import { Platform } from '../platform/platform';
/**
 * @name Haptic
 * @description
 * The `Haptic` class interacts with a haptic engine on the device, if
 * available. Generally, Ionic components use this under the hood, but you're
 * welcome to get a bit crazy with it if you fancy.
 *
 * Currently, this uses the Taptic engine on iOS.
 *
 * @usage
 * ```ts
 * export class MyClass {
 *
 *  constructor(haptic: Haptic) {
 *    haptic.selection();
 *  }
 * }
 *
 * ```
 */
import * as ɵngcc0 from '@angular/core';
export declare class Haptic {
    private _p;
    constructor(plt: Platform);
    /**
     * Check to see if the Haptic Plugin is available
     * @return {boolean} Returns true or false if the plugin is available
     *
     */
    available(): boolean;
    /**
     * Trigger a selection changed haptic event. Good for one-time events
     * (not for gestures)
     */
    selection(): void;
    /**
     * Tell the haptic engine that a gesture for a selection change is starting.
     */
    gestureSelectionStart(): void;
    /**
     * Tell the haptic engine that a selection changed during a gesture.
     */
    gestureSelectionChanged(): void;
    /**
     * Tell the haptic engine we are done with a gesture. This needs to be
     * called lest resources are not properly recycled.
     */
    gestureSelectionEnd(): void;
    /**
     * Use this to indicate success/failure/warning to the user.
     * options should be of the type `{ type: 'success' }` (or `warning`/`error`)
     */
    notification(options: {
        type: string;
    }): void;
    /**
     * Use this to indicate success/failure/warning to the user.
     * options should be of the type `{ style: 'light' }` (or `medium`/`heavy`)
     */
    impact(options: {
        style: string;
    }): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<Haptic, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<Haptic>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGFwdGljLmQudHMiLCJzb3VyY2VzIjpbImhhcHRpYy5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBsYXRmb3JtIH0gZnJvbSAnLi4vcGxhdGZvcm0vcGxhdGZvcm0nO1xuLyoqXG4gKiBAbmFtZSBIYXB0aWNcbiAqIEBkZXNjcmlwdGlvblxuICogVGhlIGBIYXB0aWNgIGNsYXNzIGludGVyYWN0cyB3aXRoIGEgaGFwdGljIGVuZ2luZSBvbiB0aGUgZGV2aWNlLCBpZlxuICogYXZhaWxhYmxlLiBHZW5lcmFsbHksIElvbmljIGNvbXBvbmVudHMgdXNlIHRoaXMgdW5kZXIgdGhlIGhvb2QsIGJ1dCB5b3UncmVcbiAqIHdlbGNvbWUgdG8gZ2V0IGEgYml0IGNyYXp5IHdpdGggaXQgaWYgeW91IGZhbmN5LlxuICpcbiAqIEN1cnJlbnRseSwgdGhpcyB1c2VzIHRoZSBUYXB0aWMgZW5naW5lIG9uIGlPUy5cbiAqXG4gKiBAdXNhZ2VcbiAqIGBgYHRzXG4gKiBleHBvcnQgY2xhc3MgTXlDbGFzcyB7XG4gKlxuICogIGNvbnN0cnVjdG9yKGhhcHRpYzogSGFwdGljKSB7XG4gKiAgICBoYXB0aWMuc2VsZWN0aW9uKCk7XG4gKiAgfVxuICogfVxuICpcbiAqIGBgYFxuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBIYXB0aWMge1xuICAgIHByaXZhdGUgX3A7XG4gICAgY29uc3RydWN0b3IocGx0OiBQbGF0Zm9ybSk7XG4gICAgLyoqXG4gICAgICogQ2hlY2sgdG8gc2VlIGlmIHRoZSBIYXB0aWMgUGx1Z2luIGlzIGF2YWlsYWJsZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBvciBmYWxzZSBpZiB0aGUgcGx1Z2luIGlzIGF2YWlsYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgYXZhaWxhYmxlKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogVHJpZ2dlciBhIHNlbGVjdGlvbiBjaGFuZ2VkIGhhcHRpYyBldmVudC4gR29vZCBmb3Igb25lLXRpbWUgZXZlbnRzXG4gICAgICogKG5vdCBmb3IgZ2VzdHVyZXMpXG4gICAgICovXG4gICAgc2VsZWN0aW9uKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogVGVsbCB0aGUgaGFwdGljIGVuZ2luZSB0aGF0IGEgZ2VzdHVyZSBmb3IgYSBzZWxlY3Rpb24gY2hhbmdlIGlzIHN0YXJ0aW5nLlxuICAgICAqL1xuICAgIGdlc3R1cmVTZWxlY3Rpb25TdGFydCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFRlbGwgdGhlIGhhcHRpYyBlbmdpbmUgdGhhdCBhIHNlbGVjdGlvbiBjaGFuZ2VkIGR1cmluZyBhIGdlc3R1cmUuXG4gICAgICovXG4gICAgZ2VzdHVyZVNlbGVjdGlvbkNoYW5nZWQoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBUZWxsIHRoZSBoYXB0aWMgZW5naW5lIHdlIGFyZSBkb25lIHdpdGggYSBnZXN0dXJlLiBUaGlzIG5lZWRzIHRvIGJlXG4gICAgICogY2FsbGVkIGxlc3QgcmVzb3VyY2VzIGFyZSBub3QgcHJvcGVybHkgcmVjeWNsZWQuXG4gICAgICovXG4gICAgZ2VzdHVyZVNlbGVjdGlvbkVuZCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIHRvIGluZGljYXRlIHN1Y2Nlc3MvZmFpbHVyZS93YXJuaW5nIHRvIHRoZSB1c2VyLlxuICAgICAqIG9wdGlvbnMgc2hvdWxkIGJlIG9mIHRoZSB0eXBlIGB7IHR5cGU6ICdzdWNjZXNzJyB9YCAob3IgYHdhcm5pbmdgL2BlcnJvcmApXG4gICAgICovXG4gICAgbm90aWZpY2F0aW9uKG9wdGlvbnM6IHtcbiAgICAgICAgdHlwZTogc3RyaW5nO1xuICAgIH0pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIHRvIGluZGljYXRlIHN1Y2Nlc3MvZmFpbHVyZS93YXJuaW5nIHRvIHRoZSB1c2VyLlxuICAgICAqIG9wdGlvbnMgc2hvdWxkIGJlIG9mIHRoZSB0eXBlIGB7IHN0eWxlOiAnbGlnaHQnIH1gIChvciBgbWVkaXVtYC9gaGVhdnlgKVxuICAgICAqL1xuICAgIGltcGFjdChvcHRpb25zOiB7XG4gICAgICAgIHN0eWxlOiBzdHJpbmc7XG4gICAgfSk6IHZvaWQ7XG59XG4iXX0=