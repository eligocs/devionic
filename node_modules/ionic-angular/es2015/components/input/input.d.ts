import { ElementRef, EventEmitter, Renderer } from '@angular/core';
import { NgControl } from '@angular/forms';
import { Subject } from 'rxjs/Subject';
import 'rxjs/add/operator/takeUntil';
import { App } from '../app/app';
import { Config } from '../../config/config';
import { Content, ContentDimensions } from '../content/content';
import { DomController } from '../../platform/dom-controller';
import { Form, IonicFormInput } from '../../util/form';
import { BaseInput } from '../../util/base-input';
import { Item } from '../item/item';
import { Platform } from '../../platform/platform';
/**
 * @name Input
 * @description
 *
 * `ion-input` is meant for text type inputs only, such as `text`,
 * `password`, `email`, `number`, `search`, `tel`, and `url`. Ionic
 * still uses an actual `<input type="text">` HTML element within the
 * component, however, with Ionic wrapping the native HTML input
 * element it's better able to handle the user experience and
 * interactivity.
 *
 * Similarly, `<ion-textarea>` should be used in place of `<textarea>`.
 *
 * An `ion-input` is **not** used for non-text type inputs, such as a
 * `checkbox`, `radio`, `toggle`, `range`, `select`, etc.
 *
 * Along with the blur/focus events, `input` support all standard text input
 * events like `keyup`, `keydown`, `keypress`, `input`, etc. Any standard event
 * can be attached and will function as expected. Example: `<ion-input (click)="someFunction()"></ion-input>`
 *
 * @usage
 * ```html
 * <ion-list>
 *   <ion-item>
 *     <ion-label color="primary">Inline Label</ion-label>
 *     <ion-input placeholder="Text Input"></ion-input>
 *   </ion-item>
 *
 *   <ion-item>
 *     <ion-label color="primary" fixed>Fixed Label</ion-label>
 *     <ion-input type="tel" placeholder="Tel Input"></ion-input>
 *   </ion-item>
 *
 *   <ion-item>
 *     <ion-input type="number" placeholder="Number Input with no label"></ion-input>
 *   </ion-item>
 *
 *   <ion-item>
 *     <ion-label color="primary" stacked>Stacked Label</ion-label>
 *     <ion-input type="email" placeholder="Email Input"></ion-input>
 *   </ion-item>
 *
 *   <ion-item>
 *     <ion-label color="primary" stacked>Stacked Label</ion-label>
 *     <ion-input type="password" placeholder="Password Input"></ion-input>
 *   </ion-item>
 *
 *   <ion-item>
 *     <ion-label color="primary" floating>Floating Label</ion-label>
 *     <ion-input></ion-input>
 *   </ion-item>
 *
 *   <ion-item>
 *     <ion-input placeholder="Clear Input" clearInput></ion-input>
 *   </ion-item>
 *
 *   <ion-item>
 *     <ion-textarea placeholder="Enter a description"></ion-textarea>
 *   </ion-item>
 * </ion-list>
 * ```
 *
 * @demo /docs/demos/src/input/
 */
import * as ɵngcc0 from '@angular/core';
export declare class TextInput extends BaseInput<string> implements IonicFormInput {
    private _plt;
    private _app;
    private _content;
    ngControl: NgControl;
    private _dom;
    _autoFocusAssist: string;
    _clearInput: boolean;
    _clearOnEdit: boolean;
    _didBlurAfterEdit: boolean;
    _readonly: boolean;
    _keyboardHeight: number;
    _type: string;
    _scrollData: ScrollData;
    _isTextarea: boolean;
    _onDestroy: Subject<void>;
    _coord: any;
    _isTouch: boolean;
    _useAssist: boolean;
    _relocated: boolean;
    /**
     * @input {boolean} If true, a clear icon will appear in the input when there is a value. Clicking it clears the input.
     */
    clearInput: any;
    /**
     * @input {string} The type of control to display. The default type is text.
     * Possible values are: `"text"`, `"password"`, `"email"`, `"number"`, `"search"`, `"tel"`, or `"url"`.
     */
    type: any;
    /**
     * @input {boolean} If true, the user cannot modify the value.
     */
    readonly: boolean;
    /**
     * @input {boolean} If true, the value will be cleared after focus upon edit.
     * Defaults to `true` when `type` is `"password"`, `false` for all other types.
     */
    clearOnEdit: any;
    /**
     * @hidden
     */
    _native: ElementRef;
    /**
     * @input {string} Set the input's autocomplete property. Values: `"on"`, `"off"`. Default `"off"`.
     */
    autocomplete: string;
    /**
     * @input {string} Set the input's autocorrect property. Values: `"on"`, `"off"`. Default `"off"`.
     */
    autocorrect: string;
    /**
     * @input {string} Instructional text that shows before the input has a value.
     */
    placeholder: string;
    /**
     * @input {any} The minimum value, which must not be greater than its maximum (max attribute) value.
     */
    min: number | string;
    /**
     * @input {any} The maximum value, which must not be less than its minimum (min attribute) value.
     */
    max: number | string;
    /**
     * @input {any} Works with the min and max attributes to limit the increments at which a value can be set.
     */
    step: number | string;
    /**
     * @hidden
     */
    input: EventEmitter<UIEvent>;
    /**
     * @hidden
     */
    blur: EventEmitter<UIEvent>;
    /**
     * @hidden
     */
    focus: EventEmitter<UIEvent>;
    constructor(config: Config, _plt: Platform, _form: Form, _app: App, elementRef: ElementRef, renderer: Renderer, _content: Content, _item: Item, ngControl: NgControl, _dom: DomController);
    ngAfterContentInit(): void;
    /**
     * @hidden
     */
    ngAfterViewInit(): void;
    /**
     * @hidden
     */
    ngOnDestroy(): void;
    /**
     * @hidden
     */
    initFocus(): void;
    /**
     * @hidden
     */
    setFocus(): void;
    /**
     * @hidden
     */
    setBlur(): void;
    /**
     * @hidden
     */
    onInput(ev: any): void;
    /**
     * @hidden
     */
    onBlur(ev: UIEvent): void;
    /**
     * @hidden
     */
    onFocus(ev: UIEvent): void;
    /**
     * @hidden
     */
    onKeydown(ev: any): void;
    /**
     * @hidden
     */
    _inputUpdated(): void;
    /**
     * @hidden
     */
    clearTextInput(): void;
    /**
    * Check if we need to clear the text input if clearOnEdit is enabled
    * @hidden
    */
    checkClearOnEdit(_: string): void;
    _getScrollData(): ScrollData;
    _relocateInput(shouldRelocate: boolean): void;
    _enableScrollPadding(): void;
    _enableHideCaretOnScroll(): void;
    _enableScrollMove(): void;
    _pointerStart(ev: UIEvent): void;
    _pointerEnd(ev: UIEvent): void;
    _jsSetFocus(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<TextInput, [null, null, null, null, null, null, { optional: true; }, { optional: true; }, { optional: true; }, null]>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<TextInput, "ion-input,ion-textarea", never, { "value": "value"; "autocomplete": "autocomplete"; "autocorrect": "autocorrect"; "placeholder": "placeholder"; "min": "min"; "max": "max"; "step": "step"; "clearInput": "clearInput"; "type": "type"; "readonly": "readonly"; "clearOnEdit": "clearOnEdit"; }, { "input": "input"; "blur": "blur"; "focus": "focus"; }, never, never>;
}
/**
 * @hidden
 */
export declare function getScrollData(inputOffsetTop: number, inputOffsetHeight: number, scrollViewDimensions: ContentDimensions, keyboardHeight: number, plaformHeight: number): ScrollData;
export interface ScrollData {
    scrollAmount: number;
    scrollTo: number;
    scrollPadding: number;
    scrollDuration: number;
    inputSafeY: number;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXQuZC50cyIsInNvdXJjZXMiOlsiaW5wdXQuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIFJlbmRlcmVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvdGFrZVVudGlsJztcbmltcG9ydCB7IEFwcCB9IGZyb20gJy4uL2FwcC9hcHAnO1xuaW1wb3J0IHsgQ29uZmlnIH0gZnJvbSAnLi4vLi4vY29uZmlnL2NvbmZpZyc7XG5pbXBvcnQgeyBDb250ZW50LCBDb250ZW50RGltZW5zaW9ucyB9IGZyb20gJy4uL2NvbnRlbnQvY29udGVudCc7XG5pbXBvcnQgeyBEb21Db250cm9sbGVyIH0gZnJvbSAnLi4vLi4vcGxhdGZvcm0vZG9tLWNvbnRyb2xsZXInO1xuaW1wb3J0IHsgRm9ybSwgSW9uaWNGb3JtSW5wdXQgfSBmcm9tICcuLi8uLi91dGlsL2Zvcm0nO1xuaW1wb3J0IHsgQmFzZUlucHV0IH0gZnJvbSAnLi4vLi4vdXRpbC9iYXNlLWlucHV0JztcbmltcG9ydCB7IEl0ZW0gfSBmcm9tICcuLi9pdGVtL2l0ZW0nO1xuaW1wb3J0IHsgUGxhdGZvcm0gfSBmcm9tICcuLi8uLi9wbGF0Zm9ybS9wbGF0Zm9ybSc7XG4vKipcbiAqIEBuYW1lIElucHV0XG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBgaW9uLWlucHV0YCBpcyBtZWFudCBmb3IgdGV4dCB0eXBlIGlucHV0cyBvbmx5LCBzdWNoIGFzIGB0ZXh0YCxcbiAqIGBwYXNzd29yZGAsIGBlbWFpbGAsIGBudW1iZXJgLCBgc2VhcmNoYCwgYHRlbGAsIGFuZCBgdXJsYC4gSW9uaWNcbiAqIHN0aWxsIHVzZXMgYW4gYWN0dWFsIGA8aW5wdXQgdHlwZT1cInRleHRcIj5gIEhUTUwgZWxlbWVudCB3aXRoaW4gdGhlXG4gKiBjb21wb25lbnQsIGhvd2V2ZXIsIHdpdGggSW9uaWMgd3JhcHBpbmcgdGhlIG5hdGl2ZSBIVE1MIGlucHV0XG4gKiBlbGVtZW50IGl0J3MgYmV0dGVyIGFibGUgdG8gaGFuZGxlIHRoZSB1c2VyIGV4cGVyaWVuY2UgYW5kXG4gKiBpbnRlcmFjdGl2aXR5LlxuICpcbiAqIFNpbWlsYXJseSwgYDxpb24tdGV4dGFyZWE+YCBzaG91bGQgYmUgdXNlZCBpbiBwbGFjZSBvZiBgPHRleHRhcmVhPmAuXG4gKlxuICogQW4gYGlvbi1pbnB1dGAgaXMgKipub3QqKiB1c2VkIGZvciBub24tdGV4dCB0eXBlIGlucHV0cywgc3VjaCBhcyBhXG4gKiBgY2hlY2tib3hgLCBgcmFkaW9gLCBgdG9nZ2xlYCwgYHJhbmdlYCwgYHNlbGVjdGAsIGV0Yy5cbiAqXG4gKiBBbG9uZyB3aXRoIHRoZSBibHVyL2ZvY3VzIGV2ZW50cywgYGlucHV0YCBzdXBwb3J0IGFsbCBzdGFuZGFyZCB0ZXh0IGlucHV0XG4gKiBldmVudHMgbGlrZSBga2V5dXBgLCBga2V5ZG93bmAsIGBrZXlwcmVzc2AsIGBpbnB1dGAsIGV0Yy4gQW55IHN0YW5kYXJkIGV2ZW50XG4gKiBjYW4gYmUgYXR0YWNoZWQgYW5kIHdpbGwgZnVuY3Rpb24gYXMgZXhwZWN0ZWQuIEV4YW1wbGU6IGA8aW9uLWlucHV0IChjbGljayk9XCJzb21lRnVuY3Rpb24oKVwiPjwvaW9uLWlucHV0PmBcbiAqXG4gKiBAdXNhZ2VcbiAqIGBgYGh0bWxcbiAqIDxpb24tbGlzdD5cbiAqICAgPGlvbi1pdGVtPlxuICogICAgIDxpb24tbGFiZWwgY29sb3I9XCJwcmltYXJ5XCI+SW5saW5lIExhYmVsPC9pb24tbGFiZWw+XG4gKiAgICAgPGlvbi1pbnB1dCBwbGFjZWhvbGRlcj1cIlRleHQgSW5wdXRcIj48L2lvbi1pbnB1dD5cbiAqICAgPC9pb24taXRlbT5cbiAqXG4gKiAgIDxpb24taXRlbT5cbiAqICAgICA8aW9uLWxhYmVsIGNvbG9yPVwicHJpbWFyeVwiIGZpeGVkPkZpeGVkIExhYmVsPC9pb24tbGFiZWw+XG4gKiAgICAgPGlvbi1pbnB1dCB0eXBlPVwidGVsXCIgcGxhY2Vob2xkZXI9XCJUZWwgSW5wdXRcIj48L2lvbi1pbnB1dD5cbiAqICAgPC9pb24taXRlbT5cbiAqXG4gKiAgIDxpb24taXRlbT5cbiAqICAgICA8aW9uLWlucHV0IHR5cGU9XCJudW1iZXJcIiBwbGFjZWhvbGRlcj1cIk51bWJlciBJbnB1dCB3aXRoIG5vIGxhYmVsXCI+PC9pb24taW5wdXQ+XG4gKiAgIDwvaW9uLWl0ZW0+XG4gKlxuICogICA8aW9uLWl0ZW0+XG4gKiAgICAgPGlvbi1sYWJlbCBjb2xvcj1cInByaW1hcnlcIiBzdGFja2VkPlN0YWNrZWQgTGFiZWw8L2lvbi1sYWJlbD5cbiAqICAgICA8aW9uLWlucHV0IHR5cGU9XCJlbWFpbFwiIHBsYWNlaG9sZGVyPVwiRW1haWwgSW5wdXRcIj48L2lvbi1pbnB1dD5cbiAqICAgPC9pb24taXRlbT5cbiAqXG4gKiAgIDxpb24taXRlbT5cbiAqICAgICA8aW9uLWxhYmVsIGNvbG9yPVwicHJpbWFyeVwiIHN0YWNrZWQ+U3RhY2tlZCBMYWJlbDwvaW9uLWxhYmVsPlxuICogICAgIDxpb24taW5wdXQgdHlwZT1cInBhc3N3b3JkXCIgcGxhY2Vob2xkZXI9XCJQYXNzd29yZCBJbnB1dFwiPjwvaW9uLWlucHV0PlxuICogICA8L2lvbi1pdGVtPlxuICpcbiAqICAgPGlvbi1pdGVtPlxuICogICAgIDxpb24tbGFiZWwgY29sb3I9XCJwcmltYXJ5XCIgZmxvYXRpbmc+RmxvYXRpbmcgTGFiZWw8L2lvbi1sYWJlbD5cbiAqICAgICA8aW9uLWlucHV0PjwvaW9uLWlucHV0PlxuICogICA8L2lvbi1pdGVtPlxuICpcbiAqICAgPGlvbi1pdGVtPlxuICogICAgIDxpb24taW5wdXQgcGxhY2Vob2xkZXI9XCJDbGVhciBJbnB1dFwiIGNsZWFySW5wdXQ+PC9pb24taW5wdXQ+XG4gKiAgIDwvaW9uLWl0ZW0+XG4gKlxuICogICA8aW9uLWl0ZW0+XG4gKiAgICAgPGlvbi10ZXh0YXJlYSBwbGFjZWhvbGRlcj1cIkVudGVyIGEgZGVzY3JpcHRpb25cIj48L2lvbi10ZXh0YXJlYT5cbiAqICAgPC9pb24taXRlbT5cbiAqIDwvaW9uLWxpc3Q+XG4gKiBgYGBcbiAqXG4gKiBAZGVtbyAvZG9jcy9kZW1vcy9zcmMvaW5wdXQvXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIFRleHRJbnB1dCBleHRlbmRzIEJhc2VJbnB1dDxzdHJpbmc+IGltcGxlbWVudHMgSW9uaWNGb3JtSW5wdXQge1xuICAgIHByaXZhdGUgX3BsdDtcbiAgICBwcml2YXRlIF9hcHA7XG4gICAgcHJpdmF0ZSBfY29udGVudDtcbiAgICBuZ0NvbnRyb2w6IE5nQ29udHJvbDtcbiAgICBwcml2YXRlIF9kb207XG4gICAgX2F1dG9Gb2N1c0Fzc2lzdDogc3RyaW5nO1xuICAgIF9jbGVhcklucHV0OiBib29sZWFuO1xuICAgIF9jbGVhck9uRWRpdDogYm9vbGVhbjtcbiAgICBfZGlkQmx1ckFmdGVyRWRpdDogYm9vbGVhbjtcbiAgICBfcmVhZG9ubHk6IGJvb2xlYW47XG4gICAgX2tleWJvYXJkSGVpZ2h0OiBudW1iZXI7XG4gICAgX3R5cGU6IHN0cmluZztcbiAgICBfc2Nyb2xsRGF0YTogU2Nyb2xsRGF0YTtcbiAgICBfaXNUZXh0YXJlYTogYm9vbGVhbjtcbiAgICBfb25EZXN0cm95OiBTdWJqZWN0PHZvaWQ+O1xuICAgIF9jb29yZDogYW55O1xuICAgIF9pc1RvdWNoOiBib29sZWFuO1xuICAgIF91c2VBc3Npc3Q6IGJvb2xlYW47XG4gICAgX3JlbG9jYXRlZDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaW5wdXQge2Jvb2xlYW59IElmIHRydWUsIGEgY2xlYXIgaWNvbiB3aWxsIGFwcGVhciBpbiB0aGUgaW5wdXQgd2hlbiB0aGVyZSBpcyBhIHZhbHVlLiBDbGlja2luZyBpdCBjbGVhcnMgdGhlIGlucHV0LlxuICAgICAqL1xuICAgIGNsZWFySW5wdXQ6IGFueTtcbiAgICAvKipcbiAgICAgKiBAaW5wdXQge3N0cmluZ30gVGhlIHR5cGUgb2YgY29udHJvbCB0byBkaXNwbGF5LiBUaGUgZGVmYXVsdCB0eXBlIGlzIHRleHQuXG4gICAgICogUG9zc2libGUgdmFsdWVzIGFyZTogYFwidGV4dFwiYCwgYFwicGFzc3dvcmRcImAsIGBcImVtYWlsXCJgLCBgXCJudW1iZXJcImAsIGBcInNlYXJjaFwiYCwgYFwidGVsXCJgLCBvciBgXCJ1cmxcImAuXG4gICAgICovXG4gICAgdHlwZTogYW55O1xuICAgIC8qKlxuICAgICAqIEBpbnB1dCB7Ym9vbGVhbn0gSWYgdHJ1ZSwgdGhlIHVzZXIgY2Fubm90IG1vZGlmeSB0aGUgdmFsdWUuXG4gICAgICovXG4gICAgcmVhZG9ubHk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGlucHV0IHtib29sZWFufSBJZiB0cnVlLCB0aGUgdmFsdWUgd2lsbCBiZSBjbGVhcmVkIGFmdGVyIGZvY3VzIHVwb24gZWRpdC5cbiAgICAgKiBEZWZhdWx0cyB0byBgdHJ1ZWAgd2hlbiBgdHlwZWAgaXMgYFwicGFzc3dvcmRcImAsIGBmYWxzZWAgZm9yIGFsbCBvdGhlciB0eXBlcy5cbiAgICAgKi9cbiAgICBjbGVhck9uRWRpdDogYW55O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBfbmF0aXZlOiBFbGVtZW50UmVmO1xuICAgIC8qKlxuICAgICAqIEBpbnB1dCB7c3RyaW5nfSBTZXQgdGhlIGlucHV0J3MgYXV0b2NvbXBsZXRlIHByb3BlcnR5LiBWYWx1ZXM6IGBcIm9uXCJgLCBgXCJvZmZcImAuIERlZmF1bHQgYFwib2ZmXCJgLlxuICAgICAqL1xuICAgIGF1dG9jb21wbGV0ZTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEBpbnB1dCB7c3RyaW5nfSBTZXQgdGhlIGlucHV0J3MgYXV0b2NvcnJlY3QgcHJvcGVydHkuIFZhbHVlczogYFwib25cImAsIGBcIm9mZlwiYC4gRGVmYXVsdCBgXCJvZmZcImAuXG4gICAgICovXG4gICAgYXV0b2NvcnJlY3Q6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBAaW5wdXQge3N0cmluZ30gSW5zdHJ1Y3Rpb25hbCB0ZXh0IHRoYXQgc2hvd3MgYmVmb3JlIHRoZSBpbnB1dCBoYXMgYSB2YWx1ZS5cbiAgICAgKi9cbiAgICBwbGFjZWhvbGRlcjogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEBpbnB1dCB7YW55fSBUaGUgbWluaW11bSB2YWx1ZSwgd2hpY2ggbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIGl0cyBtYXhpbXVtIChtYXggYXR0cmlidXRlKSB2YWx1ZS5cbiAgICAgKi9cbiAgICBtaW46IG51bWJlciB8IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBAaW5wdXQge2FueX0gVGhlIG1heGltdW0gdmFsdWUsIHdoaWNoIG11c3Qgbm90IGJlIGxlc3MgdGhhbiBpdHMgbWluaW11bSAobWluIGF0dHJpYnV0ZSkgdmFsdWUuXG4gICAgICovXG4gICAgbWF4OiBudW1iZXIgfCBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQGlucHV0IHthbnl9IFdvcmtzIHdpdGggdGhlIG1pbiBhbmQgbWF4IGF0dHJpYnV0ZXMgdG8gbGltaXQgdGhlIGluY3JlbWVudHMgYXQgd2hpY2ggYSB2YWx1ZSBjYW4gYmUgc2V0LlxuICAgICAqL1xuICAgIHN0ZXA6IG51bWJlciB8IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaW5wdXQ6IEV2ZW50RW1pdHRlcjxVSUV2ZW50PjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgYmx1cjogRXZlbnRFbWl0dGVyPFVJRXZlbnQ+O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBmb2N1czogRXZlbnRFbWl0dGVyPFVJRXZlbnQ+O1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZzogQ29uZmlnLCBfcGx0OiBQbGF0Zm9ybSwgX2Zvcm06IEZvcm0sIF9hcHA6IEFwcCwgZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcmVuZGVyZXI6IFJlbmRlcmVyLCBfY29udGVudDogQ29udGVudCwgX2l0ZW06IEl0ZW0sIG5nQ29udHJvbDogTmdDb250cm9sLCBfZG9tOiBEb21Db250cm9sbGVyKTtcbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGluaXRGb2N1cygpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXRGb2N1cygpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXRCbHVyKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uSW5wdXQoZXY6IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uQmx1cihldjogVUlFdmVudCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uRm9jdXMoZXY6IFVJRXZlbnQpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbktleWRvd24oZXY6IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIF9pbnB1dFVwZGF0ZWQoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY2xlYXJUZXh0SW5wdXQoKTogdm9pZDtcbiAgICAvKipcbiAgICAqIENoZWNrIGlmIHdlIG5lZWQgdG8gY2xlYXIgdGhlIHRleHQgaW5wdXQgaWYgY2xlYXJPbkVkaXQgaXMgZW5hYmxlZFxuICAgICogQGhpZGRlblxuICAgICovXG4gICAgY2hlY2tDbGVhck9uRWRpdChfOiBzdHJpbmcpOiB2b2lkO1xuICAgIF9nZXRTY3JvbGxEYXRhKCk6IFNjcm9sbERhdGE7XG4gICAgX3JlbG9jYXRlSW5wdXQoc2hvdWxkUmVsb2NhdGU6IGJvb2xlYW4pOiB2b2lkO1xuICAgIF9lbmFibGVTY3JvbGxQYWRkaW5nKCk6IHZvaWQ7XG4gICAgX2VuYWJsZUhpZGVDYXJldE9uU2Nyb2xsKCk6IHZvaWQ7XG4gICAgX2VuYWJsZVNjcm9sbE1vdmUoKTogdm9pZDtcbiAgICBfcG9pbnRlclN0YXJ0KGV2OiBVSUV2ZW50KTogdm9pZDtcbiAgICBfcG9pbnRlckVuZChldjogVUlFdmVudCk6IHZvaWQ7XG4gICAgX2pzU2V0Rm9jdXMoKTogdm9pZDtcbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgZGVjbGFyZSBmdW5jdGlvbiBnZXRTY3JvbGxEYXRhKGlucHV0T2Zmc2V0VG9wOiBudW1iZXIsIGlucHV0T2Zmc2V0SGVpZ2h0OiBudW1iZXIsIHNjcm9sbFZpZXdEaW1lbnNpb25zOiBDb250ZW50RGltZW5zaW9ucywga2V5Ym9hcmRIZWlnaHQ6IG51bWJlciwgcGxhZm9ybUhlaWdodDogbnVtYmVyKTogU2Nyb2xsRGF0YTtcbmV4cG9ydCBpbnRlcmZhY2UgU2Nyb2xsRGF0YSB7XG4gICAgc2Nyb2xsQW1vdW50OiBudW1iZXI7XG4gICAgc2Nyb2xsVG86IG51bWJlcjtcbiAgICBzY3JvbGxQYWRkaW5nOiBudW1iZXI7XG4gICAgc2Nyb2xsRHVyYXRpb246IG51bWJlcjtcbiAgICBpbnB1dFNhZmVZOiBudW1iZXI7XG59XG4iXX0=