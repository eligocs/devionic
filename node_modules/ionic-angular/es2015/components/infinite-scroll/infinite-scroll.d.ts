import { ElementRef, EventEmitter, NgZone } from '@angular/core';
import { Content, ScrollEvent } from '../content/content';
import { DomController } from '../../platform/dom-controller';
/**
 * @name InfiniteScroll
 * @description
 * The Infinite Scroll allows you to perform an action when the user
 * scrolls a specified distance from the bottom or top of the page.
 *
 * The expression assigned to the `infinite` event is called when
 * the user scrolls to the specified distance. When this expression
 * has finished its tasks, it should call the `complete()` method
 * on the infinite scroll instance.
 *
 * @usage
 * ```html
 * <ion-content>
 *
 *  <ion-list>
 *    <ion-item *ngFor="let i of items">{% raw %}{{i}}{% endraw %}</ion-item>
 *  </ion-list>
 *
 *  <ion-infinite-scroll (ionInfinite)="doInfinite($event)">
 *    <ion-infinite-scroll-content></ion-infinite-scroll-content>
 *  </ion-infinite-scroll>
 *
 * </ion-content>
 * ```
 *
 * ```ts
 * @Component({...})
 * export class NewsFeedPage {
 *   items = [];
 *
 *   constructor() {
 *     for (let i = 0; i < 30; i++) {
 *       this.items.push( this.items.length );
 *     }
 *   }
 *
 *   doInfinite(infiniteScroll) {
 *     console.log('Begin async operation');
 *
 *     setTimeout(() => {
 *       for (let i = 0; i < 30; i++) {
 *         this.items.push( this.items.length );
 *       }
 *
 *       console.log('Async operation has ended');
 *       infiniteScroll.complete();
 *     }, 500);
 *   }
 *
 * }
 * ```
 *
 * ## `waitFor` method of InfiniteScroll
 *
 * In case if your async operation returns promise you can utilize
 * `waitFor` method inside your template.
 *
 * ```html
 * <ion-content>
 *
 *  <ion-list>
 *    <ion-item *ngFor="let item of items">{{item}}</ion-item>
 *  </ion-list>
 *
 *  <ion-infinite-scroll (ionInfinite)="$event.waitFor(doInfinite())">
 *    <ion-infinite-scroll-content></ion-infinite-scroll-content>
 *  </ion-infinite-scroll>
 *
 * </ion-content>
 * ```
 *
 * ```ts
 * @Component({...})
 * export class NewsFeedPage {
 *   items = [];
 *
 *   constructor() {
 *     for (var i = 0; i < 30; i++) {
 *       this.items.push( this.items.length );
 *     }
 *   }
 *
 *   doInfinite(): Promise<any> {
 *     console.log('Begin async operation');
 *
 *     return new Promise((resolve) => {
 *       setTimeout(() => {
 *         for (var i = 0; i < 30; i++) {
 *           this.items.push( this.items.length );
 *         }
 *
 *         console.log('Async operation has ended');
 *         resolve();
 *       }, 500);
 *     })
 *   }
 * }
 * ```
 *
 * ## Infinite Scroll Content
 *
 * By default, Ionic uses the infinite scroll spinner that looks
 * best for the platform the user is on. However, you can change the
 * default spinner or add text by adding properties to the
 * `ion-infinite-scroll-content` component.
 *
 *  ```html
 *  <ion-content>
 *
 *    <ion-infinite-scroll (ionInfinite)="doInfinite($event)">
 *      <ion-infinite-scroll-content
 *        loadingSpinner="bubbles"
 *        loadingText="Loading more data...">
 *      </ion-infinite-scroll-content>
 *    </ion-infinite-scroll>
 *
 *  </ion-content>
 *  ```
 *
 *
 * ## Further Customizing Infinite Scroll Content
 *
 * The `ion-infinite-scroll` component holds the infinite scroll logic.
 * It requires a child component in order to display the content.
 * Ionic uses `ion-infinite-scroll-content` by default. This component
 * displays the infinite scroll and changes the look depending
 * on the infinite scroll's state. Separating these components allows
 * developers to create their own infinite scroll content components.
 * You could replace our default content with custom SVG or CSS animations.
 *
 * @demo /docs/demos/src/infinite-scroll/
 *
 */
import * as ɵngcc0 from '@angular/core';
export declare class InfiniteScroll {
    private _content;
    private _zone;
    private _elementRef;
    private _dom;
    _lastCheck: number;
    _highestY: number;
    _scLsn: any;
    _thr: string;
    _thrPx: number;
    _thrPc: number;
    _position: string;
    _init: boolean;
    /**
     * @internal
     */
    state: string;
    /**
     * @input {string} The threshold distance from the bottom
     * of the content to call the `infinite` output event when scrolled.
     * The threshold value can be either a percent, or
     * in pixels. For example, use the value of `10%` for the `infinite`
     * output event to get called when the user has scrolled 10%
     * from the bottom of the page. Use the value `100px` when the
     * scroll is within 100 pixels from the bottom of the page.
     * Default is `15%`.
     */
    threshold: string;
    /**
     * @input {boolean} If true, Whether or not the infinite scroll should be
     * enabled or not. Setting to `false` will remove scroll event listeners
     * and hide the display.
     */
    enabled: boolean;
    /**
     * @input {string} The position of the infinite scroll element.
     * The value can be either `top` or `bottom`.
     * Default is `bottom`.
     */
    position: string;
    /**
     * @output {event} Emitted when the scroll reaches
     * the threshold distance. From within your infinite handler,
     * you must call the infinite scroll's `complete()` method when
     * your async operation has completed.
     */
    ionInfinite: EventEmitter<InfiniteScroll>;
    constructor(_content: Content, _zone: NgZone, _elementRef: ElementRef, _dom: DomController);
    _onScroll(ev: ScrollEvent): 1 | 2 | 3 | 5 | 6;
    /**
     * Call `complete()` within the `infinite` output event handler when
     * your async operation has completed. For example, the `loading`
     * state is while the app is performing an asynchronous operation,
     * such as receiving more data from an AJAX request to add more items
     * to a data list. Once the data has been received and UI updated, you
     * then call this method to signify that the loading has completed.
     * This method will change the infinite scroll's state from `loading`
     * to `enabled`.
     */
    complete(): void;
    /**
    * Pass a promise inside `waitFor()` within the `infinite` output event handler in order to
    * change state of infiniteScroll to "complete"
    */
    waitFor(action: Promise<any>): void;
    /**
     * Call `enable(false)` to disable the infinite scroll from actively
     * trying to receive new data while scrolling. This method is useful
     * when it is known that there is no more data that can be added, and
     * the infinite scroll is no longer needed.
     * @param {boolean} shouldEnable  If the infinite scroll should be
     * enabled or not. Setting to `false` will remove scroll event listeners
     * and hide the display.
     */
    enable(shouldEnable: boolean): void;
    /**
     * @hidden
     */
    _setListeners(shouldListen: boolean): void;
    /**
     * @hidden
     */
    ngAfterContentInit(): void;
    /**
     * @hidden
     */
    ngOnDestroy(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<InfiniteScroll, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<InfiniteScroll, "ion-infinite-scroll", never, { "threshold": "threshold"; "enabled": "enabled"; "position": "position"; }, { "ionInfinite": "ionInfinite"; }, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5maW5pdGUtc2Nyb2xsLmQudHMiLCJzb3VyY2VzIjpbImluZmluaXRlLXNjcm9sbC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250ZW50LCBTY3JvbGxFdmVudCB9IGZyb20gJy4uL2NvbnRlbnQvY29udGVudCc7XG5pbXBvcnQgeyBEb21Db250cm9sbGVyIH0gZnJvbSAnLi4vLi4vcGxhdGZvcm0vZG9tLWNvbnRyb2xsZXInO1xuLyoqXG4gKiBAbmFtZSBJbmZpbml0ZVNjcm9sbFxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGUgSW5maW5pdGUgU2Nyb2xsIGFsbG93cyB5b3UgdG8gcGVyZm9ybSBhbiBhY3Rpb24gd2hlbiB0aGUgdXNlclxuICogc2Nyb2xscyBhIHNwZWNpZmllZCBkaXN0YW5jZSBmcm9tIHRoZSBib3R0b20gb3IgdG9wIG9mIHRoZSBwYWdlLlxuICpcbiAqIFRoZSBleHByZXNzaW9uIGFzc2lnbmVkIHRvIHRoZSBgaW5maW5pdGVgIGV2ZW50IGlzIGNhbGxlZCB3aGVuXG4gKiB0aGUgdXNlciBzY3JvbGxzIHRvIHRoZSBzcGVjaWZpZWQgZGlzdGFuY2UuIFdoZW4gdGhpcyBleHByZXNzaW9uXG4gKiBoYXMgZmluaXNoZWQgaXRzIHRhc2tzLCBpdCBzaG91bGQgY2FsbCB0aGUgYGNvbXBsZXRlKClgIG1ldGhvZFxuICogb24gdGhlIGluZmluaXRlIHNjcm9sbCBpbnN0YW5jZS5cbiAqXG4gKiBAdXNhZ2VcbiAqIGBgYGh0bWxcbiAqIDxpb24tY29udGVudD5cbiAqXG4gKiAgPGlvbi1saXN0PlxuICogICAgPGlvbi1pdGVtICpuZ0Zvcj1cImxldCBpIG9mIGl0ZW1zXCI+eyUgcmF3ICV9e3tpfX17JSBlbmRyYXcgJX08L2lvbi1pdGVtPlxuICogIDwvaW9uLWxpc3Q+XG4gKlxuICogIDxpb24taW5maW5pdGUtc2Nyb2xsIChpb25JbmZpbml0ZSk9XCJkb0luZmluaXRlKCRldmVudClcIj5cbiAqICAgIDxpb24taW5maW5pdGUtc2Nyb2xsLWNvbnRlbnQ+PC9pb24taW5maW5pdGUtc2Nyb2xsLWNvbnRlbnQ+XG4gKiAgPC9pb24taW5maW5pdGUtc2Nyb2xsPlxuICpcbiAqIDwvaW9uLWNvbnRlbnQ+XG4gKiBgYGBcbiAqXG4gKiBgYGB0c1xuICogQENvbXBvbmVudCh7Li4ufSlcbiAqIGV4cG9ydCBjbGFzcyBOZXdzRmVlZFBhZ2Uge1xuICogICBpdGVtcyA9IFtdO1xuICpcbiAqICAgY29uc3RydWN0b3IoKSB7XG4gKiAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMDsgaSsrKSB7XG4gKiAgICAgICB0aGlzLml0ZW1zLnB1c2goIHRoaXMuaXRlbXMubGVuZ3RoICk7XG4gKiAgICAgfVxuICogICB9XG4gKlxuICogICBkb0luZmluaXRlKGluZmluaXRlU2Nyb2xsKSB7XG4gKiAgICAgY29uc29sZS5sb2coJ0JlZ2luIGFzeW5jIG9wZXJhdGlvbicpO1xuICpcbiAqICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAqICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzA7IGkrKykge1xuICogICAgICAgICB0aGlzLml0ZW1zLnB1c2goIHRoaXMuaXRlbXMubGVuZ3RoICk7XG4gKiAgICAgICB9XG4gKlxuICogICAgICAgY29uc29sZS5sb2coJ0FzeW5jIG9wZXJhdGlvbiBoYXMgZW5kZWQnKTtcbiAqICAgICAgIGluZmluaXRlU2Nyb2xsLmNvbXBsZXRlKCk7XG4gKiAgICAgfSwgNTAwKTtcbiAqICAgfVxuICpcbiAqIH1cbiAqIGBgYFxuICpcbiAqICMjIGB3YWl0Rm9yYCBtZXRob2Qgb2YgSW5maW5pdGVTY3JvbGxcbiAqXG4gKiBJbiBjYXNlIGlmIHlvdXIgYXN5bmMgb3BlcmF0aW9uIHJldHVybnMgcHJvbWlzZSB5b3UgY2FuIHV0aWxpemVcbiAqIGB3YWl0Rm9yYCBtZXRob2QgaW5zaWRlIHlvdXIgdGVtcGxhdGUuXG4gKlxuICogYGBgaHRtbFxuICogPGlvbi1jb250ZW50PlxuICpcbiAqICA8aW9uLWxpc3Q+XG4gKiAgICA8aW9uLWl0ZW0gKm5nRm9yPVwibGV0IGl0ZW0gb2YgaXRlbXNcIj57e2l0ZW19fTwvaW9uLWl0ZW0+XG4gKiAgPC9pb24tbGlzdD5cbiAqXG4gKiAgPGlvbi1pbmZpbml0ZS1zY3JvbGwgKGlvbkluZmluaXRlKT1cIiRldmVudC53YWl0Rm9yKGRvSW5maW5pdGUoKSlcIj5cbiAqICAgIDxpb24taW5maW5pdGUtc2Nyb2xsLWNvbnRlbnQ+PC9pb24taW5maW5pdGUtc2Nyb2xsLWNvbnRlbnQ+XG4gKiAgPC9pb24taW5maW5pdGUtc2Nyb2xsPlxuICpcbiAqIDwvaW9uLWNvbnRlbnQ+XG4gKiBgYGBcbiAqXG4gKiBgYGB0c1xuICogQENvbXBvbmVudCh7Li4ufSlcbiAqIGV4cG9ydCBjbGFzcyBOZXdzRmVlZFBhZ2Uge1xuICogICBpdGVtcyA9IFtdO1xuICpcbiAqICAgY29uc3RydWN0b3IoKSB7XG4gKiAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMDsgaSsrKSB7XG4gKiAgICAgICB0aGlzLml0ZW1zLnB1c2goIHRoaXMuaXRlbXMubGVuZ3RoICk7XG4gKiAgICAgfVxuICogICB9XG4gKlxuICogICBkb0luZmluaXRlKCk6IFByb21pc2U8YW55PiB7XG4gKiAgICAgY29uc29sZS5sb2coJ0JlZ2luIGFzeW5jIG9wZXJhdGlvbicpO1xuICpcbiAqICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAqICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICogICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDMwOyBpKyspIHtcbiAqICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2goIHRoaXMuaXRlbXMubGVuZ3RoICk7XG4gKiAgICAgICAgIH1cbiAqXG4gKiAgICAgICAgIGNvbnNvbGUubG9nKCdBc3luYyBvcGVyYXRpb24gaGFzIGVuZGVkJyk7XG4gKiAgICAgICAgIHJlc29sdmUoKTtcbiAqICAgICAgIH0sIDUwMCk7XG4gKiAgICAgfSlcbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogIyMgSW5maW5pdGUgU2Nyb2xsIENvbnRlbnRcbiAqXG4gKiBCeSBkZWZhdWx0LCBJb25pYyB1c2VzIHRoZSBpbmZpbml0ZSBzY3JvbGwgc3Bpbm5lciB0aGF0IGxvb2tzXG4gKiBiZXN0IGZvciB0aGUgcGxhdGZvcm0gdGhlIHVzZXIgaXMgb24uIEhvd2V2ZXIsIHlvdSBjYW4gY2hhbmdlIHRoZVxuICogZGVmYXVsdCBzcGlubmVyIG9yIGFkZCB0ZXh0IGJ5IGFkZGluZyBwcm9wZXJ0aWVzIHRvIHRoZVxuICogYGlvbi1pbmZpbml0ZS1zY3JvbGwtY29udGVudGAgY29tcG9uZW50LlxuICpcbiAqICBgYGBodG1sXG4gKiAgPGlvbi1jb250ZW50PlxuICpcbiAqICAgIDxpb24taW5maW5pdGUtc2Nyb2xsIChpb25JbmZpbml0ZSk9XCJkb0luZmluaXRlKCRldmVudClcIj5cbiAqICAgICAgPGlvbi1pbmZpbml0ZS1zY3JvbGwtY29udGVudFxuICogICAgICAgIGxvYWRpbmdTcGlubmVyPVwiYnViYmxlc1wiXG4gKiAgICAgICAgbG9hZGluZ1RleHQ9XCJMb2FkaW5nIG1vcmUgZGF0YS4uLlwiPlxuICogICAgICA8L2lvbi1pbmZpbml0ZS1zY3JvbGwtY29udGVudD5cbiAqICAgIDwvaW9uLWluZmluaXRlLXNjcm9sbD5cbiAqXG4gKiAgPC9pb24tY29udGVudD5cbiAqICBgYGBcbiAqXG4gKlxuICogIyMgRnVydGhlciBDdXN0b21pemluZyBJbmZpbml0ZSBTY3JvbGwgQ29udGVudFxuICpcbiAqIFRoZSBgaW9uLWluZmluaXRlLXNjcm9sbGAgY29tcG9uZW50IGhvbGRzIHRoZSBpbmZpbml0ZSBzY3JvbGwgbG9naWMuXG4gKiBJdCByZXF1aXJlcyBhIGNoaWxkIGNvbXBvbmVudCBpbiBvcmRlciB0byBkaXNwbGF5IHRoZSBjb250ZW50LlxuICogSW9uaWMgdXNlcyBgaW9uLWluZmluaXRlLXNjcm9sbC1jb250ZW50YCBieSBkZWZhdWx0LiBUaGlzIGNvbXBvbmVudFxuICogZGlzcGxheXMgdGhlIGluZmluaXRlIHNjcm9sbCBhbmQgY2hhbmdlcyB0aGUgbG9vayBkZXBlbmRpbmdcbiAqIG9uIHRoZSBpbmZpbml0ZSBzY3JvbGwncyBzdGF0ZS4gU2VwYXJhdGluZyB0aGVzZSBjb21wb25lbnRzIGFsbG93c1xuICogZGV2ZWxvcGVycyB0byBjcmVhdGUgdGhlaXIgb3duIGluZmluaXRlIHNjcm9sbCBjb250ZW50IGNvbXBvbmVudHMuXG4gKiBZb3UgY291bGQgcmVwbGFjZSBvdXIgZGVmYXVsdCBjb250ZW50IHdpdGggY3VzdG9tIFNWRyBvciBDU1MgYW5pbWF0aW9ucy5cbiAqXG4gKiBAZGVtbyAvZG9jcy9kZW1vcy9zcmMvaW5maW5pdGUtc2Nyb2xsL1xuICpcbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgSW5maW5pdGVTY3JvbGwge1xuICAgIHByaXZhdGUgX2NvbnRlbnQ7XG4gICAgcHJpdmF0ZSBfem9uZTtcbiAgICBwcml2YXRlIF9lbGVtZW50UmVmO1xuICAgIHByaXZhdGUgX2RvbTtcbiAgICBfbGFzdENoZWNrOiBudW1iZXI7XG4gICAgX2hpZ2hlc3RZOiBudW1iZXI7XG4gICAgX3NjTHNuOiBhbnk7XG4gICAgX3Rocjogc3RyaW5nO1xuICAgIF90aHJQeDogbnVtYmVyO1xuICAgIF90aHJQYzogbnVtYmVyO1xuICAgIF9wb3NpdGlvbjogc3RyaW5nO1xuICAgIF9pbml0OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRlOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQGlucHV0IHtzdHJpbmd9IFRoZSB0aHJlc2hvbGQgZGlzdGFuY2UgZnJvbSB0aGUgYm90dG9tXG4gICAgICogb2YgdGhlIGNvbnRlbnQgdG8gY2FsbCB0aGUgYGluZmluaXRlYCBvdXRwdXQgZXZlbnQgd2hlbiBzY3JvbGxlZC5cbiAgICAgKiBUaGUgdGhyZXNob2xkIHZhbHVlIGNhbiBiZSBlaXRoZXIgYSBwZXJjZW50LCBvclxuICAgICAqIGluIHBpeGVscy4gRm9yIGV4YW1wbGUsIHVzZSB0aGUgdmFsdWUgb2YgYDEwJWAgZm9yIHRoZSBgaW5maW5pdGVgXG4gICAgICogb3V0cHV0IGV2ZW50IHRvIGdldCBjYWxsZWQgd2hlbiB0aGUgdXNlciBoYXMgc2Nyb2xsZWQgMTAlXG4gICAgICogZnJvbSB0aGUgYm90dG9tIG9mIHRoZSBwYWdlLiBVc2UgdGhlIHZhbHVlIGAxMDBweGAgd2hlbiB0aGVcbiAgICAgKiBzY3JvbGwgaXMgd2l0aGluIDEwMCBwaXhlbHMgZnJvbSB0aGUgYm90dG9tIG9mIHRoZSBwYWdlLlxuICAgICAqIERlZmF1bHQgaXMgYDE1JWAuXG4gICAgICovXG4gICAgdGhyZXNob2xkOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQGlucHV0IHtib29sZWFufSBJZiB0cnVlLCBXaGV0aGVyIG9yIG5vdCB0aGUgaW5maW5pdGUgc2Nyb2xsIHNob3VsZCBiZVxuICAgICAqIGVuYWJsZWQgb3Igbm90LiBTZXR0aW5nIHRvIGBmYWxzZWAgd2lsbCByZW1vdmUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqIGFuZCBoaWRlIHRoZSBkaXNwbGF5LlxuICAgICAqL1xuICAgIGVuYWJsZWQ6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGlucHV0IHtzdHJpbmd9IFRoZSBwb3NpdGlvbiBvZiB0aGUgaW5maW5pdGUgc2Nyb2xsIGVsZW1lbnQuXG4gICAgICogVGhlIHZhbHVlIGNhbiBiZSBlaXRoZXIgYHRvcGAgb3IgYGJvdHRvbWAuXG4gICAgICogRGVmYXVsdCBpcyBgYm90dG9tYC5cbiAgICAgKi9cbiAgICBwb3NpdGlvbjogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEBvdXRwdXQge2V2ZW50fSBFbWl0dGVkIHdoZW4gdGhlIHNjcm9sbCByZWFjaGVzXG4gICAgICogdGhlIHRocmVzaG9sZCBkaXN0YW5jZS4gRnJvbSB3aXRoaW4geW91ciBpbmZpbml0ZSBoYW5kbGVyLFxuICAgICAqIHlvdSBtdXN0IGNhbGwgdGhlIGluZmluaXRlIHNjcm9sbCdzIGBjb21wbGV0ZSgpYCBtZXRob2Qgd2hlblxuICAgICAqIHlvdXIgYXN5bmMgb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgaW9uSW5maW5pdGU6IEV2ZW50RW1pdHRlcjxJbmZpbml0ZVNjcm9sbD47XG4gICAgY29uc3RydWN0b3IoX2NvbnRlbnQ6IENvbnRlbnQsIF96b25lOiBOZ1pvbmUsIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLCBfZG9tOiBEb21Db250cm9sbGVyKTtcbiAgICBfb25TY3JvbGwoZXY6IFNjcm9sbEV2ZW50KTogMSB8IDIgfCAzIHwgNSB8IDY7XG4gICAgLyoqXG4gICAgICogQ2FsbCBgY29tcGxldGUoKWAgd2l0aGluIHRoZSBgaW5maW5pdGVgIG91dHB1dCBldmVudCBoYW5kbGVyIHdoZW5cbiAgICAgKiB5b3VyIGFzeW5jIG9wZXJhdGlvbiBoYXMgY29tcGxldGVkLiBGb3IgZXhhbXBsZSwgdGhlIGBsb2FkaW5nYFxuICAgICAqIHN0YXRlIGlzIHdoaWxlIHRoZSBhcHAgaXMgcGVyZm9ybWluZyBhbiBhc3luY2hyb25vdXMgb3BlcmF0aW9uLFxuICAgICAqIHN1Y2ggYXMgcmVjZWl2aW5nIG1vcmUgZGF0YSBmcm9tIGFuIEFKQVggcmVxdWVzdCB0byBhZGQgbW9yZSBpdGVtc1xuICAgICAqIHRvIGEgZGF0YSBsaXN0LiBPbmNlIHRoZSBkYXRhIGhhcyBiZWVuIHJlY2VpdmVkIGFuZCBVSSB1cGRhdGVkLCB5b3VcbiAgICAgKiB0aGVuIGNhbGwgdGhpcyBtZXRob2QgdG8gc2lnbmlmeSB0aGF0IHRoZSBsb2FkaW5nIGhhcyBjb21wbGV0ZWQuXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBjaGFuZ2UgdGhlIGluZmluaXRlIHNjcm9sbCdzIHN0YXRlIGZyb20gYGxvYWRpbmdgXG4gICAgICogdG8gYGVuYWJsZWRgLlxuICAgICAqL1xuICAgIGNvbXBsZXRlKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgKiBQYXNzIGEgcHJvbWlzZSBpbnNpZGUgYHdhaXRGb3IoKWAgd2l0aGluIHRoZSBgaW5maW5pdGVgIG91dHB1dCBldmVudCBoYW5kbGVyIGluIG9yZGVyIHRvXG4gICAgKiBjaGFuZ2Ugc3RhdGUgb2YgaW5maW5pdGVTY3JvbGwgdG8gXCJjb21wbGV0ZVwiXG4gICAgKi9cbiAgICB3YWl0Rm9yKGFjdGlvbjogUHJvbWlzZTxhbnk+KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBDYWxsIGBlbmFibGUoZmFsc2UpYCB0byBkaXNhYmxlIHRoZSBpbmZpbml0ZSBzY3JvbGwgZnJvbSBhY3RpdmVseVxuICAgICAqIHRyeWluZyB0byByZWNlaXZlIG5ldyBkYXRhIHdoaWxlIHNjcm9sbGluZy4gVGhpcyBtZXRob2QgaXMgdXNlZnVsXG4gICAgICogd2hlbiBpdCBpcyBrbm93biB0aGF0IHRoZXJlIGlzIG5vIG1vcmUgZGF0YSB0aGF0IGNhbiBiZSBhZGRlZCwgYW5kXG4gICAgICogdGhlIGluZmluaXRlIHNjcm9sbCBpcyBubyBsb25nZXIgbmVlZGVkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkRW5hYmxlICBJZiB0aGUgaW5maW5pdGUgc2Nyb2xsIHNob3VsZCBiZVxuICAgICAqIGVuYWJsZWQgb3Igbm90LiBTZXR0aW5nIHRvIGBmYWxzZWAgd2lsbCByZW1vdmUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqIGFuZCBoaWRlIHRoZSBkaXNwbGF5LlxuICAgICAqL1xuICAgIGVuYWJsZShzaG91bGRFbmFibGU6IGJvb2xlYW4pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBfc2V0TGlzdGVuZXJzKHNob3VsZExpc3RlbjogYm9vbGVhbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xufVxuIl19