import { ElementRef, EventEmitter, NgZone, QueryList, Renderer } from '@angular/core';
import { Ion } from '../ion';
import { Config } from '../../config/config';
import { Platform } from '../../platform/platform';
/**
 * @hidden
 */
import * as ɵngcc0 from '@angular/core';
export declare abstract class RootNode {
    abstract getElementRef(): ElementRef;
    abstract initPane(): boolean;
    abstract paneChanged?(visible: boolean): void;
}
/**
 * @name SplitPane
 *
 * @description
 * SplitPane is a component that makes it possible to create multi-view layout.
 * Similar to iPad apps, SplitPane allows UI elements, like Menus, to be
 * displayed as the viewport increases.
 *
 * If the devices screen size is below a certain size, the SplitPane will
 * collapse and the menu will become hidden again. This is especially useful when
 * creating an app that will be served over a browser or deployed through the app
 * store to phones and tablets.
 *
 * @usage
 * To use SplitPane, simply add the component around your root component.
 * In this example, we'll be using a sidemenu layout, similar to what is
 * provided from the sidemenu starter template.
 *
 *  ```html
 *  <ion-split-pane>
 *    <!--  our side menu  -->
 *    <ion-menu [content]="content">
 *      <ion-header>
 *        <ion-toolbar>
 *          <ion-title>Menu</ion-title>
 *        </ion-toolbar>
 *      </ion-header>
 *    </ion-menu>
 *
 *    <!-- the main content -->
 *    <ion-nav [root]="root" main #content></ion-nav>
 *  </ion-split-pane>
 *  ```
 *
 *  Here, SplitPane will look for the element with the `main` attribute and make
 *  that the central component on larger screens. The `main` component can be any
 *  Ionic component (`ion-nav` or `ion-tabs`) except `ion-menu`.
 *
 *  ### Setting breakpoints
 *
 *  By default, SplitPane will expand when the screen is larger than 768px.
 *  If you want to customize this, use the `when` input. The `when` input can
 *  accept any valid media query, as it uses `matchMedia()` underneath.
 *
 *  ```
 *  <ion-split-pane when="(min-width: 475px)">
 *
 *    <!--  our side menu  -->
 *    <ion-menu [content]="content">
 *    ....
 *    </ion-menu>
 *
 *    <!-- the main content -->
 *    <ion-nav [root]="root" main #content></ion-nav>
 *  </ion-split-pane>
 *  ```
 *
 *  SplitPane also provides some predefined media queries that can be used.
 *
 *  ```html
 *  <!-- could be "xs", "sm", "md", "lg", or "xl" -->
 *  <ion-split-pane when="lg">
 *  ...
 *  </ion-split-pane>
 *  ```
 *
 *
 *  | Size | Value                 | Description                                                           |
 *  |------|-----------------------|-----------------------------------------------------------------------|
 *  | `xs` | `(min-width: 0px)`    | Show the split-pane when the min-width is 0px (meaning, always)       |
 *  | `sm` | `(min-width: 576px)`  | Show the split-pane when the min-width is 576px                       |
 *  | `md` | `(min-width: 768px)`  | Show the split-pane when the min-width is 768px (default break point) |
 *  | `lg` | `(min-width: 992px)`  | Show the split-pane when the min-width is 992px                       |
 *  | `xl` | `(min-width: 1200px)` | Show the split-pane when the min-width is 1200px                      |
 *
 *  You can also pass in boolean values that will trigger SplitPane when the value
 *  or expression evaluates to true.
 *
 *
 *  ```html
 *  <ion-split-pane [when]="isLarge">
 *  ...
 *  </ion-split-pane>
 *  ```
 *
 *  ```ts
 *  class MyClass {
 *    public isLarge = false;
 *    constructor(){}
 *  }
 *  ```
 *
 *  Or
 *
 *  ```html
 *  <ion-split-pane [when]="shouldShow()">
 *  ...
 *  </ion-split-pane>
 *  ```
 *
 *  ```ts
 *  class MyClass {
 *    constructor(){}
 *    shouldShow(){
 *      if(conditionA){
 *        return true
 *      } else {
 *        return false
 *      }
 *    }
 *  }
 *  ```
 *
 */
export declare class SplitPane extends Ion implements RootNode {
    private _zone;
    private _plt;
    _init: boolean;
    _visible: boolean;
    _isEnabled: boolean;
    _rmListener: any;
    _mediaQuery: string | boolean;
    _children: RootNode[];
    /**
     * @hidden
     */
    sideContent: RootNode;
    /**
     * @hidden
     */
    mainContent: RootNode;
    /**
     * @hidden
     */
    _setchildren: QueryList<RootNode>;
    /**
     * @input {string | boolean} When the split-pane should be shown.
     * Can be a CSS media query expression, or a shortcut expression.
     * Can also be a boolean expression.
     */
    when: string | boolean;
    /**
     * @input {boolean} If `false`, the split-pane is disabled, ie. the side pane will
     * never be displayed. Default `true`.
     */
    enabled: boolean;
    /**
     * @output {any} Expression to be called when the split-pane visibility has changed
     */
    ionChange: EventEmitter<SplitPane>;
    constructor(_zone: NgZone, _plt: Platform, config: Config, elementRef: ElementRef, renderer: Renderer);
    /**
     * @hidden
     */
    _register(node: RootNode, isMain: boolean, callback: Function): boolean;
    /**
     * @hidden
     */
    ngAfterViewInit(): void;
    /**
     * @hidden
     */
    _update(): void;
    /**
     * @hidden
     */
    _updateChildren(): void;
    /**
     * @hidden
     */
    _setVisible(visible: boolean): void;
    /**
     * @hidden
     */
    isVisible(): boolean;
    /**
     * @hidden
     */
    setElementClass(className: string, add: boolean): void;
    /**
     * @hidden
     */
    _setPaneCSSClass(elementRef: ElementRef, isMain: boolean): void;
    /**
     * @hidden
     */
    ngOnDestroy(): void;
    /**
     * @hidden
     */
    initPane(): boolean;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<SplitPane, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<SplitPane, "ion-split-pane", never, { "when": "when"; "enabled": "enabled"; }, { "ionChange": "ionChange"; }, ["_setchildren"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3BsaXQtcGFuZS5kLnRzIiwic291cmNlcyI6WyJzcGxpdC1wYW5lLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBOZ1pvbmUsIFF1ZXJ5TGlzdCwgUmVuZGVyZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElvbiB9IGZyb20gJy4uL2lvbic7XG5pbXBvcnQgeyBDb25maWcgfSBmcm9tICcuLi8uLi9jb25maWcvY29uZmlnJztcbmltcG9ydCB7IFBsYXRmb3JtIH0gZnJvbSAnLi4vLi4vcGxhdGZvcm0vcGxhdGZvcm0nO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGFic3RyYWN0IGNsYXNzIFJvb3ROb2RlIHtcbiAgICBhYnN0cmFjdCBnZXRFbGVtZW50UmVmKCk6IEVsZW1lbnRSZWY7XG4gICAgYWJzdHJhY3QgaW5pdFBhbmUoKTogYm9vbGVhbjtcbiAgICBhYnN0cmFjdCBwYW5lQ2hhbmdlZD8odmlzaWJsZTogYm9vbGVhbik6IHZvaWQ7XG59XG4vKipcbiAqIEBuYW1lIFNwbGl0UGFuZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogU3BsaXRQYW5lIGlzIGEgY29tcG9uZW50IHRoYXQgbWFrZXMgaXQgcG9zc2libGUgdG8gY3JlYXRlIG11bHRpLXZpZXcgbGF5b3V0LlxuICogU2ltaWxhciB0byBpUGFkIGFwcHMsIFNwbGl0UGFuZSBhbGxvd3MgVUkgZWxlbWVudHMsIGxpa2UgTWVudXMsIHRvIGJlXG4gKiBkaXNwbGF5ZWQgYXMgdGhlIHZpZXdwb3J0IGluY3JlYXNlcy5cbiAqXG4gKiBJZiB0aGUgZGV2aWNlcyBzY3JlZW4gc2l6ZSBpcyBiZWxvdyBhIGNlcnRhaW4gc2l6ZSwgdGhlIFNwbGl0UGFuZSB3aWxsXG4gKiBjb2xsYXBzZSBhbmQgdGhlIG1lbnUgd2lsbCBiZWNvbWUgaGlkZGVuIGFnYWluLiBUaGlzIGlzIGVzcGVjaWFsbHkgdXNlZnVsIHdoZW5cbiAqIGNyZWF0aW5nIGFuIGFwcCB0aGF0IHdpbGwgYmUgc2VydmVkIG92ZXIgYSBicm93c2VyIG9yIGRlcGxveWVkIHRocm91Z2ggdGhlIGFwcFxuICogc3RvcmUgdG8gcGhvbmVzIGFuZCB0YWJsZXRzLlxuICpcbiAqIEB1c2FnZVxuICogVG8gdXNlIFNwbGl0UGFuZSwgc2ltcGx5IGFkZCB0aGUgY29tcG9uZW50IGFyb3VuZCB5b3VyIHJvb3QgY29tcG9uZW50LlxuICogSW4gdGhpcyBleGFtcGxlLCB3ZSdsbCBiZSB1c2luZyBhIHNpZGVtZW51IGxheW91dCwgc2ltaWxhciB0byB3aGF0IGlzXG4gKiBwcm92aWRlZCBmcm9tIHRoZSBzaWRlbWVudSBzdGFydGVyIHRlbXBsYXRlLlxuICpcbiAqICBgYGBodG1sXG4gKiAgPGlvbi1zcGxpdC1wYW5lPlxuICogICAgPCEtLSAgb3VyIHNpZGUgbWVudSAgLS0+XG4gKiAgICA8aW9uLW1lbnUgW2NvbnRlbnRdPVwiY29udGVudFwiPlxuICogICAgICA8aW9uLWhlYWRlcj5cbiAqICAgICAgICA8aW9uLXRvb2xiYXI+XG4gKiAgICAgICAgICA8aW9uLXRpdGxlPk1lbnU8L2lvbi10aXRsZT5cbiAqICAgICAgICA8L2lvbi10b29sYmFyPlxuICogICAgICA8L2lvbi1oZWFkZXI+XG4gKiAgICA8L2lvbi1tZW51PlxuICpcbiAqICAgIDwhLS0gdGhlIG1haW4gY29udGVudCAtLT5cbiAqICAgIDxpb24tbmF2IFtyb290XT1cInJvb3RcIiBtYWluICNjb250ZW50PjwvaW9uLW5hdj5cbiAqICA8L2lvbi1zcGxpdC1wYW5lPlxuICogIGBgYFxuICpcbiAqICBIZXJlLCBTcGxpdFBhbmUgd2lsbCBsb29rIGZvciB0aGUgZWxlbWVudCB3aXRoIHRoZSBgbWFpbmAgYXR0cmlidXRlIGFuZCBtYWtlXG4gKiAgdGhhdCB0aGUgY2VudHJhbCBjb21wb25lbnQgb24gbGFyZ2VyIHNjcmVlbnMuIFRoZSBgbWFpbmAgY29tcG9uZW50IGNhbiBiZSBhbnlcbiAqICBJb25pYyBjb21wb25lbnQgKGBpb24tbmF2YCBvciBgaW9uLXRhYnNgKSBleGNlcHQgYGlvbi1tZW51YC5cbiAqXG4gKiAgIyMjIFNldHRpbmcgYnJlYWtwb2ludHNcbiAqXG4gKiAgQnkgZGVmYXVsdCwgU3BsaXRQYW5lIHdpbGwgZXhwYW5kIHdoZW4gdGhlIHNjcmVlbiBpcyBsYXJnZXIgdGhhbiA3NjhweC5cbiAqICBJZiB5b3Ugd2FudCB0byBjdXN0b21pemUgdGhpcywgdXNlIHRoZSBgd2hlbmAgaW5wdXQuIFRoZSBgd2hlbmAgaW5wdXQgY2FuXG4gKiAgYWNjZXB0IGFueSB2YWxpZCBtZWRpYSBxdWVyeSwgYXMgaXQgdXNlcyBgbWF0Y2hNZWRpYSgpYCB1bmRlcm5lYXRoLlxuICpcbiAqICBgYGBcbiAqICA8aW9uLXNwbGl0LXBhbmUgd2hlbj1cIihtaW4td2lkdGg6IDQ3NXB4KVwiPlxuICpcbiAqICAgIDwhLS0gIG91ciBzaWRlIG1lbnUgIC0tPlxuICogICAgPGlvbi1tZW51IFtjb250ZW50XT1cImNvbnRlbnRcIj5cbiAqICAgIC4uLi5cbiAqICAgIDwvaW9uLW1lbnU+XG4gKlxuICogICAgPCEtLSB0aGUgbWFpbiBjb250ZW50IC0tPlxuICogICAgPGlvbi1uYXYgW3Jvb3RdPVwicm9vdFwiIG1haW4gI2NvbnRlbnQ+PC9pb24tbmF2PlxuICogIDwvaW9uLXNwbGl0LXBhbmU+XG4gKiAgYGBgXG4gKlxuICogIFNwbGl0UGFuZSBhbHNvIHByb3ZpZGVzIHNvbWUgcHJlZGVmaW5lZCBtZWRpYSBxdWVyaWVzIHRoYXQgY2FuIGJlIHVzZWQuXG4gKlxuICogIGBgYGh0bWxcbiAqICA8IS0tIGNvdWxkIGJlIFwieHNcIiwgXCJzbVwiLCBcIm1kXCIsIFwibGdcIiwgb3IgXCJ4bFwiIC0tPlxuICogIDxpb24tc3BsaXQtcGFuZSB3aGVuPVwibGdcIj5cbiAqICAuLi5cbiAqICA8L2lvbi1zcGxpdC1wYW5lPlxuICogIGBgYFxuICpcbiAqXG4gKiAgfCBTaXplIHwgVmFsdWUgICAgICAgICAgICAgICAgIHwgRGVzY3JpcHRpb24gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8LS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogIHwgYHhzYCB8IGAobWluLXdpZHRoOiAwcHgpYCAgICB8IFNob3cgdGhlIHNwbGl0LXBhbmUgd2hlbiB0aGUgbWluLXdpZHRoIGlzIDBweCAobWVhbmluZywgYWx3YXlzKSAgICAgICB8XG4gKiAgfCBgc21gIHwgYChtaW4td2lkdGg6IDU3NnB4KWAgIHwgU2hvdyB0aGUgc3BsaXQtcGFuZSB3aGVuIHRoZSBtaW4td2lkdGggaXMgNTc2cHggICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8IGBtZGAgfCBgKG1pbi13aWR0aDogNzY4cHgpYCAgfCBTaG93IHRoZSBzcGxpdC1wYW5lIHdoZW4gdGhlIG1pbi13aWR0aCBpcyA3NjhweCAoZGVmYXVsdCBicmVhayBwb2ludCkgfFxuICogIHwgYGxnYCB8IGAobWluLXdpZHRoOiA5OTJweClgICB8IFNob3cgdGhlIHNwbGl0LXBhbmUgd2hlbiB0aGUgbWluLXdpZHRoIGlzIDk5MnB4ICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgfCBgeGxgIHwgYChtaW4td2lkdGg6IDEyMDBweClgIHwgU2hvdyB0aGUgc3BsaXQtcGFuZSB3aGVuIHRoZSBtaW4td2lkdGggaXMgMTIwMHB4ICAgICAgICAgICAgICAgICAgICAgIHxcbiAqXG4gKiAgWW91IGNhbiBhbHNvIHBhc3MgaW4gYm9vbGVhbiB2YWx1ZXMgdGhhdCB3aWxsIHRyaWdnZXIgU3BsaXRQYW5lIHdoZW4gdGhlIHZhbHVlXG4gKiAgb3IgZXhwcmVzc2lvbiBldmFsdWF0ZXMgdG8gdHJ1ZS5cbiAqXG4gKlxuICogIGBgYGh0bWxcbiAqICA8aW9uLXNwbGl0LXBhbmUgW3doZW5dPVwiaXNMYXJnZVwiPlxuICogIC4uLlxuICogIDwvaW9uLXNwbGl0LXBhbmU+XG4gKiAgYGBgXG4gKlxuICogIGBgYHRzXG4gKiAgY2xhc3MgTXlDbGFzcyB7XG4gKiAgICBwdWJsaWMgaXNMYXJnZSA9IGZhbHNlO1xuICogICAgY29uc3RydWN0b3IoKXt9XG4gKiAgfVxuICogIGBgYFxuICpcbiAqICBPclxuICpcbiAqICBgYGBodG1sXG4gKiAgPGlvbi1zcGxpdC1wYW5lIFt3aGVuXT1cInNob3VsZFNob3coKVwiPlxuICogIC4uLlxuICogIDwvaW9uLXNwbGl0LXBhbmU+XG4gKiAgYGBgXG4gKlxuICogIGBgYHRzXG4gKiAgY2xhc3MgTXlDbGFzcyB7XG4gKiAgICBjb25zdHJ1Y3Rvcigpe31cbiAqICAgIHNob3VsZFNob3coKXtcbiAqICAgICAgaWYoY29uZGl0aW9uQSl7XG4gKiAgICAgICAgcmV0dXJuIHRydWVcbiAqICAgICAgfSBlbHNlIHtcbiAqICAgICAgICByZXR1cm4gZmFsc2VcbiAqICAgICAgfVxuICogICAgfVxuICogIH1cbiAqICBgYGBcbiAqXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIFNwbGl0UGFuZSBleHRlbmRzIElvbiBpbXBsZW1lbnRzIFJvb3ROb2RlIHtcbiAgICBwcml2YXRlIF96b25lO1xuICAgIHByaXZhdGUgX3BsdDtcbiAgICBfaW5pdDogYm9vbGVhbjtcbiAgICBfdmlzaWJsZTogYm9vbGVhbjtcbiAgICBfaXNFbmFibGVkOiBib29sZWFuO1xuICAgIF9ybUxpc3RlbmVyOiBhbnk7XG4gICAgX21lZGlhUXVlcnk6IHN0cmluZyB8IGJvb2xlYW47XG4gICAgX2NoaWxkcmVuOiBSb290Tm9kZVtdO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzaWRlQ29udGVudDogUm9vdE5vZGU7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG1haW5Db250ZW50OiBSb290Tm9kZTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgX3NldGNoaWxkcmVuOiBRdWVyeUxpc3Q8Um9vdE5vZGU+O1xuICAgIC8qKlxuICAgICAqIEBpbnB1dCB7c3RyaW5nIHwgYm9vbGVhbn0gV2hlbiB0aGUgc3BsaXQtcGFuZSBzaG91bGQgYmUgc2hvd24uXG4gICAgICogQ2FuIGJlIGEgQ1NTIG1lZGlhIHF1ZXJ5IGV4cHJlc3Npb24sIG9yIGEgc2hvcnRjdXQgZXhwcmVzc2lvbi5cbiAgICAgKiBDYW4gYWxzbyBiZSBhIGJvb2xlYW4gZXhwcmVzc2lvbi5cbiAgICAgKi9cbiAgICB3aGVuOiBzdHJpbmcgfCBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEBpbnB1dCB7Ym9vbGVhbn0gSWYgYGZhbHNlYCwgdGhlIHNwbGl0LXBhbmUgaXMgZGlzYWJsZWQsIGllLiB0aGUgc2lkZSBwYW5lIHdpbGxcbiAgICAgKiBuZXZlciBiZSBkaXNwbGF5ZWQuIERlZmF1bHQgYHRydWVgLlxuICAgICAqL1xuICAgIGVuYWJsZWQ6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQG91dHB1dCB7YW55fSBFeHByZXNzaW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBzcGxpdC1wYW5lIHZpc2liaWxpdHkgaGFzIGNoYW5nZWRcbiAgICAgKi9cbiAgICBpb25DaGFuZ2U6IEV2ZW50RW1pdHRlcjxTcGxpdFBhbmU+O1xuICAgIGNvbnN0cnVjdG9yKF96b25lOiBOZ1pvbmUsIF9wbHQ6IFBsYXRmb3JtLCBjb25maWc6IENvbmZpZywgZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcmVuZGVyZXI6IFJlbmRlcmVyKTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgX3JlZ2lzdGVyKG5vZGU6IFJvb3ROb2RlLCBpc01haW46IGJvb2xlYW4sIGNhbGxiYWNrOiBGdW5jdGlvbik6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBfdXBkYXRlKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIF91cGRhdGVDaGlsZHJlbigpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBfc2V0VmlzaWJsZSh2aXNpYmxlOiBib29sZWFuKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaXNWaXNpYmxlKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNldEVsZW1lbnRDbGFzcyhjbGFzc05hbWU6IHN0cmluZywgYWRkOiBib29sZWFuKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgX3NldFBhbmVDU1NDbGFzcyhlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBpc01haW46IGJvb2xlYW4pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBpbml0UGFuZSgpOiBib29sZWFuO1xufVxuIl19