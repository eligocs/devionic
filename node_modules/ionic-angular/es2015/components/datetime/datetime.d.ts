import { AfterContentInit, ElementRef, EventEmitter, OnDestroy, Renderer } from '@angular/core';
import { ControlValueAccessor } from '@angular/forms';
import { Config } from '../../config/config';
import { Picker } from '../picker/picker';
import { PickerController } from '../picker/picker-controller';
import { Form } from '../../util/form';
import { BaseInput } from '../../util/base-input';
import { Item } from '../item/item';
import { DateTimeData, LocaleData } from '../../util/datetime-util';
/**
 * @name DateTime
 * @description
 * The DateTime component is used to present an interface which makes it easy for
 * users to select dates and times. Tapping on `<ion-datetime>` will display a picker
 * interface that slides up from the bottom of the page. The picker then displays
 * scrollable columns that can be used to individually select years, months, days,
 * hours and minute values. The DateTime component is similar to the native
 * `<input type="datetime-local">` element, however, Ionic's DateTime component makes
 * it easy to display the date and time in a preferred format, and manage the datetime
 * values.
 *
 * ```html
 * <ion-item>
 *   <ion-label>Date</ion-label>
 *   <ion-datetime displayFormat="MM/DD/YYYY" [(ngModel)]="myDate"></ion-datetime>
 * </ion-item>
 * ```
 *
 *
 * ## Display and Picker Formats
 *
 * The DateTime component displays the values in two places: in the `<ion-datetime>`
 * component, and in the interface that is presented from the bottom of the screen.
 * The following chart lists all of the formats that can be used.
 *
 * | Format  | Description                    | Example                 |
 * |---------|--------------------------------|-------------------------|
 * | `YYYY`  | Year, 4 digits                 | `2018`                  |
 * | `YY`    | Year, 2 digits                 | `18`                    |
 * | `M`     | Month                          | `1` ... `12`            |
 * | `MM`    | Month, leading zero            | `01` ... `12`           |
 * | `MMM`   | Month, short name              | `Jan`                   |
 * | `MMMM`  | Month, full name               | `January`               |
 * | `D`     | Day                            | `1` ... `31`            |
 * | `DD`    | Day, leading zero              | `01` ... `31`           |
 * | `DDD`   | Day, short name                | `Fri`                   |
 * | `DDDD`  | Day, full name                 | `Friday`                |
 * | `H`     | Hour, 24-hour                  | `0` ... `23`            |
 * | `HH`    | Hour, 24-hour, leading zero    | `00` ... `23`           |
 * | `h`     | Hour, 12-hour                  | `1` ... `12`            |
 * | `hh`    | Hour, 12-hour, leading zero    | `01` ... `12`           |
 * | `a`     | 12-hour time period, lowercase | `am` `pm`               |
 * | `A`     | 12-hour time period, uppercase | `AM` `PM`               |
 * | `m`     | Minute                         | `1` ... `59`            |
 * | `mm`    | Minute, leading zero           | `01` ... `59`           |
 * | `s`     | Second                         | `1` ... `59`            |
 * | `ss`    | Second, leading zero           | `01` ... `59`           |
 * | `Z`     | UTC Timezone Offset            | `Z or +HH:mm or -HH:mm` |
 *
 * **Important**: See the [Month Names and Day of the Week Names](#month-names-and-day-of-the-week-names)
 * section below on how to use different names for the month and day.
 *
 * ### Display Format
 *
 * The `displayFormat` input property specifies how a datetime's value should be
 * printed, as formatted text, within the `ion-datetime` component.
 *
 * In the following example, the display in the `<ion-datetime>` will use the
 * month's short name, the numerical day with a leading zero, a comma and the
 * four-digit year. In addition to the date, it will display the time with the hours
 * in the 24-hour format and the minutes. Any character can be used as a separator.
 * An example display using this format is: `Jun 17, 2005 11:06`.
 *
 * ```html
 * <ion-item>
 *   <ion-label>Date</ion-label>
 *   <ion-datetime displayFormat="MMM DD, YYYY HH:mm" [(ngModel)]="myDate"></ion-datetime>
 * </ion-item>
 * ```
 *
 * ### Picker Format
 *
 * The `pickerFormat` input property determines which columns should be shown in the
 * interface, the order of the columns, and which format to use within each column.
 * If the `pickerFormat` input is not provided then it will default to the `displayFormat`.
 *
 * In the following example, the display in the `<ion-datetime>` will use the
 * `MM/YYYY` format, such as `06/2020`. However, the picker interface
 * will display two columns with the month's long name, and the four-digit year.
 *
 * ```html
 * <ion-item>
 *   <ion-label>Date</ion-label>
 *   <ion-datetime displayFormat="MM/YYYY" pickerFormat="MMMM YYYY" [(ngModel)]="myDate"></ion-datetime>
 * </ion-item>
 * ```
 *
 * ### Datetime Data
 *
 * Historically, handling datetime values within JavaScript, or even within HTML
 * inputs, has always been a challenge. Specifically, JavaScript's `Date` object is
 * notoriously difficult to correctly parse apart datetime strings or to format
 * datetime values. Even worse is how different browsers and JavaScript versions
 * parse various datetime strings differently, especially per locale.
 *
 * But no worries, all is not lost! Ionic's datetime input has been designed so
 * developers can avoid the common pitfalls, allowing developers to easily format
 * datetime values within the input, and give the user a simple datetime picker for a
 * great user experience.
 *
 * ##### ISO 8601 Datetime Format: YYYY-MM-DDTHH:mmZ
 *
 * Ionic uses the [ISO 8601 datetime format](https://www.w3.org/TR/NOTE-datetime)
 * for its value. The value is simply a string, rather than using JavaScript's `Date`
 * object. Additionally, when using the ISO datetime format, it makes it easier
 * to serialize and pass within JSON objects, and sending databases a standardized
 * format which it can be easily parsed if need be.
 *
 * To create an ISO datetime string for the current date and time, e.g. use `const currentDate = (new Date()).toISOString();`.
 *
 * An ISO format can be used as a simple year, or just the hour and minute, or get more
 * detailed down to the millisecond and timezone. Any of the ISO formats below can be used,
 * and after a user selects a new value, Ionic will continue to use the same ISO format
 * which datetime value was originally given as.
 *
 * | Description          | Format                 | Datetime Value Example       |
 * |----------------------|------------------------|------------------------------|
 * | Year                 | YYYY                   | 1994                         |
 * | Year and Month       | YYYY-MM                | 1994-12                      |
 * | Complete Date        | YYYY-MM-DD             | 1994-12-15                   |
 * | Date and Time        | YYYY-MM-DDTHH:mm       | 1994-12-15T13:47             |
 * | UTC Timezone         | YYYY-MM-DDTHH:mm:ssTZD | 1994-12-15T13:47:20.789Z     |
 * | Timezone Offset      | YYYY-MM-DDTHH:mm:ssTZD | 1994-12-15T13:47:20.789+5:00 |
 * | Hour and Minute      | HH:mm                  | 13:47                        |
 * | Hour, Minute, Second | HH:mm:ss               | 13:47:20                     |
 *
 * Note that the year is always four-digits, milliseconds (if it's added) is always
 * three-digits, and all others are always two-digits. So the number representing
 * January always has a leading zero, such as `01`. Additionally, the hour is always
 * in the 24-hour format, so `00` is `12am` on a 12-hour clock, `13` means `1pm`,
 * and `23` means `11pm`.
 *
 * It's also important to note that neither the `displayFormat` or `pickerFormat` can
 * set the datetime value's output, which is the value that is set by the component's
 * `ngModel`. The format's are merely for displaying the value as text and the picker's
 * interface, but the datetime's value is always persisted as a valid ISO 8601 datetime
 * string.
 *
 *
 * ## Min and Max Datetimes
 *
 * Dates are infinite in either direction, so for a user's selection there should be at
 * least some form of restricting the dates that can be selected. By default, the maximum
 * date is to the end of the current year, and the minimum date is from the beginning
 * of the year that was 100 years ago.
 *
 * To customize the minimum and maximum datetime values, the `min` and `max` component
 * inputs can be provided which may make more sense for the app's use-case, rather
 * than the default of the last 100 years. Following the same IS0 8601 format listed
 * in the table above, each component can restrict which dates can be selected by the
 * user. Below is an example of restricting the date selection between the beginning
 * of 2016, and October 31st of 2020:
 *
 * ```html
 * <ion-item>
 *   <ion-label>Date</ion-label>
 *   <ion-datetime displayFormat="MMMM YYYY" min="2016" max="2020-10-31" [(ngModel)]="myDate">
 *   </ion-datetime>
 * </ion-item>
 * ```
 *
 *
 * ## Month Names and Day of the Week Names
 *
 * At this time, there is no one-size-fits-all standard to automatically choose the correct
 * language/spelling for a month name, or day of the week name, depending on the language
 * or locale. Good news is that there is an
 * [Intl.DateTimeFormat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat)
 * standard which *most* browsers have adopted. However, at this time the standard has not
 * been fully implemented by all popular browsers so Ionic is unavailable to take advantage
 * of it *yet*. Additionally, Angular also provides an internationalization service, but it
 * is still under heavy development so Ionic does not depend on it at this time.
 *
 * All things considered, the by far easiest solution is to just provide an array of names
 * if the app needs to use names other than the default English version of month and day
 * names. The month names and day names can be either configured at the app level, or
 * individual `ion-datetime` level.
 *
 * ### App Config Level
 *
 * ```ts
 * //app.module.ts
 * @NgModule({
 * ...,
 * imports: [
 *   IonicModule.forRoot(MyApp, {
 *   monthNames: ['janeiro', 'fevereiro', 'mar\u00e7o', ... ],
 *   monthShortNames: ['jan', 'fev', 'mar', ... ],
 *   dayNames: ['domingo', 'segunda-feira', 'ter\u00e7a-feira', ... ],
 *   dayShortNames: ['dom', 'seg', 'ter', ... ],
 * })
 * ],
 * ...
 * })
 * ```
 *
 * ### Component Input Level
 *
 * ```html
 * <ion-item>
 *   <ion-label>Período</ion-label>
 *   <ion-datetime displayFormat="DDDD MMM D, YYYY" [(ngModel)]="myDate"
 *     monthNames="janeiro, fevereiro, mar\u00e7o, ..."
 *     monthShortNames="jan, fev, mar, ..."
 *     dayNames="domingo, segunda-feira, ter\u00e7a-feira, ..."
 *     dayShortNames="dom, seg, ter, ..."></ion-datetime>
 * </ion-item>
 * ```
 *
 *
 * ### Advanced Datetime Validation and Manipulation
 *
 * The datetime picker provides the simplicity of selecting an exact format, and persists
 * the datetime values as a string using the standardized
 * [ISO 8601 datetime format](https://www.w3.org/TR/NOTE-datetime).
 * However, it's important to note that `ion-datetime` does not attempt to solve all
 * situtations when validating and manipulating datetime values. If datetime values need
 * to be parsed from a certain format, or manipulated (such as adding 5 days to a date,
 * subtracting 30 minutes, etc.), or even formatting data to a specific locale, then we highly
 * recommend using [moment.js](http://momentjs.com/) to "Parse, validate, manipulate, and
 * display dates in JavaScript". [Moment.js](http://momentjs.com/) has quickly become
 * our goto standard when dealing with datetimes within JavaScript, but Ionic does not
 * prepackage this dependency since most apps will not require it, and its locale
 * configuration should be decided by the end-developer.
 *
 *
 * @usage
 * ```html
 * <ion-item>
 *   <ion-label>Date</ion-label>
 *   <ion-datetime displayFormat="MM/DD/YYYY" [(ngModel)]="myDate">
 *   </ion-datetime>
 * </ion-item>
 * ```
 *
 *
 * @demo /docs/demos/src/datetime/
 */
import * as ɵngcc0 from '@angular/core';
export declare class DateTime extends BaseInput<DateTimeData> implements AfterContentInit, ControlValueAccessor, OnDestroy {
    private _pickerCtrl;
    _text: string;
    _min: DateTimeData;
    _max: DateTimeData;
    _locale: LocaleData;
    _picker: Picker;
    /**
     * @input {string} The minimum datetime allowed. Value must be a date string
     * following the
     * [ISO 8601 datetime format standard](https://www.w3.org/TR/NOTE-datetime),
     * such as `1996-12-19`. The format does not have to be specific to an exact
     * datetime. For example, the minimum could just be the year, such as `1994`.
     * Defaults to the beginning of the year, 100 years ago from today.
     */
    min: string;
    /**
     * @input {string} The maximum datetime allowed. Value must be a date string
     * following the
     * [ISO 8601 datetime format standard](https://www.w3.org/TR/NOTE-datetime),
     * `1996-12-19`. The format does not have to be specific to an exact
     * datetime. For example, the maximum could just be the year, such as `1994`.
     * Defaults to the end of this year.
     */
    max: string;
    /**
     * @input {string} The display format of the date and time as text that shows
     * within the item. When the `pickerFormat` input is not used, then the
     * `displayFormat` is used for both display the formatted text, and determining
     * the datetime picker's columns. See the `pickerFormat` input description for
     * more info. Defaults to `MMM D, YYYY`.
     */
    displayFormat: string;
    /**
     * @input {string} The default datetime selected in picker modal if field value is empty.
     * Value must be a date string following the
     * [ISO 8601 datetime format standard](https://www.w3.org/TR/NOTE-datetime),
     * `1996-12-19`.
     */
    initialValue: string;
    /**
     * @input {string} The format of the date and time picker columns the user selects.
     * A datetime input can have one or many datetime parts, each getting their
     * own column which allow individual selection of that particular datetime part. For
     * example, year and month columns are two individually selectable columns which help
     * choose an exact date from the datetime picker. Each column follows the string
     * parse format. Defaults to use `displayFormat`.
     */
    pickerFormat: string;
    /**
     * @input {string} The text to display on the picker's cancel button. Default: `Cancel`.
     */
    cancelText: string;
    /**
     * @input {string} The text to display on the picker's "Done" button. Default: `Done`.
     */
    doneText: string;
    /**
     * @input {array | string} Values used to create the list of selectable years. By default
     * the year values range between the `min` and `max` datetime inputs. However, to
     * control exactly which years to display, the `yearValues` input can take either an array
     * of numbers, or string of comma separated numbers. For example, to show upcoming and
     * recent leap years, then this input's value would be `yearValues="2024,2020,2016,2012,2008"`.
     */
    yearValues: any;
    /**
     * @input {array | string} Values used to create the list of selectable months. By default
     * the month values range from `1` to `12`. However, to control exactly which months to
     * display, the `monthValues` input can take either an array of numbers, or string of
     * comma separated numbers. For example, if only summer months should be shown, then this
     * input value would be `monthValues="6,7,8"`. Note that month numbers do *not* have a
     * zero-based index, meaning January's value is `1`, and December's is `12`.
     */
    monthValues: any;
    /**
     * @input {array | string} Values used to create the list of selectable days. By default
     * every day is shown for the given month. However, to control exactly which days of
     * the month to display, the `dayValues` input can take either an array of numbers, or
     * string of comma separated numbers. Note that even if the array days have an invalid
     * number for the selected month, like `31` in February, it will correctly not show
     * days which are not valid for the selected month.
     */
    dayValues: any;
    /**
     * @input {array | string} Values used to create the list of selectable hours. By default
     * the hour values range from `0` to `23` for 24-hour, or `1` to `12` for 12-hour. However,
     * to control exactly which hours to display, the `hourValues` input can take either an
     * array of numbers, or string of comma separated numbers.
     */
    hourValues: any;
    /**
     * @input {array | string} Values used to create the list of selectable minutes. By default
     * the mintues range from `0` to `59`. However, to control exactly which minutes to display,
     * the `minuteValues` input can take either an array of numbers, or string of comma separated
     * numbers. For example, if the minute selections should only be every 15 minutes, then
     * this input value would be `minuteValues="0,15,30,45"`.
     */
    minuteValues: any;
    /**
     * @input {array} Full names for each month name. This can be used to provide
     * locale month names. Defaults to English.
     */
    monthNames: any;
    /**
     * @input {array} Short abbreviated names for each month name. This can be used to provide
     * locale month names. Defaults to English.
     */
    monthShortNames: any;
    /**
     * @input {array} Full day of the week names. This can be used to provide
     * locale names for each day in the week. Defaults to English.
     */
    dayNames: any;
    /**
     * @input {array} Short abbreviated day of the week names. This can be used to provide
     * locale names for each day in the week. Defaults to English.
     */
    dayShortNames: any;
    /**
     * @input {any} Any additional options that the picker interface can accept.
     * See the [Picker API docs](../../picker/Picker) for the picker options.
     */
    pickerOptions: any;
    /**
     * @input {string} The text to display when there's no date selected yet.
     * Using lowercase to match the input attribute
     */
    placeholder: string;
    /**
     * @output {any} Emitted when the datetime selection was cancelled.
     */
    ionCancel: EventEmitter<any>;
    constructor(form: Form, config: Config, elementRef: ElementRef, renderer: Renderer, item: Item, _pickerCtrl: PickerController);
    /**
     * @hidden
     */
    ngAfterContentInit(): void;
    /**
     * @hidden
     */
    _inputNormalize(val: any): DateTimeData;
    /**
     * @hidden
     */
    _inputUpdated(): void;
    /**
     * @hidden
     */
    _inputShouldChange(): boolean;
    /**
     * TODO: REMOVE THIS
     * @hidden
     */
    _inputChangeEvent(): any;
    /**
     * @hidden
     */
    _inputNgModelEvent(): any;
    _click(ev: UIEvent): void;
    _keyup(): void;
    /**
     * @hidden
     */
    open(): void;
    /**
     * @hidden
     */
    generate(): void;
    /**
     * @hidden
     */
    validateColumn(name: string, index: number, min: number, max: number, lowerBounds: number[], upperBounds: number[]): number;
    /**
     * @private
     */
    validate(): void;
    /**
     * @hidden
     */
    divyColumns(): void;
    /**
     * @hidden
     */
    updateText(): void;
    /**
     * @hidden
     */
    getValue(): DateTimeData;
    /**
     * @hidden
     */
    getValueOrDefault(): DateTimeData;
    /**
     * Get the default value as a date string
     * @hidden
     */
    getDefaultValueDateString(): string;
    /**
     * @hidden
     */
    hasValue(): boolean;
    /**
     * @hidden
     */
    calcMinMax(now?: Date): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<DateTime, [null, null, null, null, { optional: true; }, { optional: true; }]>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<DateTime, "ion-datetime", never, { "cancelText": "cancelText"; "doneText": "doneText"; "pickerOptions": "pickerOptions"; "placeholder": "placeholder"; "min": "min"; "max": "max"; "displayFormat": "displayFormat"; "initialValue": "initialValue"; "pickerFormat": "pickerFormat"; "yearValues": "yearValues"; "monthValues": "monthValues"; "dayValues": "dayValues"; "hourValues": "hourValues"; "minuteValues": "minuteValues"; "monthNames": "monthNames"; "monthShortNames": "monthShortNames"; "dayNames": "dayNames"; "dayShortNames": "dayShortNames"; }, { "ionCancel": "ionCancel"; }, never, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXRpbWUuZC50cyIsInNvdXJjZXMiOlsiZGF0ZXRpbWUuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFmdGVyQ29udGVudEluaXQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgT25EZXN0cm95LCBSZW5kZXJlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBDb25maWcgfSBmcm9tICcuLi8uLi9jb25maWcvY29uZmlnJztcbmltcG9ydCB7IFBpY2tlciB9IGZyb20gJy4uL3BpY2tlci9waWNrZXInO1xuaW1wb3J0IHsgUGlja2VyQ29udHJvbGxlciB9IGZyb20gJy4uL3BpY2tlci9waWNrZXItY29udHJvbGxlcic7XG5pbXBvcnQgeyBGb3JtIH0gZnJvbSAnLi4vLi4vdXRpbC9mb3JtJztcbmltcG9ydCB7IEJhc2VJbnB1dCB9IGZyb20gJy4uLy4uL3V0aWwvYmFzZS1pbnB1dCc7XG5pbXBvcnQgeyBJdGVtIH0gZnJvbSAnLi4vaXRlbS9pdGVtJztcbmltcG9ydCB7IERhdGVUaW1lRGF0YSwgTG9jYWxlRGF0YSB9IGZyb20gJy4uLy4uL3V0aWwvZGF0ZXRpbWUtdXRpbCc7XG4vKipcbiAqIEBuYW1lIERhdGVUaW1lXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoZSBEYXRlVGltZSBjb21wb25lbnQgaXMgdXNlZCB0byBwcmVzZW50IGFuIGludGVyZmFjZSB3aGljaCBtYWtlcyBpdCBlYXN5IGZvclxuICogdXNlcnMgdG8gc2VsZWN0IGRhdGVzIGFuZCB0aW1lcy4gVGFwcGluZyBvbiBgPGlvbi1kYXRldGltZT5gIHdpbGwgZGlzcGxheSBhIHBpY2tlclxuICogaW50ZXJmYWNlIHRoYXQgc2xpZGVzIHVwIGZyb20gdGhlIGJvdHRvbSBvZiB0aGUgcGFnZS4gVGhlIHBpY2tlciB0aGVuIGRpc3BsYXlzXG4gKiBzY3JvbGxhYmxlIGNvbHVtbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBpbmRpdmlkdWFsbHkgc2VsZWN0IHllYXJzLCBtb250aHMsIGRheXMsXG4gKiBob3VycyBhbmQgbWludXRlIHZhbHVlcy4gVGhlIERhdGVUaW1lIGNvbXBvbmVudCBpcyBzaW1pbGFyIHRvIHRoZSBuYXRpdmVcbiAqIGA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCI+YCBlbGVtZW50LCBob3dldmVyLCBJb25pYydzIERhdGVUaW1lIGNvbXBvbmVudCBtYWtlc1xuICogaXQgZWFzeSB0byBkaXNwbGF5IHRoZSBkYXRlIGFuZCB0aW1lIGluIGEgcHJlZmVycmVkIGZvcm1hdCwgYW5kIG1hbmFnZSB0aGUgZGF0ZXRpbWVcbiAqIHZhbHVlcy5cbiAqXG4gKiBgYGBodG1sXG4gKiA8aW9uLWl0ZW0+XG4gKiAgIDxpb24tbGFiZWw+RGF0ZTwvaW9uLWxhYmVsPlxuICogICA8aW9uLWRhdGV0aW1lIGRpc3BsYXlGb3JtYXQ9XCJNTS9ERC9ZWVlZXCIgWyhuZ01vZGVsKV09XCJteURhdGVcIj48L2lvbi1kYXRldGltZT5cbiAqIDwvaW9uLWl0ZW0+XG4gKiBgYGBcbiAqXG4gKlxuICogIyMgRGlzcGxheSBhbmQgUGlja2VyIEZvcm1hdHNcbiAqXG4gKiBUaGUgRGF0ZVRpbWUgY29tcG9uZW50IGRpc3BsYXlzIHRoZSB2YWx1ZXMgaW4gdHdvIHBsYWNlczogaW4gdGhlIGA8aW9uLWRhdGV0aW1lPmBcbiAqIGNvbXBvbmVudCwgYW5kIGluIHRoZSBpbnRlcmZhY2UgdGhhdCBpcyBwcmVzZW50ZWQgZnJvbSB0aGUgYm90dG9tIG9mIHRoZSBzY3JlZW4uXG4gKiBUaGUgZm9sbG93aW5nIGNoYXJ0IGxpc3RzIGFsbCBvZiB0aGUgZm9ybWF0cyB0aGF0IGNhbiBiZSB1c2VkLlxuICpcbiAqIHwgRm9ybWF0ICB8IERlc2NyaXB0aW9uICAgICAgICAgICAgICAgICAgICB8IEV4YW1wbGUgICAgICAgICAgICAgICAgIHxcbiAqIHwtLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwgYFlZWVlgICB8IFllYXIsIDQgZGlnaXRzICAgICAgICAgICAgICAgICB8IGAyMDE4YCAgICAgICAgICAgICAgICAgIHxcbiAqIHwgYFlZYCAgICB8IFllYXIsIDIgZGlnaXRzICAgICAgICAgICAgICAgICB8IGAxOGAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgYE1gICAgICB8IE1vbnRoICAgICAgICAgICAgICAgICAgICAgICAgICB8IGAxYCAuLi4gYDEyYCAgICAgICAgICAgIHxcbiAqIHwgYE1NYCAgICB8IE1vbnRoLCBsZWFkaW5nIHplcm8gICAgICAgICAgICB8IGAwMWAgLi4uIGAxMmAgICAgICAgICAgIHxcbiAqIHwgYE1NTWAgICB8IE1vbnRoLCBzaG9ydCBuYW1lICAgICAgICAgICAgICB8IGBKYW5gICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgYE1NTU1gICB8IE1vbnRoLCBmdWxsIG5hbWUgICAgICAgICAgICAgICB8IGBKYW51YXJ5YCAgICAgICAgICAgICAgIHxcbiAqIHwgYERgICAgICB8IERheSAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGAxYCAuLi4gYDMxYCAgICAgICAgICAgIHxcbiAqIHwgYEREYCAgICB8IERheSwgbGVhZGluZyB6ZXJvICAgICAgICAgICAgICB8IGAwMWAgLi4uIGAzMWAgICAgICAgICAgIHxcbiAqIHwgYERERGAgICB8IERheSwgc2hvcnQgbmFtZSAgICAgICAgICAgICAgICB8IGBGcmlgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgYERERERgICB8IERheSwgZnVsbCBuYW1lICAgICAgICAgICAgICAgICB8IGBGcmlkYXlgICAgICAgICAgICAgICAgIHxcbiAqIHwgYEhgICAgICB8IEhvdXIsIDI0LWhvdXIgICAgICAgICAgICAgICAgICB8IGAwYCAuLi4gYDIzYCAgICAgICAgICAgIHxcbiAqIHwgYEhIYCAgICB8IEhvdXIsIDI0LWhvdXIsIGxlYWRpbmcgemVybyAgICB8IGAwMGAgLi4uIGAyM2AgICAgICAgICAgIHxcbiAqIHwgYGhgICAgICB8IEhvdXIsIDEyLWhvdXIgICAgICAgICAgICAgICAgICB8IGAxYCAuLi4gYDEyYCAgICAgICAgICAgIHxcbiAqIHwgYGhoYCAgICB8IEhvdXIsIDEyLWhvdXIsIGxlYWRpbmcgemVybyAgICB8IGAwMWAgLi4uIGAxMmAgICAgICAgICAgIHxcbiAqIHwgYGFgICAgICB8IDEyLWhvdXIgdGltZSBwZXJpb2QsIGxvd2VyY2FzZSB8IGBhbWAgYHBtYCAgICAgICAgICAgICAgIHxcbiAqIHwgYEFgICAgICB8IDEyLWhvdXIgdGltZSBwZXJpb2QsIHVwcGVyY2FzZSB8IGBBTWAgYFBNYCAgICAgICAgICAgICAgIHxcbiAqIHwgYG1gICAgICB8IE1pbnV0ZSAgICAgICAgICAgICAgICAgICAgICAgICB8IGAxYCAuLi4gYDU5YCAgICAgICAgICAgIHxcbiAqIHwgYG1tYCAgICB8IE1pbnV0ZSwgbGVhZGluZyB6ZXJvICAgICAgICAgICB8IGAwMWAgLi4uIGA1OWAgICAgICAgICAgIHxcbiAqIHwgYHNgICAgICB8IFNlY29uZCAgICAgICAgICAgICAgICAgICAgICAgICB8IGAxYCAuLi4gYDU5YCAgICAgICAgICAgIHxcbiAqIHwgYHNzYCAgICB8IFNlY29uZCwgbGVhZGluZyB6ZXJvICAgICAgICAgICB8IGAwMWAgLi4uIGA1OWAgICAgICAgICAgIHxcbiAqIHwgYFpgICAgICB8IFVUQyBUaW1lem9uZSBPZmZzZXQgICAgICAgICAgICB8IGBaIG9yICtISDptbSBvciAtSEg6bW1gIHxcbiAqXG4gKiAqKkltcG9ydGFudCoqOiBTZWUgdGhlIFtNb250aCBOYW1lcyBhbmQgRGF5IG9mIHRoZSBXZWVrIE5hbWVzXSgjbW9udGgtbmFtZXMtYW5kLWRheS1vZi10aGUtd2Vlay1uYW1lcylcbiAqIHNlY3Rpb24gYmVsb3cgb24gaG93IHRvIHVzZSBkaWZmZXJlbnQgbmFtZXMgZm9yIHRoZSBtb250aCBhbmQgZGF5LlxuICpcbiAqICMjIyBEaXNwbGF5IEZvcm1hdFxuICpcbiAqIFRoZSBgZGlzcGxheUZvcm1hdGAgaW5wdXQgcHJvcGVydHkgc3BlY2lmaWVzIGhvdyBhIGRhdGV0aW1lJ3MgdmFsdWUgc2hvdWxkIGJlXG4gKiBwcmludGVkLCBhcyBmb3JtYXR0ZWQgdGV4dCwgd2l0aGluIHRoZSBgaW9uLWRhdGV0aW1lYCBjb21wb25lbnQuXG4gKlxuICogSW4gdGhlIGZvbGxvd2luZyBleGFtcGxlLCB0aGUgZGlzcGxheSBpbiB0aGUgYDxpb24tZGF0ZXRpbWU+YCB3aWxsIHVzZSB0aGVcbiAqIG1vbnRoJ3Mgc2hvcnQgbmFtZSwgdGhlIG51bWVyaWNhbCBkYXkgd2l0aCBhIGxlYWRpbmcgemVybywgYSBjb21tYSBhbmQgdGhlXG4gKiBmb3VyLWRpZ2l0IHllYXIuIEluIGFkZGl0aW9uIHRvIHRoZSBkYXRlLCBpdCB3aWxsIGRpc3BsYXkgdGhlIHRpbWUgd2l0aCB0aGUgaG91cnNcbiAqIGluIHRoZSAyNC1ob3VyIGZvcm1hdCBhbmQgdGhlIG1pbnV0ZXMuIEFueSBjaGFyYWN0ZXIgY2FuIGJlIHVzZWQgYXMgYSBzZXBhcmF0b3IuXG4gKiBBbiBleGFtcGxlIGRpc3BsYXkgdXNpbmcgdGhpcyBmb3JtYXQgaXM6IGBKdW4gMTcsIDIwMDUgMTE6MDZgLlxuICpcbiAqIGBgYGh0bWxcbiAqIDxpb24taXRlbT5cbiAqICAgPGlvbi1sYWJlbD5EYXRlPC9pb24tbGFiZWw+XG4gKiAgIDxpb24tZGF0ZXRpbWUgZGlzcGxheUZvcm1hdD1cIk1NTSBERCwgWVlZWSBISDptbVwiIFsobmdNb2RlbCldPVwibXlEYXRlXCI+PC9pb24tZGF0ZXRpbWU+XG4gKiA8L2lvbi1pdGVtPlxuICogYGBgXG4gKlxuICogIyMjIFBpY2tlciBGb3JtYXRcbiAqXG4gKiBUaGUgYHBpY2tlckZvcm1hdGAgaW5wdXQgcHJvcGVydHkgZGV0ZXJtaW5lcyB3aGljaCBjb2x1bW5zIHNob3VsZCBiZSBzaG93biBpbiB0aGVcbiAqIGludGVyZmFjZSwgdGhlIG9yZGVyIG9mIHRoZSBjb2x1bW5zLCBhbmQgd2hpY2ggZm9ybWF0IHRvIHVzZSB3aXRoaW4gZWFjaCBjb2x1bW4uXG4gKiBJZiB0aGUgYHBpY2tlckZvcm1hdGAgaW5wdXQgaXMgbm90IHByb3ZpZGVkIHRoZW4gaXQgd2lsbCBkZWZhdWx0IHRvIHRoZSBgZGlzcGxheUZvcm1hdGAuXG4gKlxuICogSW4gdGhlIGZvbGxvd2luZyBleGFtcGxlLCB0aGUgZGlzcGxheSBpbiB0aGUgYDxpb24tZGF0ZXRpbWU+YCB3aWxsIHVzZSB0aGVcbiAqIGBNTS9ZWVlZYCBmb3JtYXQsIHN1Y2ggYXMgYDA2LzIwMjBgLiBIb3dldmVyLCB0aGUgcGlja2VyIGludGVyZmFjZVxuICogd2lsbCBkaXNwbGF5IHR3byBjb2x1bW5zIHdpdGggdGhlIG1vbnRoJ3MgbG9uZyBuYW1lLCBhbmQgdGhlIGZvdXItZGlnaXQgeWVhci5cbiAqXG4gKiBgYGBodG1sXG4gKiA8aW9uLWl0ZW0+XG4gKiAgIDxpb24tbGFiZWw+RGF0ZTwvaW9uLWxhYmVsPlxuICogICA8aW9uLWRhdGV0aW1lIGRpc3BsYXlGb3JtYXQ9XCJNTS9ZWVlZXCIgcGlja2VyRm9ybWF0PVwiTU1NTSBZWVlZXCIgWyhuZ01vZGVsKV09XCJteURhdGVcIj48L2lvbi1kYXRldGltZT5cbiAqIDwvaW9uLWl0ZW0+XG4gKiBgYGBcbiAqXG4gKiAjIyMgRGF0ZXRpbWUgRGF0YVxuICpcbiAqIEhpc3RvcmljYWxseSwgaGFuZGxpbmcgZGF0ZXRpbWUgdmFsdWVzIHdpdGhpbiBKYXZhU2NyaXB0LCBvciBldmVuIHdpdGhpbiBIVE1MXG4gKiBpbnB1dHMsIGhhcyBhbHdheXMgYmVlbiBhIGNoYWxsZW5nZS4gU3BlY2lmaWNhbGx5LCBKYXZhU2NyaXB0J3MgYERhdGVgIG9iamVjdCBpc1xuICogbm90b3Jpb3VzbHkgZGlmZmljdWx0IHRvIGNvcnJlY3RseSBwYXJzZSBhcGFydCBkYXRldGltZSBzdHJpbmdzIG9yIHRvIGZvcm1hdFxuICogZGF0ZXRpbWUgdmFsdWVzLiBFdmVuIHdvcnNlIGlzIGhvdyBkaWZmZXJlbnQgYnJvd3NlcnMgYW5kIEphdmFTY3JpcHQgdmVyc2lvbnNcbiAqIHBhcnNlIHZhcmlvdXMgZGF0ZXRpbWUgc3RyaW5ncyBkaWZmZXJlbnRseSwgZXNwZWNpYWxseSBwZXIgbG9jYWxlLlxuICpcbiAqIEJ1dCBubyB3b3JyaWVzLCBhbGwgaXMgbm90IGxvc3QhIElvbmljJ3MgZGF0ZXRpbWUgaW5wdXQgaGFzIGJlZW4gZGVzaWduZWQgc29cbiAqIGRldmVsb3BlcnMgY2FuIGF2b2lkIHRoZSBjb21tb24gcGl0ZmFsbHMsIGFsbG93aW5nIGRldmVsb3BlcnMgdG8gZWFzaWx5IGZvcm1hdFxuICogZGF0ZXRpbWUgdmFsdWVzIHdpdGhpbiB0aGUgaW5wdXQsIGFuZCBnaXZlIHRoZSB1c2VyIGEgc2ltcGxlIGRhdGV0aW1lIHBpY2tlciBmb3IgYVxuICogZ3JlYXQgdXNlciBleHBlcmllbmNlLlxuICpcbiAqICMjIyMjIElTTyA4NjAxIERhdGV0aW1lIEZvcm1hdDogWVlZWS1NTS1ERFRISDptbVpcbiAqXG4gKiBJb25pYyB1c2VzIHRoZSBbSVNPIDg2MDEgZGF0ZXRpbWUgZm9ybWF0XShodHRwczovL3d3dy53My5vcmcvVFIvTk9URS1kYXRldGltZSlcbiAqIGZvciBpdHMgdmFsdWUuIFRoZSB2YWx1ZSBpcyBzaW1wbHkgYSBzdHJpbmcsIHJhdGhlciB0aGFuIHVzaW5nIEphdmFTY3JpcHQncyBgRGF0ZWBcbiAqIG9iamVjdC4gQWRkaXRpb25hbGx5LCB3aGVuIHVzaW5nIHRoZSBJU08gZGF0ZXRpbWUgZm9ybWF0LCBpdCBtYWtlcyBpdCBlYXNpZXJcbiAqIHRvIHNlcmlhbGl6ZSBhbmQgcGFzcyB3aXRoaW4gSlNPTiBvYmplY3RzLCBhbmQgc2VuZGluZyBkYXRhYmFzZXMgYSBzdGFuZGFyZGl6ZWRcbiAqIGZvcm1hdCB3aGljaCBpdCBjYW4gYmUgZWFzaWx5IHBhcnNlZCBpZiBuZWVkIGJlLlxuICpcbiAqIFRvIGNyZWF0ZSBhbiBJU08gZGF0ZXRpbWUgc3RyaW5nIGZvciB0aGUgY3VycmVudCBkYXRlIGFuZCB0aW1lLCBlLmcuIHVzZSBgY29uc3QgY3VycmVudERhdGUgPSAobmV3IERhdGUoKSkudG9JU09TdHJpbmcoKTtgLlxuICpcbiAqIEFuIElTTyBmb3JtYXQgY2FuIGJlIHVzZWQgYXMgYSBzaW1wbGUgeWVhciwgb3IganVzdCB0aGUgaG91ciBhbmQgbWludXRlLCBvciBnZXQgbW9yZVxuICogZGV0YWlsZWQgZG93biB0byB0aGUgbWlsbGlzZWNvbmQgYW5kIHRpbWV6b25lLiBBbnkgb2YgdGhlIElTTyBmb3JtYXRzIGJlbG93IGNhbiBiZSB1c2VkLFxuICogYW5kIGFmdGVyIGEgdXNlciBzZWxlY3RzIGEgbmV3IHZhbHVlLCBJb25pYyB3aWxsIGNvbnRpbnVlIHRvIHVzZSB0aGUgc2FtZSBJU08gZm9ybWF0XG4gKiB3aGljaCBkYXRldGltZSB2YWx1ZSB3YXMgb3JpZ2luYWxseSBnaXZlbiBhcy5cbiAqXG4gKiB8IERlc2NyaXB0aW9uICAgICAgICAgIHwgRm9ybWF0ICAgICAgICAgICAgICAgICB8IERhdGV0aW1lIFZhbHVlIEV4YW1wbGUgICAgICAgfFxuICogfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwgWWVhciAgICAgICAgICAgICAgICAgfCBZWVlZICAgICAgICAgICAgICAgICAgIHwgMTk5NCAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IFllYXIgYW5kIE1vbnRoICAgICAgIHwgWVlZWS1NTSAgICAgICAgICAgICAgICB8IDE5OTQtMTIgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCBDb21wbGV0ZSBEYXRlICAgICAgICB8IFlZWVktTU0tREQgICAgICAgICAgICAgfCAxOTk0LTEyLTE1ICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgRGF0ZSBhbmQgVGltZSAgICAgICAgfCBZWVlZLU1NLUREVEhIOm1tICAgICAgIHwgMTk5NC0xMi0xNVQxMzo0NyAgICAgICAgICAgICB8XG4gKiB8IFVUQyBUaW1lem9uZSAgICAgICAgIHwgWVlZWS1NTS1ERFRISDptbTpzc1RaRCB8IDE5OTQtMTItMTVUMTM6NDc6MjAuNzg5WiAgICAgfFxuICogfCBUaW1lem9uZSBPZmZzZXQgICAgICB8IFlZWVktTU0tRERUSEg6bW06c3NUWkQgfCAxOTk0LTEyLTE1VDEzOjQ3OjIwLjc4OSs1OjAwIHxcbiAqIHwgSG91ciBhbmQgTWludXRlICAgICAgfCBISDptbSAgICAgICAgICAgICAgICAgIHwgMTM6NDcgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IEhvdXIsIE1pbnV0ZSwgU2Vjb25kIHwgSEg6bW06c3MgICAgICAgICAgICAgICB8IDEzOjQ3OjIwICAgICAgICAgICAgICAgICAgICAgfFxuICpcbiAqIE5vdGUgdGhhdCB0aGUgeWVhciBpcyBhbHdheXMgZm91ci1kaWdpdHMsIG1pbGxpc2Vjb25kcyAoaWYgaXQncyBhZGRlZCkgaXMgYWx3YXlzXG4gKiB0aHJlZS1kaWdpdHMsIGFuZCBhbGwgb3RoZXJzIGFyZSBhbHdheXMgdHdvLWRpZ2l0cy4gU28gdGhlIG51bWJlciByZXByZXNlbnRpbmdcbiAqIEphbnVhcnkgYWx3YXlzIGhhcyBhIGxlYWRpbmcgemVybywgc3VjaCBhcyBgMDFgLiBBZGRpdGlvbmFsbHksIHRoZSBob3VyIGlzIGFsd2F5c1xuICogaW4gdGhlIDI0LWhvdXIgZm9ybWF0LCBzbyBgMDBgIGlzIGAxMmFtYCBvbiBhIDEyLWhvdXIgY2xvY2ssIGAxM2AgbWVhbnMgYDFwbWAsXG4gKiBhbmQgYDIzYCBtZWFucyBgMTFwbWAuXG4gKlxuICogSXQncyBhbHNvIGltcG9ydGFudCB0byBub3RlIHRoYXQgbmVpdGhlciB0aGUgYGRpc3BsYXlGb3JtYXRgIG9yIGBwaWNrZXJGb3JtYXRgIGNhblxuICogc2V0IHRoZSBkYXRldGltZSB2YWx1ZSdzIG91dHB1dCwgd2hpY2ggaXMgdGhlIHZhbHVlIHRoYXQgaXMgc2V0IGJ5IHRoZSBjb21wb25lbnQnc1xuICogYG5nTW9kZWxgLiBUaGUgZm9ybWF0J3MgYXJlIG1lcmVseSBmb3IgZGlzcGxheWluZyB0aGUgdmFsdWUgYXMgdGV4dCBhbmQgdGhlIHBpY2tlcidzXG4gKiBpbnRlcmZhY2UsIGJ1dCB0aGUgZGF0ZXRpbWUncyB2YWx1ZSBpcyBhbHdheXMgcGVyc2lzdGVkIGFzIGEgdmFsaWQgSVNPIDg2MDEgZGF0ZXRpbWVcbiAqIHN0cmluZy5cbiAqXG4gKlxuICogIyMgTWluIGFuZCBNYXggRGF0ZXRpbWVzXG4gKlxuICogRGF0ZXMgYXJlIGluZmluaXRlIGluIGVpdGhlciBkaXJlY3Rpb24sIHNvIGZvciBhIHVzZXIncyBzZWxlY3Rpb24gdGhlcmUgc2hvdWxkIGJlIGF0XG4gKiBsZWFzdCBzb21lIGZvcm0gb2YgcmVzdHJpY3RpbmcgdGhlIGRhdGVzIHRoYXQgY2FuIGJlIHNlbGVjdGVkLiBCeSBkZWZhdWx0LCB0aGUgbWF4aW11bVxuICogZGF0ZSBpcyB0byB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHllYXIsIGFuZCB0aGUgbWluaW11bSBkYXRlIGlzIGZyb20gdGhlIGJlZ2lubmluZ1xuICogb2YgdGhlIHllYXIgdGhhdCB3YXMgMTAwIHllYXJzIGFnby5cbiAqXG4gKiBUbyBjdXN0b21pemUgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gZGF0ZXRpbWUgdmFsdWVzLCB0aGUgYG1pbmAgYW5kIGBtYXhgIGNvbXBvbmVudFxuICogaW5wdXRzIGNhbiBiZSBwcm92aWRlZCB3aGljaCBtYXkgbWFrZSBtb3JlIHNlbnNlIGZvciB0aGUgYXBwJ3MgdXNlLWNhc2UsIHJhdGhlclxuICogdGhhbiB0aGUgZGVmYXVsdCBvZiB0aGUgbGFzdCAxMDAgeWVhcnMuIEZvbGxvd2luZyB0aGUgc2FtZSBJUzAgODYwMSBmb3JtYXQgbGlzdGVkXG4gKiBpbiB0aGUgdGFibGUgYWJvdmUsIGVhY2ggY29tcG9uZW50IGNhbiByZXN0cmljdCB3aGljaCBkYXRlcyBjYW4gYmUgc2VsZWN0ZWQgYnkgdGhlXG4gKiB1c2VyLiBCZWxvdyBpcyBhbiBleGFtcGxlIG9mIHJlc3RyaWN0aW5nIHRoZSBkYXRlIHNlbGVjdGlvbiBiZXR3ZWVuIHRoZSBiZWdpbm5pbmdcbiAqIG9mIDIwMTYsIGFuZCBPY3RvYmVyIDMxc3Qgb2YgMjAyMDpcbiAqXG4gKiBgYGBodG1sXG4gKiA8aW9uLWl0ZW0+XG4gKiAgIDxpb24tbGFiZWw+RGF0ZTwvaW9uLWxhYmVsPlxuICogICA8aW9uLWRhdGV0aW1lIGRpc3BsYXlGb3JtYXQ9XCJNTU1NIFlZWVlcIiBtaW49XCIyMDE2XCIgbWF4PVwiMjAyMC0xMC0zMVwiIFsobmdNb2RlbCldPVwibXlEYXRlXCI+XG4gKiAgIDwvaW9uLWRhdGV0aW1lPlxuICogPC9pb24taXRlbT5cbiAqIGBgYFxuICpcbiAqXG4gKiAjIyBNb250aCBOYW1lcyBhbmQgRGF5IG9mIHRoZSBXZWVrIE5hbWVzXG4gKlxuICogQXQgdGhpcyB0aW1lLCB0aGVyZSBpcyBubyBvbmUtc2l6ZS1maXRzLWFsbCBzdGFuZGFyZCB0byBhdXRvbWF0aWNhbGx5IGNob29zZSB0aGUgY29ycmVjdFxuICogbGFuZ3VhZ2Uvc3BlbGxpbmcgZm9yIGEgbW9udGggbmFtZSwgb3IgZGF5IG9mIHRoZSB3ZWVrIG5hbWUsIGRlcGVuZGluZyBvbiB0aGUgbGFuZ3VhZ2VcbiAqIG9yIGxvY2FsZS4gR29vZCBuZXdzIGlzIHRoYXQgdGhlcmUgaXMgYW5cbiAqIFtJbnRsLkRhdGVUaW1lRm9ybWF0XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlVGltZUZvcm1hdClcbiAqIHN0YW5kYXJkIHdoaWNoICptb3N0KiBicm93c2VycyBoYXZlIGFkb3B0ZWQuIEhvd2V2ZXIsIGF0IHRoaXMgdGltZSB0aGUgc3RhbmRhcmQgaGFzIG5vdFxuICogYmVlbiBmdWxseSBpbXBsZW1lbnRlZCBieSBhbGwgcG9wdWxhciBicm93c2VycyBzbyBJb25pYyBpcyB1bmF2YWlsYWJsZSB0byB0YWtlIGFkdmFudGFnZVxuICogb2YgaXQgKnlldCouIEFkZGl0aW9uYWxseSwgQW5ndWxhciBhbHNvIHByb3ZpZGVzIGFuIGludGVybmF0aW9uYWxpemF0aW9uIHNlcnZpY2UsIGJ1dCBpdFxuICogaXMgc3RpbGwgdW5kZXIgaGVhdnkgZGV2ZWxvcG1lbnQgc28gSW9uaWMgZG9lcyBub3QgZGVwZW5kIG9uIGl0IGF0IHRoaXMgdGltZS5cbiAqXG4gKiBBbGwgdGhpbmdzIGNvbnNpZGVyZWQsIHRoZSBieSBmYXIgZWFzaWVzdCBzb2x1dGlvbiBpcyB0byBqdXN0IHByb3ZpZGUgYW4gYXJyYXkgb2YgbmFtZXNcbiAqIGlmIHRoZSBhcHAgbmVlZHMgdG8gdXNlIG5hbWVzIG90aGVyIHRoYW4gdGhlIGRlZmF1bHQgRW5nbGlzaCB2ZXJzaW9uIG9mIG1vbnRoIGFuZCBkYXlcbiAqIG5hbWVzLiBUaGUgbW9udGggbmFtZXMgYW5kIGRheSBuYW1lcyBjYW4gYmUgZWl0aGVyIGNvbmZpZ3VyZWQgYXQgdGhlIGFwcCBsZXZlbCwgb3JcbiAqIGluZGl2aWR1YWwgYGlvbi1kYXRldGltZWAgbGV2ZWwuXG4gKlxuICogIyMjIEFwcCBDb25maWcgTGV2ZWxcbiAqXG4gKiBgYGB0c1xuICogLy9hcHAubW9kdWxlLnRzXG4gKiBATmdNb2R1bGUoe1xuICogLi4uLFxuICogaW1wb3J0czogW1xuICogICBJb25pY01vZHVsZS5mb3JSb290KE15QXBwLCB7XG4gKiAgIG1vbnRoTmFtZXM6IFsnamFuZWlybycsICdmZXZlcmVpcm8nLCAnbWFyXFx1MDBlN28nLCAuLi4gXSxcbiAqICAgbW9udGhTaG9ydE5hbWVzOiBbJ2phbicsICdmZXYnLCAnbWFyJywgLi4uIF0sXG4gKiAgIGRheU5hbWVzOiBbJ2RvbWluZ28nLCAnc2VndW5kYS1mZWlyYScsICd0ZXJcXHUwMGU3YS1mZWlyYScsIC4uLiBdLFxuICogICBkYXlTaG9ydE5hbWVzOiBbJ2RvbScsICdzZWcnLCAndGVyJywgLi4uIF0sXG4gKiB9KVxuICogXSxcbiAqIC4uLlxuICogfSlcbiAqIGBgYFxuICpcbiAqICMjIyBDb21wb25lbnQgSW5wdXQgTGV2ZWxcbiAqXG4gKiBgYGBodG1sXG4gKiA8aW9uLWl0ZW0+XG4gKiAgIDxpb24tbGFiZWw+UGVyw61vZG88L2lvbi1sYWJlbD5cbiAqICAgPGlvbi1kYXRldGltZSBkaXNwbGF5Rm9ybWF0PVwiRERERCBNTU0gRCwgWVlZWVwiIFsobmdNb2RlbCldPVwibXlEYXRlXCJcbiAqICAgICBtb250aE5hbWVzPVwiamFuZWlybywgZmV2ZXJlaXJvLCBtYXJcXHUwMGU3bywgLi4uXCJcbiAqICAgICBtb250aFNob3J0TmFtZXM9XCJqYW4sIGZldiwgbWFyLCAuLi5cIlxuICogICAgIGRheU5hbWVzPVwiZG9taW5nbywgc2VndW5kYS1mZWlyYSwgdGVyXFx1MDBlN2EtZmVpcmEsIC4uLlwiXG4gKiAgICAgZGF5U2hvcnROYW1lcz1cImRvbSwgc2VnLCB0ZXIsIC4uLlwiPjwvaW9uLWRhdGV0aW1lPlxuICogPC9pb24taXRlbT5cbiAqIGBgYFxuICpcbiAqXG4gKiAjIyMgQWR2YW5jZWQgRGF0ZXRpbWUgVmFsaWRhdGlvbiBhbmQgTWFuaXB1bGF0aW9uXG4gKlxuICogVGhlIGRhdGV0aW1lIHBpY2tlciBwcm92aWRlcyB0aGUgc2ltcGxpY2l0eSBvZiBzZWxlY3RpbmcgYW4gZXhhY3QgZm9ybWF0LCBhbmQgcGVyc2lzdHNcbiAqIHRoZSBkYXRldGltZSB2YWx1ZXMgYXMgYSBzdHJpbmcgdXNpbmcgdGhlIHN0YW5kYXJkaXplZFxuICogW0lTTyA4NjAxIGRhdGV0aW1lIGZvcm1hdF0oaHR0cHM6Ly93d3cudzMub3JnL1RSL05PVEUtZGF0ZXRpbWUpLlxuICogSG93ZXZlciwgaXQncyBpbXBvcnRhbnQgdG8gbm90ZSB0aGF0IGBpb24tZGF0ZXRpbWVgIGRvZXMgbm90IGF0dGVtcHQgdG8gc29sdmUgYWxsXG4gKiBzaXR1dGF0aW9ucyB3aGVuIHZhbGlkYXRpbmcgYW5kIG1hbmlwdWxhdGluZyBkYXRldGltZSB2YWx1ZXMuIElmIGRhdGV0aW1lIHZhbHVlcyBuZWVkXG4gKiB0byBiZSBwYXJzZWQgZnJvbSBhIGNlcnRhaW4gZm9ybWF0LCBvciBtYW5pcHVsYXRlZCAoc3VjaCBhcyBhZGRpbmcgNSBkYXlzIHRvIGEgZGF0ZSxcbiAqIHN1YnRyYWN0aW5nIDMwIG1pbnV0ZXMsIGV0Yy4pLCBvciBldmVuIGZvcm1hdHRpbmcgZGF0YSB0byBhIHNwZWNpZmljIGxvY2FsZSwgdGhlbiB3ZSBoaWdobHlcbiAqIHJlY29tbWVuZCB1c2luZyBbbW9tZW50LmpzXShodHRwOi8vbW9tZW50anMuY29tLykgdG8gXCJQYXJzZSwgdmFsaWRhdGUsIG1hbmlwdWxhdGUsIGFuZFxuICogZGlzcGxheSBkYXRlcyBpbiBKYXZhU2NyaXB0XCIuIFtNb21lbnQuanNdKGh0dHA6Ly9tb21lbnRqcy5jb20vKSBoYXMgcXVpY2tseSBiZWNvbWVcbiAqIG91ciBnb3RvIHN0YW5kYXJkIHdoZW4gZGVhbGluZyB3aXRoIGRhdGV0aW1lcyB3aXRoaW4gSmF2YVNjcmlwdCwgYnV0IElvbmljIGRvZXMgbm90XG4gKiBwcmVwYWNrYWdlIHRoaXMgZGVwZW5kZW5jeSBzaW5jZSBtb3N0IGFwcHMgd2lsbCBub3QgcmVxdWlyZSBpdCwgYW5kIGl0cyBsb2NhbGVcbiAqIGNvbmZpZ3VyYXRpb24gc2hvdWxkIGJlIGRlY2lkZWQgYnkgdGhlIGVuZC1kZXZlbG9wZXIuXG4gKlxuICpcbiAqIEB1c2FnZVxuICogYGBgaHRtbFxuICogPGlvbi1pdGVtPlxuICogICA8aW9uLWxhYmVsPkRhdGU8L2lvbi1sYWJlbD5cbiAqICAgPGlvbi1kYXRldGltZSBkaXNwbGF5Rm9ybWF0PVwiTU0vREQvWVlZWVwiIFsobmdNb2RlbCldPVwibXlEYXRlXCI+XG4gKiAgIDwvaW9uLWRhdGV0aW1lPlxuICogPC9pb24taXRlbT5cbiAqIGBgYFxuICpcbiAqXG4gKiBAZGVtbyAvZG9jcy9kZW1vcy9zcmMvZGF0ZXRpbWUvXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIERhdGVUaW1lIGV4dGVuZHMgQmFzZUlucHV0PERhdGVUaW1lRGF0YT4gaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBDb250cm9sVmFsdWVBY2Nlc3NvciwgT25EZXN0cm95IHtcbiAgICBwcml2YXRlIF9waWNrZXJDdHJsO1xuICAgIF90ZXh0OiBzdHJpbmc7XG4gICAgX21pbjogRGF0ZVRpbWVEYXRhO1xuICAgIF9tYXg6IERhdGVUaW1lRGF0YTtcbiAgICBfbG9jYWxlOiBMb2NhbGVEYXRhO1xuICAgIF9waWNrZXI6IFBpY2tlcjtcbiAgICAvKipcbiAgICAgKiBAaW5wdXQge3N0cmluZ30gVGhlIG1pbmltdW0gZGF0ZXRpbWUgYWxsb3dlZC4gVmFsdWUgbXVzdCBiZSBhIGRhdGUgc3RyaW5nXG4gICAgICogZm9sbG93aW5nIHRoZVxuICAgICAqIFtJU08gODYwMSBkYXRldGltZSBmb3JtYXQgc3RhbmRhcmRdKGh0dHBzOi8vd3d3LnczLm9yZy9UUi9OT1RFLWRhdGV0aW1lKSxcbiAgICAgKiBzdWNoIGFzIGAxOTk2LTEyLTE5YC4gVGhlIGZvcm1hdCBkb2VzIG5vdCBoYXZlIHRvIGJlIHNwZWNpZmljIHRvIGFuIGV4YWN0XG4gICAgICogZGF0ZXRpbWUuIEZvciBleGFtcGxlLCB0aGUgbWluaW11bSBjb3VsZCBqdXN0IGJlIHRoZSB5ZWFyLCBzdWNoIGFzIGAxOTk0YC5cbiAgICAgKiBEZWZhdWx0cyB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSB5ZWFyLCAxMDAgeWVhcnMgYWdvIGZyb20gdG9kYXkuXG4gICAgICovXG4gICAgbWluOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQGlucHV0IHtzdHJpbmd9IFRoZSBtYXhpbXVtIGRhdGV0aW1lIGFsbG93ZWQuIFZhbHVlIG11c3QgYmUgYSBkYXRlIHN0cmluZ1xuICAgICAqIGZvbGxvd2luZyB0aGVcbiAgICAgKiBbSVNPIDg2MDEgZGF0ZXRpbWUgZm9ybWF0IHN0YW5kYXJkXShodHRwczovL3d3dy53My5vcmcvVFIvTk9URS1kYXRldGltZSksXG4gICAgICogYDE5OTYtMTItMTlgLiBUaGUgZm9ybWF0IGRvZXMgbm90IGhhdmUgdG8gYmUgc3BlY2lmaWMgdG8gYW4gZXhhY3RcbiAgICAgKiBkYXRldGltZS4gRm9yIGV4YW1wbGUsIHRoZSBtYXhpbXVtIGNvdWxkIGp1c3QgYmUgdGhlIHllYXIsIHN1Y2ggYXMgYDE5OTRgLlxuICAgICAqIERlZmF1bHRzIHRvIHRoZSBlbmQgb2YgdGhpcyB5ZWFyLlxuICAgICAqL1xuICAgIG1heDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEBpbnB1dCB7c3RyaW5nfSBUaGUgZGlzcGxheSBmb3JtYXQgb2YgdGhlIGRhdGUgYW5kIHRpbWUgYXMgdGV4dCB0aGF0IHNob3dzXG4gICAgICogd2l0aGluIHRoZSBpdGVtLiBXaGVuIHRoZSBgcGlja2VyRm9ybWF0YCBpbnB1dCBpcyBub3QgdXNlZCwgdGhlbiB0aGVcbiAgICAgKiBgZGlzcGxheUZvcm1hdGAgaXMgdXNlZCBmb3IgYm90aCBkaXNwbGF5IHRoZSBmb3JtYXR0ZWQgdGV4dCwgYW5kIGRldGVybWluaW5nXG4gICAgICogdGhlIGRhdGV0aW1lIHBpY2tlcidzIGNvbHVtbnMuIFNlZSB0aGUgYHBpY2tlckZvcm1hdGAgaW5wdXQgZGVzY3JpcHRpb24gZm9yXG4gICAgICogbW9yZSBpbmZvLiBEZWZhdWx0cyB0byBgTU1NIEQsIFlZWVlgLlxuICAgICAqL1xuICAgIGRpc3BsYXlGb3JtYXQ6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBAaW5wdXQge3N0cmluZ30gVGhlIGRlZmF1bHQgZGF0ZXRpbWUgc2VsZWN0ZWQgaW4gcGlja2VyIG1vZGFsIGlmIGZpZWxkIHZhbHVlIGlzIGVtcHR5LlxuICAgICAqIFZhbHVlIG11c3QgYmUgYSBkYXRlIHN0cmluZyBmb2xsb3dpbmcgdGhlXG4gICAgICogW0lTTyA4NjAxIGRhdGV0aW1lIGZvcm1hdCBzdGFuZGFyZF0oaHR0cHM6Ly93d3cudzMub3JnL1RSL05PVEUtZGF0ZXRpbWUpLFxuICAgICAqIGAxOTk2LTEyLTE5YC5cbiAgICAgKi9cbiAgICBpbml0aWFsVmFsdWU6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBAaW5wdXQge3N0cmluZ30gVGhlIGZvcm1hdCBvZiB0aGUgZGF0ZSBhbmQgdGltZSBwaWNrZXIgY29sdW1ucyB0aGUgdXNlciBzZWxlY3RzLlxuICAgICAqIEEgZGF0ZXRpbWUgaW5wdXQgY2FuIGhhdmUgb25lIG9yIG1hbnkgZGF0ZXRpbWUgcGFydHMsIGVhY2ggZ2V0dGluZyB0aGVpclxuICAgICAqIG93biBjb2x1bW4gd2hpY2ggYWxsb3cgaW5kaXZpZHVhbCBzZWxlY3Rpb24gb2YgdGhhdCBwYXJ0aWN1bGFyIGRhdGV0aW1lIHBhcnQuIEZvclxuICAgICAqIGV4YW1wbGUsIHllYXIgYW5kIG1vbnRoIGNvbHVtbnMgYXJlIHR3byBpbmRpdmlkdWFsbHkgc2VsZWN0YWJsZSBjb2x1bW5zIHdoaWNoIGhlbHBcbiAgICAgKiBjaG9vc2UgYW4gZXhhY3QgZGF0ZSBmcm9tIHRoZSBkYXRldGltZSBwaWNrZXIuIEVhY2ggY29sdW1uIGZvbGxvd3MgdGhlIHN0cmluZ1xuICAgICAqIHBhcnNlIGZvcm1hdC4gRGVmYXVsdHMgdG8gdXNlIGBkaXNwbGF5Rm9ybWF0YC5cbiAgICAgKi9cbiAgICBwaWNrZXJGb3JtYXQ6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBAaW5wdXQge3N0cmluZ30gVGhlIHRleHQgdG8gZGlzcGxheSBvbiB0aGUgcGlja2VyJ3MgY2FuY2VsIGJ1dHRvbi4gRGVmYXVsdDogYENhbmNlbGAuXG4gICAgICovXG4gICAgY2FuY2VsVGV4dDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEBpbnB1dCB7c3RyaW5nfSBUaGUgdGV4dCB0byBkaXNwbGF5IG9uIHRoZSBwaWNrZXIncyBcIkRvbmVcIiBidXR0b24uIERlZmF1bHQ6IGBEb25lYC5cbiAgICAgKi9cbiAgICBkb25lVGV4dDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEBpbnB1dCB7YXJyYXkgfCBzdHJpbmd9IFZhbHVlcyB1c2VkIHRvIGNyZWF0ZSB0aGUgbGlzdCBvZiBzZWxlY3RhYmxlIHllYXJzLiBCeSBkZWZhdWx0XG4gICAgICogdGhlIHllYXIgdmFsdWVzIHJhbmdlIGJldHdlZW4gdGhlIGBtaW5gIGFuZCBgbWF4YCBkYXRldGltZSBpbnB1dHMuIEhvd2V2ZXIsIHRvXG4gICAgICogY29udHJvbCBleGFjdGx5IHdoaWNoIHllYXJzIHRvIGRpc3BsYXksIHRoZSBgeWVhclZhbHVlc2AgaW5wdXQgY2FuIHRha2UgZWl0aGVyIGFuIGFycmF5XG4gICAgICogb2YgbnVtYmVycywgb3Igc3RyaW5nIG9mIGNvbW1hIHNlcGFyYXRlZCBudW1iZXJzLiBGb3IgZXhhbXBsZSwgdG8gc2hvdyB1cGNvbWluZyBhbmRcbiAgICAgKiByZWNlbnQgbGVhcCB5ZWFycywgdGhlbiB0aGlzIGlucHV0J3MgdmFsdWUgd291bGQgYmUgYHllYXJWYWx1ZXM9XCIyMDI0LDIwMjAsMjAxNiwyMDEyLDIwMDhcImAuXG4gICAgICovXG4gICAgeWVhclZhbHVlczogYW55O1xuICAgIC8qKlxuICAgICAqIEBpbnB1dCB7YXJyYXkgfCBzdHJpbmd9IFZhbHVlcyB1c2VkIHRvIGNyZWF0ZSB0aGUgbGlzdCBvZiBzZWxlY3RhYmxlIG1vbnRocy4gQnkgZGVmYXVsdFxuICAgICAqIHRoZSBtb250aCB2YWx1ZXMgcmFuZ2UgZnJvbSBgMWAgdG8gYDEyYC4gSG93ZXZlciwgdG8gY29udHJvbCBleGFjdGx5IHdoaWNoIG1vbnRocyB0b1xuICAgICAqIGRpc3BsYXksIHRoZSBgbW9udGhWYWx1ZXNgIGlucHV0IGNhbiB0YWtlIGVpdGhlciBhbiBhcnJheSBvZiBudW1iZXJzLCBvciBzdHJpbmcgb2ZcbiAgICAgKiBjb21tYSBzZXBhcmF0ZWQgbnVtYmVycy4gRm9yIGV4YW1wbGUsIGlmIG9ubHkgc3VtbWVyIG1vbnRocyBzaG91bGQgYmUgc2hvd24sIHRoZW4gdGhpc1xuICAgICAqIGlucHV0IHZhbHVlIHdvdWxkIGJlIGBtb250aFZhbHVlcz1cIjYsNyw4XCJgLiBOb3RlIHRoYXQgbW9udGggbnVtYmVycyBkbyAqbm90KiBoYXZlIGFcbiAgICAgKiB6ZXJvLWJhc2VkIGluZGV4LCBtZWFuaW5nIEphbnVhcnkncyB2YWx1ZSBpcyBgMWAsIGFuZCBEZWNlbWJlcidzIGlzIGAxMmAuXG4gICAgICovXG4gICAgbW9udGhWYWx1ZXM6IGFueTtcbiAgICAvKipcbiAgICAgKiBAaW5wdXQge2FycmF5IHwgc3RyaW5nfSBWYWx1ZXMgdXNlZCB0byBjcmVhdGUgdGhlIGxpc3Qgb2Ygc2VsZWN0YWJsZSBkYXlzLiBCeSBkZWZhdWx0XG4gICAgICogZXZlcnkgZGF5IGlzIHNob3duIGZvciB0aGUgZ2l2ZW4gbW9udGguIEhvd2V2ZXIsIHRvIGNvbnRyb2wgZXhhY3RseSB3aGljaCBkYXlzIG9mXG4gICAgICogdGhlIG1vbnRoIHRvIGRpc3BsYXksIHRoZSBgZGF5VmFsdWVzYCBpbnB1dCBjYW4gdGFrZSBlaXRoZXIgYW4gYXJyYXkgb2YgbnVtYmVycywgb3JcbiAgICAgKiBzdHJpbmcgb2YgY29tbWEgc2VwYXJhdGVkIG51bWJlcnMuIE5vdGUgdGhhdCBldmVuIGlmIHRoZSBhcnJheSBkYXlzIGhhdmUgYW4gaW52YWxpZFxuICAgICAqIG51bWJlciBmb3IgdGhlIHNlbGVjdGVkIG1vbnRoLCBsaWtlIGAzMWAgaW4gRmVicnVhcnksIGl0IHdpbGwgY29ycmVjdGx5IG5vdCBzaG93XG4gICAgICogZGF5cyB3aGljaCBhcmUgbm90IHZhbGlkIGZvciB0aGUgc2VsZWN0ZWQgbW9udGguXG4gICAgICovXG4gICAgZGF5VmFsdWVzOiBhbnk7XG4gICAgLyoqXG4gICAgICogQGlucHV0IHthcnJheSB8IHN0cmluZ30gVmFsdWVzIHVzZWQgdG8gY3JlYXRlIHRoZSBsaXN0IG9mIHNlbGVjdGFibGUgaG91cnMuIEJ5IGRlZmF1bHRcbiAgICAgKiB0aGUgaG91ciB2YWx1ZXMgcmFuZ2UgZnJvbSBgMGAgdG8gYDIzYCBmb3IgMjQtaG91ciwgb3IgYDFgIHRvIGAxMmAgZm9yIDEyLWhvdXIuIEhvd2V2ZXIsXG4gICAgICogdG8gY29udHJvbCBleGFjdGx5IHdoaWNoIGhvdXJzIHRvIGRpc3BsYXksIHRoZSBgaG91clZhbHVlc2AgaW5wdXQgY2FuIHRha2UgZWl0aGVyIGFuXG4gICAgICogYXJyYXkgb2YgbnVtYmVycywgb3Igc3RyaW5nIG9mIGNvbW1hIHNlcGFyYXRlZCBudW1iZXJzLlxuICAgICAqL1xuICAgIGhvdXJWYWx1ZXM6IGFueTtcbiAgICAvKipcbiAgICAgKiBAaW5wdXQge2FycmF5IHwgc3RyaW5nfSBWYWx1ZXMgdXNlZCB0byBjcmVhdGUgdGhlIGxpc3Qgb2Ygc2VsZWN0YWJsZSBtaW51dGVzLiBCeSBkZWZhdWx0XG4gICAgICogdGhlIG1pbnR1ZXMgcmFuZ2UgZnJvbSBgMGAgdG8gYDU5YC4gSG93ZXZlciwgdG8gY29udHJvbCBleGFjdGx5IHdoaWNoIG1pbnV0ZXMgdG8gZGlzcGxheSxcbiAgICAgKiB0aGUgYG1pbnV0ZVZhbHVlc2AgaW5wdXQgY2FuIHRha2UgZWl0aGVyIGFuIGFycmF5IG9mIG51bWJlcnMsIG9yIHN0cmluZyBvZiBjb21tYSBzZXBhcmF0ZWRcbiAgICAgKiBudW1iZXJzLiBGb3IgZXhhbXBsZSwgaWYgdGhlIG1pbnV0ZSBzZWxlY3Rpb25zIHNob3VsZCBvbmx5IGJlIGV2ZXJ5IDE1IG1pbnV0ZXMsIHRoZW5cbiAgICAgKiB0aGlzIGlucHV0IHZhbHVlIHdvdWxkIGJlIGBtaW51dGVWYWx1ZXM9XCIwLDE1LDMwLDQ1XCJgLlxuICAgICAqL1xuICAgIG1pbnV0ZVZhbHVlczogYW55O1xuICAgIC8qKlxuICAgICAqIEBpbnB1dCB7YXJyYXl9IEZ1bGwgbmFtZXMgZm9yIGVhY2ggbW9udGggbmFtZS4gVGhpcyBjYW4gYmUgdXNlZCB0byBwcm92aWRlXG4gICAgICogbG9jYWxlIG1vbnRoIG5hbWVzLiBEZWZhdWx0cyB0byBFbmdsaXNoLlxuICAgICAqL1xuICAgIG1vbnRoTmFtZXM6IGFueTtcbiAgICAvKipcbiAgICAgKiBAaW5wdXQge2FycmF5fSBTaG9ydCBhYmJyZXZpYXRlZCBuYW1lcyBmb3IgZWFjaCBtb250aCBuYW1lLiBUaGlzIGNhbiBiZSB1c2VkIHRvIHByb3ZpZGVcbiAgICAgKiBsb2NhbGUgbW9udGggbmFtZXMuIERlZmF1bHRzIHRvIEVuZ2xpc2guXG4gICAgICovXG4gICAgbW9udGhTaG9ydE5hbWVzOiBhbnk7XG4gICAgLyoqXG4gICAgICogQGlucHV0IHthcnJheX0gRnVsbCBkYXkgb2YgdGhlIHdlZWsgbmFtZXMuIFRoaXMgY2FuIGJlIHVzZWQgdG8gcHJvdmlkZVxuICAgICAqIGxvY2FsZSBuYW1lcyBmb3IgZWFjaCBkYXkgaW4gdGhlIHdlZWsuIERlZmF1bHRzIHRvIEVuZ2xpc2guXG4gICAgICovXG4gICAgZGF5TmFtZXM6IGFueTtcbiAgICAvKipcbiAgICAgKiBAaW5wdXQge2FycmF5fSBTaG9ydCBhYmJyZXZpYXRlZCBkYXkgb2YgdGhlIHdlZWsgbmFtZXMuIFRoaXMgY2FuIGJlIHVzZWQgdG8gcHJvdmlkZVxuICAgICAqIGxvY2FsZSBuYW1lcyBmb3IgZWFjaCBkYXkgaW4gdGhlIHdlZWsuIERlZmF1bHRzIHRvIEVuZ2xpc2guXG4gICAgICovXG4gICAgZGF5U2hvcnROYW1lczogYW55O1xuICAgIC8qKlxuICAgICAqIEBpbnB1dCB7YW55fSBBbnkgYWRkaXRpb25hbCBvcHRpb25zIHRoYXQgdGhlIHBpY2tlciBpbnRlcmZhY2UgY2FuIGFjY2VwdC5cbiAgICAgKiBTZWUgdGhlIFtQaWNrZXIgQVBJIGRvY3NdKC4uLy4uL3BpY2tlci9QaWNrZXIpIGZvciB0aGUgcGlja2VyIG9wdGlvbnMuXG4gICAgICovXG4gICAgcGlja2VyT3B0aW9uczogYW55O1xuICAgIC8qKlxuICAgICAqIEBpbnB1dCB7c3RyaW5nfSBUaGUgdGV4dCB0byBkaXNwbGF5IHdoZW4gdGhlcmUncyBubyBkYXRlIHNlbGVjdGVkIHlldC5cbiAgICAgKiBVc2luZyBsb3dlcmNhc2UgdG8gbWF0Y2ggdGhlIGlucHV0IGF0dHJpYnV0ZVxuICAgICAqL1xuICAgIHBsYWNlaG9sZGVyOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQG91dHB1dCB7YW55fSBFbWl0dGVkIHdoZW4gdGhlIGRhdGV0aW1lIHNlbGVjdGlvbiB3YXMgY2FuY2VsbGVkLlxuICAgICAqL1xuICAgIGlvbkNhbmNlbDogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgY29uc3RydWN0b3IoZm9ybTogRm9ybSwgY29uZmlnOiBDb25maWcsIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIHJlbmRlcmVyOiBSZW5kZXJlciwgaXRlbTogSXRlbSwgX3BpY2tlckN0cmw6IFBpY2tlckNvbnRyb2xsZXIpO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgX2lucHV0Tm9ybWFsaXplKHZhbDogYW55KTogRGF0ZVRpbWVEYXRhO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBfaW5wdXRVcGRhdGVkKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIF9pbnB1dFNob3VsZENoYW5nZSgpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFRPRE86IFJFTU9WRSBUSElTXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIF9pbnB1dENoYW5nZUV2ZW50KCk6IGFueTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgX2lucHV0TmdNb2RlbEV2ZW50KCk6IGFueTtcbiAgICBfY2xpY2soZXY6IFVJRXZlbnQpOiB2b2lkO1xuICAgIF9rZXl1cCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvcGVuKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdlbmVyYXRlKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHZhbGlkYXRlQ29sdW1uKG5hbWU6IHN0cmluZywgaW5kZXg6IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyLCBsb3dlckJvdW5kczogbnVtYmVyW10sIHVwcGVyQm91bmRzOiBudW1iZXJbXSk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHZhbGlkYXRlKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGRpdnlDb2x1bW5zKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHVwZGF0ZVRleHQoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0VmFsdWUoKTogRGF0ZVRpbWVEYXRhO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXRWYWx1ZU9yRGVmYXVsdCgpOiBEYXRlVGltZURhdGE7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIGFzIGEgZGF0ZSBzdHJpbmdcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0RGVmYXVsdFZhbHVlRGF0ZVN0cmluZygpOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhc1ZhbHVlKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNhbGNNaW5NYXgobm93PzogRGF0ZSk6IHZvaWQ7XG59XG4iXX0=