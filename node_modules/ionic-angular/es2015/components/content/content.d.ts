import { AfterViewInit, ElementRef, EventEmitter, NgZone, OnDestroy, Renderer } from '@angular/core';
import { App } from '../app/app';
import { Config } from '../../config/config';
import { DomController } from '../../platform/dom-controller';
import { Img } from '../img/img-interface';
import { Ion } from '../ion';
import { Keyboard } from '../../platform/keyboard';
import { NavController } from '../../navigation/nav-controller';
import { Content as IContent, Tabs } from '../../navigation/nav-interfaces';
import { Platform } from '../../platform/platform';
import { ScrollEvent, ScrollView } from '../../util/scroll-view';
import { ViewController } from '../../navigation/view-controller';
import * as ɵngcc0 from '@angular/core';
export { ScrollEvent } from '../../util/scroll-view';
export declare class EventEmitterProxy<T> extends EventEmitter<T> {
    onSubscribe: Function;
    subscribe(generatorOrNext?: any, error?: any, complete?: any): any;
}
/**
 * @name Content
 * @description
 * The Content component provides an easy to use content area with
 * some useful methods to control the scrollable area. There should
 * only be one content in a single view component. If additional scrollable
 * elements are needed, use [ionScroll](../../scroll/Scroll).
 *
 *
 * The content area can also implement pull-to-refresh with the
 * [Refresher](../../refresher/Refresher) component.
 *
 * @usage
 * ```html
 * <ion-content>
 *   Add your content here!
 * </ion-content>
 * ```
 *
 * To get a reference to the content component from a Page's logic,
 * you can use Angular's `@ViewChild` annotation:
 *
 * ```ts
 * import { Component, ViewChild } from '@angular/core';
 * import { Content } from 'ionic-angular';
 *
 * @Component({...})
 * export class MyPage{
 *   @ViewChild(Content) content: Content;
 *
 *   scrollToTop() {
 *     this.content.scrollToTop();
 *   }
 * }
 * ```
 *
 * @advanced
 *
 * ### Scroll Events
 *
 * Scroll events happen outside of Angular's Zones. This is for performance reasons. So
 * if you're trying to bind a value to any scroll event, it will need to be wrapped in
 * a `zone.run()`
 *
 * ```ts
 * import { Component, NgZone } from '@angular/core';
 * @Component({
 *   template: `
 *     <ion-header>
 *       <ion-navbar>
 *         <ion-title>{{scrollAmount}}</ion-title>
 *       </ion-navbar>
 *     </ion-header>
 *     <ion-content (ionScroll)="scrollHandler($event)">
 *        <p> Some realllllllly long content </p>
 *     </ion-content>
 * `})
 * class E2EPage {
 *  public scrollAmount = 0;
 *  constructor( public zone: NgZone){}
 *  scrollHandler(event) {
 *    console.log(`ScrollEvent: ${event}`)
 *    this.zone.run(()=>{
 *      // since scrollAmount is data-binded,
 *      // the update needs to happen in zone
 *      this.scrollAmount++
 *    })
 *  }
 * }
 * ```
 *
 * This goes for any scroll event, not just `ionScroll`.
 *
 * ### Resizing the content
 *
 * If the height of `ion-header`, `ion-footer` or `ion-tabbar`
 * changes dynamically, `content.resize()` has to be called in order to update the
 * layout of `Content`.
 *
 *
 * ```ts
 * @Component({
 *   template: `
 *     <ion-header>
 *       <ion-navbar>
 *         <ion-title>Main Navbar</ion-title>
 *       </ion-navbar>
 *       <ion-toolbar *ngIf="showToolbar">
 *         <ion-title>Dynamic Toolbar</ion-title>
 *       </ion-toolbar>
 *     </ion-header>
 *     <ion-content>
 *       <button ion-button (click)="toggleToolbar()">Toggle Toolbar</button>
 *     </ion-content>
 * `})
 *
 * class E2EPage {
 *   @ViewChild(Content) content: Content;
 *   showToolbar: boolean = false;
 *
 *   toggleToolbar() {
 *     this.showToolbar = !this.showToolbar;
 *     this.content.resize();
 *   }
 * }
 * ```
 *
 *
 * Scroll to a specific position
 *
 * ```ts
 * import { Component, ViewChild } from '@angular/core';
 * import { Content } from 'ionic-angular';
 *
 * @Component({
 *   template: `<ion-content>
 *                <button ion-button (click)="scrollTo()">Down 500px</button>
 *              </ion-content>`
 * )}
 * export class MyPage{
 *   @ViewChild(Content) content: Content;
 *
 *   scrollTo() {
 *     // set the scrollLeft to 0px, and scrollTop to 500px
 *     // the scroll duration should take 200ms
 *     this.content.scrollTo(0, 500, 200);
 *   }
 * }
 * ```
 *
 */
export declare class Content extends Ion implements OnDestroy, AfterViewInit, IContent {
    private _plt;
    private _dom;
    _app: App;
    _keyboard: Keyboard;
    _zone: NgZone;
    /** @internal */
    _cTop: number;
    /** @internal */
    _cBottom: number;
    /** @internal */
    _pTop: number;
    /** @internal */
    _pRight: number;
    /** @internal */
    _pBottom: number;
    /** @internal */
    _pLeft: number;
    /** @internal */
    _scrollPadding: number;
    /** @internal */
    _hdrHeight: number;
    /** @internal */
    _ftrHeight: number;
    /** @internal */
    _tabs: Tabs;
    /** @internal */
    _tabbarHeight: number;
    /** @internal */
    _tabsPlacement: string;
    /** @internal */
    _tTop: number;
    /** @internal */
    _fTop: number;
    /** @internal */
    _fBottom: number;
    /** @internal */
    _inputPolling: boolean;
    /** @internal */
    _scroll: ScrollView;
    /** @internal */
    _scLsn: Function;
    /** @internal */
    _fullscreen: boolean;
    /** @internal */
    _hasRefresher: boolean;
    /** @internal */
    _footerEle: HTMLElement;
    /** @internal */
    _dirty: boolean;
    /** @internal */
    _imgs: Img[];
    /** @internal */
    _viewCtrlReadSub: any;
    /** @internal */
    _viewCtrlWriteSub: any;
    /** @internal */
    _scrollDownOnLoad: boolean;
    _viewCtrl: any;
    private _imgReqBfr;
    private _imgRndBfr;
    private _imgVelMax;
    /** @hidden */
    statusbarPadding: boolean;
    /** @internal */
    _fixedContent: ElementRef;
    /** @internal */
    _scrollContent: ElementRef;
    /**
     * Content height of the viewable area. This does not include content
     * which is outside the overflow area, or content area which is under
     * headers and footers. Read-only.
     *
     * @return {number}
     */
    readonly contentHeight: number;
    /**
     * Content width including content which is not visible on the screen
     * due to overflow. Read-only.
     *
     * @return {number}
     */
    readonly contentWidth: number;
    /**
     * A number representing how many pixels the top of the content has been
     * adjusted, which could be by either padding or margin. This adjustment
     * is to account for the space needed for the header.
     *
     * @return {number}
     */
    contentTop: number;
    /**
     * A number representing how many pixels the bottom of the content has been
     * adjusted, which could be by either padding or margin. This adjustment
     * is to account for the space needed for the footer.
     *
     * @return {number}
     */
    contentBottom: number;
    /**
     * Content height including content which is not visible on the screen
     * due to overflow. Read-only.
     *
     * @return {number}
     */
    readonly scrollHeight: number;
    /**
     * Content width including content which is not visible due to
     * overflow. Read-only.
     *
     * @return {number}
     */
    readonly scrollWidth: number;
    /**
     * The distance of the content's top to its topmost visible content.
     *
     * @return {number}
     */
    /**
     * @param {number} top
     */
    scrollTop: number;
    /**
     * The distance of the content's left to its leftmost visible content.
     *
     * @return {number}
     */
    /**
     * @param {number} top
     */
    scrollLeft: number;
    /**
     * If the content is actively scrolling or not.
     *
     * @return {boolean}
     */
    readonly isScrolling: boolean;
    /**
     * The current, or last known, vertical scroll direction. Possible
     * string values include `down` and `up`.
     *
     * @return {string}
     */
    readonly directionY: string;
    /**
     * The current, or last known, horizontal scroll direction. Possible
     * string values include `right` and `left`.
     *
     * @return {string}
     */
    readonly directionX: string;
    /**
     * @output {ScrollEvent} Emitted when the scrolling first starts.
     */
    ionScrollStart: EventEmitterProxy<ScrollEvent>;
    /**
     * @output {ScrollEvent} Emitted on every scroll event.
     */
    ionScroll: EventEmitterProxy<ScrollEvent>;
    /**
     * @output {ScrollEvent} Emitted when scrolling ends.
     */
    ionScrollEnd: EventEmitterProxy<ScrollEvent>;
    constructor(config: Config, _plt: Platform, _dom: DomController, elementRef: ElementRef, renderer: Renderer, _app: App, _keyboard: Keyboard, _zone: NgZone, viewCtrl: ViewController, navCtrl: NavController);
    /**
     * @hidden
     */
    ngAfterViewInit(): void;
    /**
     * @hidden
     */
    enableJsScroll(): void;
    /**
     * @hidden
     */
    ngOnDestroy(): void;
    /**
     * @hidden
     */
    getScrollElement(): HTMLElement;
    /**
     * @private
     */
    getFixedElement(): HTMLElement;
    /**
     * @hidden
     */
    onScrollElementTransitionEnd(callback: {
        (ev: TransitionEvent): void;
    }): void;
    /**
     * Scroll to the specified position.
     *
     * @param {number} x  The x-value to scroll to.
     * @param {number} y  The y-value to scroll to.
     * @param {number} [duration]  Duration of the scroll animation in milliseconds. Defaults to `300`.
     * @returns {Promise} Returns a promise which is resolved when the scroll has completed.
     */
    scrollTo(x: number, y: number, duration?: number, done?: Function): Promise<any>;
    /**
     * Scroll to the top of the content component.
     *
     * @param {number} [duration]  Duration of the scroll animation in milliseconds. Defaults to `300`.
     * @returns {Promise} Returns a promise which is resolved when the scroll has completed.
     */
    scrollToTop(duration?: number): Promise<any>;
    /**
     * Scroll to the bottom of the content component.
     *
     * @param {number} [duration]  Duration of the scroll animation in milliseconds. Defaults to `300`.
     * @returns {Promise} Returns a promise which is resolved when the scroll has completed.
     */
    scrollToBottom(duration?: number): Promise<any>;
    /**
     * @input {boolean} If true, the content will scroll behind the headers
     * and footers. This effect can easily be seen by setting the toolbar
     * to transparent.
     */
    fullscreen: boolean;
    /**
     * @input {boolean} If true, the content will scroll down on load.
     */
    scrollDownOnLoad: boolean;
    /**
     * @private
     */
    addImg(img: Img): void;
    /**
     * @hidden
     */
    removeImg(img: Img): void;
    /**
     * @hidden
     * DOM WRITE
     */
    setScrollElementStyle(prop: string, val: any): void;
    /**
     * Returns the content and scroll elements' dimensions.
     * @returns {object} dimensions  The content and scroll elements' dimensions
     * {number} dimensions.contentHeight  content offsetHeight
     * {number} dimensions.contentTop  content offsetTop
     * {number} dimensions.contentBottom  content offsetTop+offsetHeight
     * {number} dimensions.contentWidth  content offsetWidth
     * {number} dimensions.contentLeft  content offsetLeft
     * {number} dimensions.contentRight  content offsetLeft + offsetWidth
     * {number} dimensions.scrollHeight  scroll scrollHeight
     * {number} dimensions.scrollTop  scroll scrollTop
     * {number} dimensions.scrollBottom  scroll scrollTop + scrollHeight
     * {number} dimensions.scrollWidth  scroll scrollWidth
     * {number} dimensions.scrollLeft  scroll scrollLeft
     * {number} dimensions.scrollRight  scroll scrollLeft + scrollWidth
     */
    getContentDimensions(): ContentDimensions;
    /**
     * @hidden
     * DOM WRITE
     * Adds padding to the bottom of the scroll element when the keyboard is open
     * so content below the keyboard can be scrolled into view.
     */
    addScrollPadding(newPadding: number): void;
    /**
     * @hidden
     * DOM WRITE
     */
    clearScrollPaddingFocusOut(): void;
    /**
     * Tell the content to recalculate its dimensions. This should be called
     * after dynamically adding/removing headers, footers, or tabs.
     */
    resize(): void;
    /**
     * @hidden
     * DOM READ
     */
    private _readDimensions();
    /**
     * @hidden
     * DOM WRITE
     */
    private _writeDimensions();
    /**
     * @hidden
     */
    imgsUpdate(): void;
    /**
     * @hidden
     */
    isImgsUpdatable(): boolean;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<Content, [null, null, null, null, null, null, null, null, { optional: true; }, { optional: true; }]>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<Content, "ion-content", never, { "fullscreen": "fullscreen"; "scrollDownOnLoad": "scrollDownOnLoad"; }, { "ionScrollStart": "ionScrollStart"; "ionScroll": "ionScroll"; "ionScrollEnd": "ionScrollEnd"; }, never, ["[ion-fixed],ion-fab", "*", "ion-refresher"]>;
}
export declare function updateImgs(imgs: Img[], viewableTop: number, contentHeight: number, scrollDirectionY: string, requestableBuffer: number, renderableBuffer: number): void;
export interface ContentDimensions {
    contentHeight: number;
    contentTop: number;
    contentBottom: number;
    contentWidth: number;
    contentLeft: number;
    scrollHeight: number;
    scrollTop: number;
    scrollWidth: number;
    scrollLeft: number;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGVudC5kLnRzIiwic291cmNlcyI6WyJjb250ZW50LmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFmdGVyVmlld0luaXQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgTmdab25lLCBPbkRlc3Ryb3ksIFJlbmRlcmVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBcHAgfSBmcm9tICcuLi9hcHAvYXBwJztcbmltcG9ydCB7IENvbmZpZyB9IGZyb20gJy4uLy4uL2NvbmZpZy9jb25maWcnO1xuaW1wb3J0IHsgRG9tQ29udHJvbGxlciB9IGZyb20gJy4uLy4uL3BsYXRmb3JtL2RvbS1jb250cm9sbGVyJztcbmltcG9ydCB7IEltZyB9IGZyb20gJy4uL2ltZy9pbWctaW50ZXJmYWNlJztcbmltcG9ydCB7IElvbiB9IGZyb20gJy4uL2lvbic7XG5pbXBvcnQgeyBLZXlib2FyZCB9IGZyb20gJy4uLy4uL3BsYXRmb3JtL2tleWJvYXJkJztcbmltcG9ydCB7IE5hdkNvbnRyb2xsZXIgfSBmcm9tICcuLi8uLi9uYXZpZ2F0aW9uL25hdi1jb250cm9sbGVyJztcbmltcG9ydCB7IENvbnRlbnQgYXMgSUNvbnRlbnQsIFRhYnMgfSBmcm9tICcuLi8uLi9uYXZpZ2F0aW9uL25hdi1pbnRlcmZhY2VzJztcbmltcG9ydCB7IFBsYXRmb3JtIH0gZnJvbSAnLi4vLi4vcGxhdGZvcm0vcGxhdGZvcm0nO1xuaW1wb3J0IHsgU2Nyb2xsRXZlbnQsIFNjcm9sbFZpZXcgfSBmcm9tICcuLi8uLi91dGlsL3Njcm9sbC12aWV3JztcbmltcG9ydCB7IFZpZXdDb250cm9sbGVyIH0gZnJvbSAnLi4vLi4vbmF2aWdhdGlvbi92aWV3LWNvbnRyb2xsZXInO1xuZXhwb3J0IHsgU2Nyb2xsRXZlbnQgfSBmcm9tICcuLi8uLi91dGlsL3Njcm9sbC12aWV3JztcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIEV2ZW50RW1pdHRlclByb3h5PFQ+IGV4dGVuZHMgRXZlbnRFbWl0dGVyPFQ+IHtcbiAgICBvblN1YnNjcmliZTogRnVuY3Rpb247XG4gICAgc3Vic2NyaWJlKGdlbmVyYXRvck9yTmV4dD86IGFueSwgZXJyb3I/OiBhbnksIGNvbXBsZXRlPzogYW55KTogYW55O1xufVxuLyoqXG4gKiBAbmFtZSBDb250ZW50XG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoZSBDb250ZW50IGNvbXBvbmVudCBwcm92aWRlcyBhbiBlYXN5IHRvIHVzZSBjb250ZW50IGFyZWEgd2l0aFxuICogc29tZSB1c2VmdWwgbWV0aG9kcyB0byBjb250cm9sIHRoZSBzY3JvbGxhYmxlIGFyZWEuIFRoZXJlIHNob3VsZFxuICogb25seSBiZSBvbmUgY29udGVudCBpbiBhIHNpbmdsZSB2aWV3IGNvbXBvbmVudC4gSWYgYWRkaXRpb25hbCBzY3JvbGxhYmxlXG4gKiBlbGVtZW50cyBhcmUgbmVlZGVkLCB1c2UgW2lvblNjcm9sbF0oLi4vLi4vc2Nyb2xsL1Njcm9sbCkuXG4gKlxuICpcbiAqIFRoZSBjb250ZW50IGFyZWEgY2FuIGFsc28gaW1wbGVtZW50IHB1bGwtdG8tcmVmcmVzaCB3aXRoIHRoZVxuICogW1JlZnJlc2hlcl0oLi4vLi4vcmVmcmVzaGVyL1JlZnJlc2hlcikgY29tcG9uZW50LlxuICpcbiAqIEB1c2FnZVxuICogYGBgaHRtbFxuICogPGlvbi1jb250ZW50PlxuICogICBBZGQgeW91ciBjb250ZW50IGhlcmUhXG4gKiA8L2lvbi1jb250ZW50PlxuICogYGBgXG4gKlxuICogVG8gZ2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBjb250ZW50IGNvbXBvbmVudCBmcm9tIGEgUGFnZSdzIGxvZ2ljLFxuICogeW91IGNhbiB1c2UgQW5ndWxhcidzIGBAVmlld0NoaWxkYCBhbm5vdGF0aW9uOlxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBDb21wb25lbnQsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICogaW1wb3J0IHsgQ29udGVudCB9IGZyb20gJ2lvbmljLWFuZ3VsYXInO1xuICpcbiAqIEBDb21wb25lbnQoey4uLn0pXG4gKiBleHBvcnQgY2xhc3MgTXlQYWdle1xuICogICBAVmlld0NoaWxkKENvbnRlbnQpIGNvbnRlbnQ6IENvbnRlbnQ7XG4gKlxuICogICBzY3JvbGxUb1RvcCgpIHtcbiAqICAgICB0aGlzLmNvbnRlbnQuc2Nyb2xsVG9Ub3AoKTtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogQGFkdmFuY2VkXG4gKlxuICogIyMjIFNjcm9sbCBFdmVudHNcbiAqXG4gKiBTY3JvbGwgZXZlbnRzIGhhcHBlbiBvdXRzaWRlIG9mIEFuZ3VsYXIncyBab25lcy4gVGhpcyBpcyBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gU29cbiAqIGlmIHlvdSdyZSB0cnlpbmcgdG8gYmluZCBhIHZhbHVlIHRvIGFueSBzY3JvbGwgZXZlbnQsIGl0IHdpbGwgbmVlZCB0byBiZSB3cmFwcGVkIGluXG4gKiBhIGB6b25lLnJ1bigpYFxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBDb21wb25lbnQsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICogQENvbXBvbmVudCh7XG4gKiAgIHRlbXBsYXRlOiBgXG4gKiAgICAgPGlvbi1oZWFkZXI+XG4gKiAgICAgICA8aW9uLW5hdmJhcj5cbiAqICAgICAgICAgPGlvbi10aXRsZT57e3Njcm9sbEFtb3VudH19PC9pb24tdGl0bGU+XG4gKiAgICAgICA8L2lvbi1uYXZiYXI+XG4gKiAgICAgPC9pb24taGVhZGVyPlxuICogICAgIDxpb24tY29udGVudCAoaW9uU2Nyb2xsKT1cInNjcm9sbEhhbmRsZXIoJGV2ZW50KVwiPlxuICogICAgICAgIDxwPiBTb21lIHJlYWxsbGxsbGxseSBsb25nIGNvbnRlbnQgPC9wPlxuICogICAgIDwvaW9uLWNvbnRlbnQ+XG4gKiBgfSlcbiAqIGNsYXNzIEUyRVBhZ2Uge1xuICogIHB1YmxpYyBzY3JvbGxBbW91bnQgPSAwO1xuICogIGNvbnN0cnVjdG9yKCBwdWJsaWMgem9uZTogTmdab25lKXt9XG4gKiAgc2Nyb2xsSGFuZGxlcihldmVudCkge1xuICogICAgY29uc29sZS5sb2coYFNjcm9sbEV2ZW50OiAke2V2ZW50fWApXG4gKiAgICB0aGlzLnpvbmUucnVuKCgpPT57XG4gKiAgICAgIC8vIHNpbmNlIHNjcm9sbEFtb3VudCBpcyBkYXRhLWJpbmRlZCxcbiAqICAgICAgLy8gdGhlIHVwZGF0ZSBuZWVkcyB0byBoYXBwZW4gaW4gem9uZVxuICogICAgICB0aGlzLnNjcm9sbEFtb3VudCsrXG4gKiAgICB9KVxuICogIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIFRoaXMgZ29lcyBmb3IgYW55IHNjcm9sbCBldmVudCwgbm90IGp1c3QgYGlvblNjcm9sbGAuXG4gKlxuICogIyMjIFJlc2l6aW5nIHRoZSBjb250ZW50XG4gKlxuICogSWYgdGhlIGhlaWdodCBvZiBgaW9uLWhlYWRlcmAsIGBpb24tZm9vdGVyYCBvciBgaW9uLXRhYmJhcmBcbiAqIGNoYW5nZXMgZHluYW1pY2FsbHksIGBjb250ZW50LnJlc2l6ZSgpYCBoYXMgdG8gYmUgY2FsbGVkIGluIG9yZGVyIHRvIHVwZGF0ZSB0aGVcbiAqIGxheW91dCBvZiBgQ29udGVudGAuXG4gKlxuICpcbiAqIGBgYHRzXG4gKiBAQ29tcG9uZW50KHtcbiAqICAgdGVtcGxhdGU6IGBcbiAqICAgICA8aW9uLWhlYWRlcj5cbiAqICAgICAgIDxpb24tbmF2YmFyPlxuICogICAgICAgICA8aW9uLXRpdGxlPk1haW4gTmF2YmFyPC9pb24tdGl0bGU+XG4gKiAgICAgICA8L2lvbi1uYXZiYXI+XG4gKiAgICAgICA8aW9uLXRvb2xiYXIgKm5nSWY9XCJzaG93VG9vbGJhclwiPlxuICogICAgICAgICA8aW9uLXRpdGxlPkR5bmFtaWMgVG9vbGJhcjwvaW9uLXRpdGxlPlxuICogICAgICAgPC9pb24tdG9vbGJhcj5cbiAqICAgICA8L2lvbi1oZWFkZXI+XG4gKiAgICAgPGlvbi1jb250ZW50PlxuICogICAgICAgPGJ1dHRvbiBpb24tYnV0dG9uIChjbGljayk9XCJ0b2dnbGVUb29sYmFyKClcIj5Ub2dnbGUgVG9vbGJhcjwvYnV0dG9uPlxuICogICAgIDwvaW9uLWNvbnRlbnQ+XG4gKiBgfSlcbiAqXG4gKiBjbGFzcyBFMkVQYWdlIHtcbiAqICAgQFZpZXdDaGlsZChDb250ZW50KSBjb250ZW50OiBDb250ZW50O1xuICogICBzaG93VG9vbGJhcjogYm9vbGVhbiA9IGZhbHNlO1xuICpcbiAqICAgdG9nZ2xlVG9vbGJhcigpIHtcbiAqICAgICB0aGlzLnNob3dUb29sYmFyID0gIXRoaXMuc2hvd1Rvb2xiYXI7XG4gKiAgICAgdGhpcy5jb250ZW50LnJlc2l6ZSgpO1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKlxuICogU2Nyb2xsIHRvIGEgc3BlY2lmaWMgcG9zaXRpb25cbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQ29tcG9uZW50LCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqIGltcG9ydCB7IENvbnRlbnQgfSBmcm9tICdpb25pYy1hbmd1bGFyJztcbiAqXG4gKiBAQ29tcG9uZW50KHtcbiAqICAgdGVtcGxhdGU6IGA8aW9uLWNvbnRlbnQ+XG4gKiAgICAgICAgICAgICAgICA8YnV0dG9uIGlvbi1idXR0b24gKGNsaWNrKT1cInNjcm9sbFRvKClcIj5Eb3duIDUwMHB4PC9idXR0b24+XG4gKiAgICAgICAgICAgICAgPC9pb24tY29udGVudD5gXG4gKiApfVxuICogZXhwb3J0IGNsYXNzIE15UGFnZXtcbiAqICAgQFZpZXdDaGlsZChDb250ZW50KSBjb250ZW50OiBDb250ZW50O1xuICpcbiAqICAgc2Nyb2xsVG8oKSB7XG4gKiAgICAgLy8gc2V0IHRoZSBzY3JvbGxMZWZ0IHRvIDBweCwgYW5kIHNjcm9sbFRvcCB0byA1MDBweFxuICogICAgIC8vIHRoZSBzY3JvbGwgZHVyYXRpb24gc2hvdWxkIHRha2UgMjAwbXNcbiAqICAgICB0aGlzLmNvbnRlbnQuc2Nyb2xsVG8oMCwgNTAwLCAyMDApO1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIENvbnRlbnQgZXh0ZW5kcyBJb24gaW1wbGVtZW50cyBPbkRlc3Ryb3ksIEFmdGVyVmlld0luaXQsIElDb250ZW50IHtcbiAgICBwcml2YXRlIF9wbHQ7XG4gICAgcHJpdmF0ZSBfZG9tO1xuICAgIF9hcHA6IEFwcDtcbiAgICBfa2V5Ym9hcmQ6IEtleWJvYXJkO1xuICAgIF96b25lOiBOZ1pvbmU7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9jVG9wOiBudW1iZXI7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9jQm90dG9tOiBudW1iZXI7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9wVG9wOiBudW1iZXI7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9wUmlnaHQ6IG51bWJlcjtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3BCb3R0b206IG51bWJlcjtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3BMZWZ0OiBudW1iZXI7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9zY3JvbGxQYWRkaW5nOiBudW1iZXI7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9oZHJIZWlnaHQ6IG51bWJlcjtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2Z0ckhlaWdodDogbnVtYmVyO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfdGFiczogVGFicztcbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3RhYmJhckhlaWdodDogbnVtYmVyO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfdGFic1BsYWNlbWVudDogc3RyaW5nO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfdFRvcDogbnVtYmVyO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZlRvcDogbnVtYmVyO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZkJvdHRvbTogbnVtYmVyO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfaW5wdXRQb2xsaW5nOiBib29sZWFuO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfc2Nyb2xsOiBTY3JvbGxWaWV3O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfc2NMc246IEZ1bmN0aW9uO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZnVsbHNjcmVlbjogYm9vbGVhbjtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2hhc1JlZnJlc2hlcjogYm9vbGVhbjtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2Zvb3RlckVsZTogSFRNTEVsZW1lbnQ7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9kaXJ0eTogYm9vbGVhbjtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2ltZ3M6IEltZ1tdO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfdmlld0N0cmxSZWFkU3ViOiBhbnk7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF92aWV3Q3RybFdyaXRlU3ViOiBhbnk7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9zY3JvbGxEb3duT25Mb2FkOiBib29sZWFuO1xuICAgIF92aWV3Q3RybDogYW55O1xuICAgIHByaXZhdGUgX2ltZ1JlcUJmcjtcbiAgICBwcml2YXRlIF9pbWdSbmRCZnI7XG4gICAgcHJpdmF0ZSBfaW1nVmVsTWF4O1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgc3RhdHVzYmFyUGFkZGluZzogYm9vbGVhbjtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2ZpeGVkQ29udGVudDogRWxlbWVudFJlZjtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3Njcm9sbENvbnRlbnQ6IEVsZW1lbnRSZWY7XG4gICAgLyoqXG4gICAgICogQ29udGVudCBoZWlnaHQgb2YgdGhlIHZpZXdhYmxlIGFyZWEuIFRoaXMgZG9lcyBub3QgaW5jbHVkZSBjb250ZW50XG4gICAgICogd2hpY2ggaXMgb3V0c2lkZSB0aGUgb3ZlcmZsb3cgYXJlYSwgb3IgY29udGVudCBhcmVhIHdoaWNoIGlzIHVuZGVyXG4gICAgICogaGVhZGVycyBhbmQgZm9vdGVycy4gUmVhZC1vbmx5LlxuICAgICAqXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIHJlYWRvbmx5IGNvbnRlbnRIZWlnaHQ6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBDb250ZW50IHdpZHRoIGluY2x1ZGluZyBjb250ZW50IHdoaWNoIGlzIG5vdCB2aXNpYmxlIG9uIHRoZSBzY3JlZW5cbiAgICAgKiBkdWUgdG8gb3ZlcmZsb3cuIFJlYWQtb25seS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICByZWFkb25seSBjb250ZW50V2lkdGg6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBBIG51bWJlciByZXByZXNlbnRpbmcgaG93IG1hbnkgcGl4ZWxzIHRoZSB0b3Agb2YgdGhlIGNvbnRlbnQgaGFzIGJlZW5cbiAgICAgKiBhZGp1c3RlZCwgd2hpY2ggY291bGQgYmUgYnkgZWl0aGVyIHBhZGRpbmcgb3IgbWFyZ2luLiBUaGlzIGFkanVzdG1lbnRcbiAgICAgKiBpcyB0byBhY2NvdW50IGZvciB0aGUgc3BhY2UgbmVlZGVkIGZvciB0aGUgaGVhZGVyLlxuICAgICAqXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGNvbnRlbnRUb3A6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBBIG51bWJlciByZXByZXNlbnRpbmcgaG93IG1hbnkgcGl4ZWxzIHRoZSBib3R0b20gb2YgdGhlIGNvbnRlbnQgaGFzIGJlZW5cbiAgICAgKiBhZGp1c3RlZCwgd2hpY2ggY291bGQgYmUgYnkgZWl0aGVyIHBhZGRpbmcgb3IgbWFyZ2luLiBUaGlzIGFkanVzdG1lbnRcbiAgICAgKiBpcyB0byBhY2NvdW50IGZvciB0aGUgc3BhY2UgbmVlZGVkIGZvciB0aGUgZm9vdGVyLlxuICAgICAqXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGNvbnRlbnRCb3R0b206IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBDb250ZW50IGhlaWdodCBpbmNsdWRpbmcgY29udGVudCB3aGljaCBpcyBub3QgdmlzaWJsZSBvbiB0aGUgc2NyZWVuXG4gICAgICogZHVlIHRvIG92ZXJmbG93LiBSZWFkLW9ubHkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgcmVhZG9ubHkgc2Nyb2xsSGVpZ2h0OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQ29udGVudCB3aWR0aCBpbmNsdWRpbmcgY29udGVudCB3aGljaCBpcyBub3QgdmlzaWJsZSBkdWUgdG9cbiAgICAgKiBvdmVyZmxvdy4gUmVhZC1vbmx5LlxuICAgICAqXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIHJlYWRvbmx5IHNjcm9sbFdpZHRoOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogVGhlIGRpc3RhbmNlIG9mIHRoZSBjb250ZW50J3MgdG9wIHRvIGl0cyB0b3Btb3N0IHZpc2libGUgY29udGVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9wXG4gICAgICovXG4gICAgc2Nyb2xsVG9wOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogVGhlIGRpc3RhbmNlIG9mIHRoZSBjb250ZW50J3MgbGVmdCB0byBpdHMgbGVmdG1vc3QgdmlzaWJsZSBjb250ZW50LlxuICAgICAqXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b3BcbiAgICAgKi9cbiAgICBzY3JvbGxMZWZ0OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIGNvbnRlbnQgaXMgYWN0aXZlbHkgc2Nyb2xsaW5nIG9yIG5vdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgcmVhZG9ubHkgaXNTY3JvbGxpbmc6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQsIG9yIGxhc3Qga25vd24sIHZlcnRpY2FsIHNjcm9sbCBkaXJlY3Rpb24uIFBvc3NpYmxlXG4gICAgICogc3RyaW5nIHZhbHVlcyBpbmNsdWRlIGBkb3duYCBhbmQgYHVwYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICByZWFkb25seSBkaXJlY3Rpb25ZOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQsIG9yIGxhc3Qga25vd24sIGhvcml6b250YWwgc2Nyb2xsIGRpcmVjdGlvbi4gUG9zc2libGVcbiAgICAgKiBzdHJpbmcgdmFsdWVzIGluY2x1ZGUgYHJpZ2h0YCBhbmQgYGxlZnRgLlxuICAgICAqXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIHJlYWRvbmx5IGRpcmVjdGlvblg6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBAb3V0cHV0IHtTY3JvbGxFdmVudH0gRW1pdHRlZCB3aGVuIHRoZSBzY3JvbGxpbmcgZmlyc3Qgc3RhcnRzLlxuICAgICAqL1xuICAgIGlvblNjcm9sbFN0YXJ0OiBFdmVudEVtaXR0ZXJQcm94eTxTY3JvbGxFdmVudD47XG4gICAgLyoqXG4gICAgICogQG91dHB1dCB7U2Nyb2xsRXZlbnR9IEVtaXR0ZWQgb24gZXZlcnkgc2Nyb2xsIGV2ZW50LlxuICAgICAqL1xuICAgIGlvblNjcm9sbDogRXZlbnRFbWl0dGVyUHJveHk8U2Nyb2xsRXZlbnQ+O1xuICAgIC8qKlxuICAgICAqIEBvdXRwdXQge1Njcm9sbEV2ZW50fSBFbWl0dGVkIHdoZW4gc2Nyb2xsaW5nIGVuZHMuXG4gICAgICovXG4gICAgaW9uU2Nyb2xsRW5kOiBFdmVudEVtaXR0ZXJQcm94eTxTY3JvbGxFdmVudD47XG4gICAgY29uc3RydWN0b3IoY29uZmlnOiBDb25maWcsIF9wbHQ6IFBsYXRmb3JtLCBfZG9tOiBEb21Db250cm9sbGVyLCBlbGVtZW50UmVmOiBFbGVtZW50UmVmLCByZW5kZXJlcjogUmVuZGVyZXIsIF9hcHA6IEFwcCwgX2tleWJvYXJkOiBLZXlib2FyZCwgX3pvbmU6IE5nWm9uZSwgdmlld0N0cmw6IFZpZXdDb250cm9sbGVyLCBuYXZDdHJsOiBOYXZDb250cm9sbGVyKTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGVuYWJsZUpzU2Nyb2xsKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldFNjcm9sbEVsZW1lbnQoKTogSFRNTEVsZW1lbnQ7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRGaXhlZEVsZW1lbnQoKTogSFRNTEVsZW1lbnQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uU2Nyb2xsRWxlbWVudFRyYW5zaXRpb25FbmQoY2FsbGJhY2s6IHtcbiAgICAgICAgKGV2OiBUcmFuc2l0aW9uRXZlbnQpOiB2b2lkO1xuICAgIH0pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFNjcm9sbCB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggIFRoZSB4LXZhbHVlIHRvIHNjcm9sbCB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAgVGhlIHktdmFsdWUgdG8gc2Nyb2xsIHRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZHVyYXRpb25dICBEdXJhdGlvbiBvZiB0aGUgc2Nyb2xsIGFuaW1hdGlvbiBpbiBtaWxsaXNlY29uZHMuIERlZmF1bHRzIHRvIGAzMDBgLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBSZXR1cm5zIGEgcHJvbWlzZSB3aGljaCBpcyByZXNvbHZlZCB3aGVuIHRoZSBzY3JvbGwgaGFzIGNvbXBsZXRlZC5cbiAgICAgKi9cbiAgICBzY3JvbGxUbyh4OiBudW1iZXIsIHk6IG51bWJlciwgZHVyYXRpb24/OiBudW1iZXIsIGRvbmU/OiBGdW5jdGlvbik6IFByb21pc2U8YW55PjtcbiAgICAvKipcbiAgICAgKiBTY3JvbGwgdG8gdGhlIHRvcCBvZiB0aGUgY29udGVudCBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uXSAgRHVyYXRpb24gb2YgdGhlIHNjcm9sbCBhbmltYXRpb24gaW4gbWlsbGlzZWNvbmRzLiBEZWZhdWx0cyB0byBgMzAwYC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gUmV0dXJucyBhIHByb21pc2Ugd2hpY2ggaXMgcmVzb2x2ZWQgd2hlbiB0aGUgc2Nyb2xsIGhhcyBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgc2Nyb2xsVG9Ub3AoZHVyYXRpb24/OiBudW1iZXIpOiBQcm9taXNlPGFueT47XG4gICAgLyoqXG4gICAgICogU2Nyb2xsIHRvIHRoZSBib3R0b20gb2YgdGhlIGNvbnRlbnQgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkdXJhdGlvbl0gIER1cmF0aW9uIG9mIHRoZSBzY3JvbGwgYW5pbWF0aW9uIGluIG1pbGxpc2Vjb25kcy4gRGVmYXVsdHMgdG8gYDMwMGAuXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFJldHVybnMgYSBwcm9taXNlIHdoaWNoIGlzIHJlc29sdmVkIHdoZW4gdGhlIHNjcm9sbCBoYXMgY29tcGxldGVkLlxuICAgICAqL1xuICAgIHNjcm9sbFRvQm90dG9tKGR1cmF0aW9uPzogbnVtYmVyKTogUHJvbWlzZTxhbnk+O1xuICAgIC8qKlxuICAgICAqIEBpbnB1dCB7Ym9vbGVhbn0gSWYgdHJ1ZSwgdGhlIGNvbnRlbnQgd2lsbCBzY3JvbGwgYmVoaW5kIHRoZSBoZWFkZXJzXG4gICAgICogYW5kIGZvb3RlcnMuIFRoaXMgZWZmZWN0IGNhbiBlYXNpbHkgYmUgc2VlbiBieSBzZXR0aW5nIHRoZSB0b29sYmFyXG4gICAgICogdG8gdHJhbnNwYXJlbnQuXG4gICAgICovXG4gICAgZnVsbHNjcmVlbjogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaW5wdXQge2Jvb2xlYW59IElmIHRydWUsIHRoZSBjb250ZW50IHdpbGwgc2Nyb2xsIGRvd24gb24gbG9hZC5cbiAgICAgKi9cbiAgICBzY3JvbGxEb3duT25Mb2FkOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYWRkSW1nKGltZzogSW1nKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVtb3ZlSW1nKGltZzogSW1nKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogRE9NIFdSSVRFXG4gICAgICovXG4gICAgc2V0U2Nyb2xsRWxlbWVudFN0eWxlKHByb3A6IHN0cmluZywgdmFsOiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbnRlbnQgYW5kIHNjcm9sbCBlbGVtZW50cycgZGltZW5zaW9ucy5cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBkaW1lbnNpb25zICBUaGUgY29udGVudCBhbmQgc2Nyb2xsIGVsZW1lbnRzJyBkaW1lbnNpb25zXG4gICAgICoge251bWJlcn0gZGltZW5zaW9ucy5jb250ZW50SGVpZ2h0ICBjb250ZW50IG9mZnNldEhlaWdodFxuICAgICAqIHtudW1iZXJ9IGRpbWVuc2lvbnMuY29udGVudFRvcCAgY29udGVudCBvZmZzZXRUb3BcbiAgICAgKiB7bnVtYmVyfSBkaW1lbnNpb25zLmNvbnRlbnRCb3R0b20gIGNvbnRlbnQgb2Zmc2V0VG9wK29mZnNldEhlaWdodFxuICAgICAqIHtudW1iZXJ9IGRpbWVuc2lvbnMuY29udGVudFdpZHRoICBjb250ZW50IG9mZnNldFdpZHRoXG4gICAgICoge251bWJlcn0gZGltZW5zaW9ucy5jb250ZW50TGVmdCAgY29udGVudCBvZmZzZXRMZWZ0XG4gICAgICoge251bWJlcn0gZGltZW5zaW9ucy5jb250ZW50UmlnaHQgIGNvbnRlbnQgb2Zmc2V0TGVmdCArIG9mZnNldFdpZHRoXG4gICAgICoge251bWJlcn0gZGltZW5zaW9ucy5zY3JvbGxIZWlnaHQgIHNjcm9sbCBzY3JvbGxIZWlnaHRcbiAgICAgKiB7bnVtYmVyfSBkaW1lbnNpb25zLnNjcm9sbFRvcCAgc2Nyb2xsIHNjcm9sbFRvcFxuICAgICAqIHtudW1iZXJ9IGRpbWVuc2lvbnMuc2Nyb2xsQm90dG9tICBzY3JvbGwgc2Nyb2xsVG9wICsgc2Nyb2xsSGVpZ2h0XG4gICAgICoge251bWJlcn0gZGltZW5zaW9ucy5zY3JvbGxXaWR0aCAgc2Nyb2xsIHNjcm9sbFdpZHRoXG4gICAgICoge251bWJlcn0gZGltZW5zaW9ucy5zY3JvbGxMZWZ0ICBzY3JvbGwgc2Nyb2xsTGVmdFxuICAgICAqIHtudW1iZXJ9IGRpbWVuc2lvbnMuc2Nyb2xsUmlnaHQgIHNjcm9sbCBzY3JvbGxMZWZ0ICsgc2Nyb2xsV2lkdGhcbiAgICAgKi9cbiAgICBnZXRDb250ZW50RGltZW5zaW9ucygpOiBDb250ZW50RGltZW5zaW9ucztcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogRE9NIFdSSVRFXG4gICAgICogQWRkcyBwYWRkaW5nIHRvIHRoZSBib3R0b20gb2YgdGhlIHNjcm9sbCBlbGVtZW50IHdoZW4gdGhlIGtleWJvYXJkIGlzIG9wZW5cbiAgICAgKiBzbyBjb250ZW50IGJlbG93IHRoZSBrZXlib2FyZCBjYW4gYmUgc2Nyb2xsZWQgaW50byB2aWV3LlxuICAgICAqL1xuICAgIGFkZFNjcm9sbFBhZGRpbmcobmV3UGFkZGluZzogbnVtYmVyKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogRE9NIFdSSVRFXG4gICAgICovXG4gICAgY2xlYXJTY3JvbGxQYWRkaW5nRm9jdXNPdXQoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBUZWxsIHRoZSBjb250ZW50IHRvIHJlY2FsY3VsYXRlIGl0cyBkaW1lbnNpb25zLiBUaGlzIHNob3VsZCBiZSBjYWxsZWRcbiAgICAgKiBhZnRlciBkeW5hbWljYWxseSBhZGRpbmcvcmVtb3ZpbmcgaGVhZGVycywgZm9vdGVycywgb3IgdGFicy5cbiAgICAgKi9cbiAgICByZXNpemUoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogRE9NIFJFQURcbiAgICAgKi9cbiAgICBwcml2YXRlIF9yZWFkRGltZW5zaW9ucygpO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBET00gV1JJVEVcbiAgICAgKi9cbiAgICBwcml2YXRlIF93cml0ZURpbWVuc2lvbnMoKTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaW1nc1VwZGF0ZSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBpc0ltZ3NVcGRhdGFibGUoKTogYm9vbGVhbjtcbn1cbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIHVwZGF0ZUltZ3MoaW1nczogSW1nW10sIHZpZXdhYmxlVG9wOiBudW1iZXIsIGNvbnRlbnRIZWlnaHQ6IG51bWJlciwgc2Nyb2xsRGlyZWN0aW9uWTogc3RyaW5nLCByZXF1ZXN0YWJsZUJ1ZmZlcjogbnVtYmVyLCByZW5kZXJhYmxlQnVmZmVyOiBudW1iZXIpOiB2b2lkO1xuZXhwb3J0IGludGVyZmFjZSBDb250ZW50RGltZW5zaW9ucyB7XG4gICAgY29udGVudEhlaWdodDogbnVtYmVyO1xuICAgIGNvbnRlbnRUb3A6IG51bWJlcjtcbiAgICBjb250ZW50Qm90dG9tOiBudW1iZXI7XG4gICAgY29udGVudFdpZHRoOiBudW1iZXI7XG4gICAgY29udGVudExlZnQ6IG51bWJlcjtcbiAgICBzY3JvbGxIZWlnaHQ6IG51bWJlcjtcbiAgICBzY3JvbGxUb3A6IG51bWJlcjtcbiAgICBzY3JvbGxXaWR0aDogbnVtYmVyO1xuICAgIHNjcm9sbExlZnQ6IG51bWJlcjtcbn1cbiJdfQ==