import { AfterContentInit, ChangeDetectorRef, DoCheck, ElementRef, IterableDiffer, IterableDiffers, NgZone, OnChanges, OnDestroy, Renderer, SimpleChanges, TrackByFunction } from '@angular/core';
import { Config } from '../../config/config';
import { Content, ScrollEvent } from '../content/content';
import { DomController } from '../../platform/dom-controller';
import { Platform } from '../../platform/platform';
import { ViewController } from '../../navigation/view-controller';
import { VirtualCell, VirtualData, VirtualNode } from './virtual-util';
import { VirtualItem } from './virtual-item';
import { VirtualFooter } from './virtual-footer';
import { VirtualHeader } from './virtual-header';
/**
 * @name VirtualScroll
 * @description
 * Virtual Scroll displays a virtual, "infinite" list. An array of records
 * is passed to the virtual scroll containing the data to create templates
 * for. The template created for each record, referred to as a cell, can
 * consist of items, headers, and footers.
 *
 * For performance reasons, not every record in the list is rendered at once;
 * instead a small subset of records (enough to fill the viewport) are rendered
 * and reused as the user scrolls.
 *
 * ### The Basics
 *
 * The array of records should be passed to the `virtualScroll` property.
 * The data given to the `virtualScroll` property must be an array. An item
 * template with the `*virtualItem` property is required in the `virtualScroll`.
 * The `virtualScroll` and `*virtualItem` properties can be added to any element.
 *
 * ```html
 * <ion-list [virtualScroll]="items">
 *
 *   <ion-item *virtualItem="let item">
 *     {% raw %}{{ item }}{% endraw %}
 *   </ion-item>
 *
 * </ion-list>
 * ```
 *
 *
 * ### Section Headers and Footers
 *
 * Section headers and footers are optional. They can be dynamically created
 * from developer-defined functions. For example, a large list of contacts
 * usually has a divider for each letter in the alphabet. Developers provide
 * their own custom function to be called on each record. The logic in the
 * custom function should determine whether to create the section template
 * and what data to provide to the template. The custom function should
 * return `null` if a template shouldn't be created.
 *
 * ```html
 * <ion-list [virtualScroll]="items" [headerFn]="myHeaderFn">
 *
 *   <ion-item-divider *virtualHeader="let header">
 *     Header: {% raw %}{{ header }}{% endraw %}
 *   </ion-item-divider>
 *
 *   <ion-item *virtualItem="let item">
 *     Item: {% raw %}{{ item }}{% endraw %}
 *   </ion-item>
 *
 * </ion-list>
 * ```
 *
 * Below is an example of a custom function called on every record. It
 * gets passed the individual record, the record's index number,
 * and the entire array of records. In this example, after every 20
 * records a header will be inserted. So between the 19th and 20th records,
 * between the 39th and 40th, and so on, a `<ion-item-divider>` will
 * be created and the template's data will come from the function's
 * returned data.
 *
 * ```ts
 * myHeaderFn(record, recordIndex, records) {
 *   if (recordIndex % 20 === 0) {
 *     return 'Header ' + recordIndex;
 *   }
 *   return null;
 * }
 * ```
 *
 *
 * ### Approximate Widths and Heights
 *
 * If the height of items in the virtual scroll are not close to the
 * default size of 40px, it is extremely important to provide a value for
 * approxItemHeight height. An exact pixel-perfect size is not necessary,
 * but without an estimate the virtual scroll will not render correctly.
 *
 * The approximate width and height of each template is used to help
 * determine how many cells should be created, and to help calculate
 * the height of the scrollable area. Note that the actual rendered size
 * of each cell comes from the app's CSS, whereas this approximation
 * is only used to help calculate initial dimensions.
 *
 * It's also important to know that Ionic's default item sizes have
 * slightly different heights between platforms, which is perfectly fine.
 *
 *
 * ### Images Within Virtual Scroll
 *
 * HTTP requests, image decoding, and image rendering can cause jank while
 * scrolling. In order to better control images, Ionic provides `<ion-img>`
 * to manage HTTP requests and image rendering. While scrolling through items
 * quickly, `<ion-img>` knows when and when not to make requests, when and
 * when not to render images, and only loads the images that are viewable
 * after scrolling. [Read more about `ion-img`.](../../img/Img/)
 *
 * It's also important for app developers to ensure image sizes are locked in,
 * and after images have fully loaded they do not change size and affect any
 * other element sizes. Simply put, to ensure rendering bugs are not introduced,
 * it's vital that elements within a virtual item does not dynamically change.
 *
 * For virtual scrolling, the natural effects of the `<img>` are not desirable
 * features. We recommend using the `<ion-img>` component over the native
 * `<img>` element because when an `<img>` element is added to the DOM, it
 * immediately makes a HTTP request for the image file. Additionally, `<img>`
 * renders whenever it wants which could be while the user is scrolling. However,
 * `<ion-img>` is governed by the containing `ion-content` and does not render
 * images while scrolling quickly.
 *
 * ```html
 * <ion-list [virtualScroll]="items">
 *
 *   <ion-item *virtualItem="let item">
 *     <ion-avatar item-start>
 *       <ion-img [src]="item.avatarUrl"></ion-img>
 *     </ion-avatar>
 *    {% raw %} {{ item.firstName }} {{ item.lastName }}{% endraw %}
 *   </ion-item>
 *
 * </ion-list>
 * ```
 *
 *
 * ### Custom Components
 *
 * If a custom component is going to be used within Virtual Scroll, it's best
 * to wrap it with a good old `<div>` to ensure the component is rendered
 * correctly. Since each custom component's implementation and internals can be
 * quite different, wrapping within a `<div>` is a safe way to make sure
 * dimensions are measured correctly.
 *
 * ```html
 * <ion-list [virtualScroll]="items">
 *
 *   <div *virtualItem="let item">
 *     <my-custom-item [item]="item">
 *       {% raw %} {{ item }}{% endraw %}
 *     </my-custom-item>
 *   </div>
 *
 * </ion-list>
 * ```
 *
 *
 * ## Virtual Scroll Performance Tips
 *
 * #### iOS Cordova WKWebView
 *
 * When deploying to iOS with Cordova, it's highly recommended to use the
 * [WKWebView plugin](http://blog.ionic.io/cordova-ios-performance-improvements-drop-in-speed-with-wkwebview/)
 * in order to take advantage of iOS's higher performimg webview. Additionally,
 * WKWebView is superior at scrolling efficiently in comparision to the older
 * UIWebView.
 *
 * #### Lock in element dimensions and locations
 *
 * In order for virtual scroll to efficiently size and locate every item, it's
 * very important every element within each virtual item does not dynamically
 * change its dimensions or location. The best way to ensure size and location
 * does not change, it's recommended each virtual item has locked in its size
 * via CSS.
 *
 * #### Use `ion-img` for images
 *
 * When including images within Virtual Scroll, be sure to use
 * [`ion-img`](../img/Img/) rather than the standard `<img>` HTML element.
 * With `ion-img`, images are lazy loaded so only the viewable ones are
 * rendered, and HTTP requests are efficiently controlled while scrolling.
 *
 * #### Set Approximate Widths and Heights
 *
 * As mentioned above, all elements should lock in their dimensions. However,
 * virtual scroll isn't aware of the dimensions until after they have been
 * rendered. For the initial render, virtual scroll still needs to set
 * how many items should be built. With "approx" property inputs, such as
 * `approxItemHeight`, we're able to give virtual scroll an approximate size,
 * therefore allowing virtual scroll to decide how many items should be
 * created.
 *
 * #### Changing dataset should use `virtualTrackBy`
 *
 * It is possible for the identities of elements in the iterator to change
 * while the data does not. This can happen, for example, if the iterator
 * produced from an RPC to the server, and that RPC is re-run. Even if the
 * "data" hasn't changed, the second response will produce objects with
 * different identities, and Ionic will tear down the entire DOM and rebuild
 * it. This is an expensive operation and should be avoided if possible.
 *
 * #### Efficient headers and footer functions
 *
 * Each virtual item must stay extremely efficient, but one way to really
 * kill its performance is to perform any DOM operations within section header
 * and footer functions. These functions are called for every record in the
 * dataset, so please make sure they're performant.
 *
 */
import * as Éµngcc0 from '@angular/core';
export declare class VirtualScroll implements DoCheck, OnChanges, AfterContentInit, OnDestroy {
    private _iterableDiffers;
    private _elementRef;
    private _renderer;
    private _zone;
    private _cd;
    private _content;
    private _plt;
    private _ctrl;
    private _config;
    private _dom;
    _differ: IterableDiffer<any>;
    _scrollSub: any;
    _scrollEndSub: any;
    _resizeSub: any;
    _init: boolean;
    _lastEle: boolean;
    _hdrFn: Function;
    _ftrFn: Function;
    _records: any[];
    _cells: VirtualCell[];
    _nodes: VirtualNode[];
    _vHeight: number;
    _lastCheck: number;
    _recordSize: number;
    _data: VirtualData;
    _queue: number;
    _itmTmp: VirtualItem;
    _hdrTmp: VirtualHeader;
    _ftrTmp: VirtualFooter;
    /**
     * @input {array} The data that builds the templates within the virtual scroll.
     * This is the same data that you'd pass to `*ngFor`. It's important to note
     * that when this data has changed, then the entire virtual scroll is reset,
     * which is an expensive operation and should be avoided if possible.
     */
    virtualScroll: any;
    /**
     * @input {number} The buffer ratio is used to decide how many cells
     * should get created when initially rendered. The number is a
     * multiplier against the viewable area's height. For example, if it
     * takes `20` cells to fill up the height of the viewable area, then
     * with a buffer ratio of `3` it will create `60` cells that are
     * available for reuse while scrolling. For better performance, it's
     * better to have more cells than what are required to fill the
     * viewable area. Default is `3`.
     * In case more than one items are rendered per row, bufferRatio
     * has to account for that and a multiple number should be used.
     * For example if a single item per row list used 3 as bufferRatio
     * a 4 item per row list should use 3 * 4 = 12 as buffer ratio.
     */
    bufferRatio: number;
    /**
     * @input {string} The approximate width of each item template's cell.
     * This dimension is used to help determine how many cells should
     * be created when initialized, and to help calculate the height of
     * the scrollable area. This value can use either `px` or `%` units.
     * Note that the actual rendered size of each cell comes from the
     * app's CSS, whereas this approximation is used to help calculate
     * initial dimensions before the item has been rendered. Default is
     * `100%`.
     */
    approxItemWidth: string;
    /**
     * @input {string} It is important to provide this
     * if virtual item height will be significantly larger than the default
     * The approximate height of each virtual item template's cell.
     * This dimension is used to help determine how many cells should
     * be created when initialized, and to help calculate the height of
     * the scrollable area. This height value can only use `px` units.
     * Note that the actual rendered size of each cell comes from the
     * app's CSS, whereas this approximation is used to help calculate
     * initial dimensions before the item has been rendered. Default is
     * `40px`.
     */
    approxItemHeight: string;
    /**
     * @input {string} The approximate width of each header template's cell.
     * This dimension is used to help determine how many cells should
     * be created when initialized, and to help calculate the height of
     * the scrollable area. This value can use either `px` or `%` units.
     * Note that the actual rendered size of each cell comes from the
     * app's CSS, whereas this approximation is used to help calculate
     * initial dimensions. Default is `100%`.
     */
    approxHeaderWidth: string;
    /**
     * @input {string} The approximate height of each header template's cell.
     * This dimension is used to help determine how many cells should
     * be created when initialized, and to help calculate the height of
     * the scrollable area. This height value can only use `px` units.
     * Note that the actual rendered size of each cell comes from the
     * app's CSS, whereas this approximation is used to help calculate
     * initial dimensions before the item has been rendered. Default is `40px`.
     */
    approxHeaderHeight: string;
    /**
     * @input {string} The approximate width of each footer template's cell.
     * This dimension is used to help determine how many cells should
     * be created when initialized, and to help calculate the height of
     * the scrollable area. This value can use either `px` or `%` units.
     * Note that the actual rendered size of each cell comes from the
     * app's CSS, whereas this approximation is used to help calculate
     * initial dimensions before the item has been rendered. Default is `100%`.
     */
    approxFooterWidth: string;
    /**
     * @input {string} The approximate height of each footer template's cell.
     * This dimension is used to help determine how many cells should
     * be created when initialized, and to help calculate the height of
     * the scrollable area. This height value can only use `px` units.
     * Note that the actual rendered size of each cell comes from the
     * app's CSS, whereas this approximation is used to help calculate
     * initial dimensions before the item has been rendered. Default is `40px`.
     */
    approxFooterHeight: string;
    /**
     * @input {function} Section headers and the data used within its given
     * template can be dynamically created by passing a function to `headerFn`.
     * For example, a large list of contacts usually has dividers between each
     * letter in the alphabet. App's can provide their own custom `headerFn`
     * which is called with each record within the dataset. The logic within
     * the header function can decide if the header template should be used,
     * and what data to give to the header template. The function must return
     * `null` if a header cell shouldn't be created.
     */
    headerFn: Function;
    /**
     * @input {function} Section footers and the data used within its given
     * template can be dynamically created by passing a function to `footerFn`.
     * The logic within the footer function can decide if the footer template
     * should be used, and what data to give to the footer template. The function
     * must return `null` if a footer cell shouldn't be created.
     */
    footerFn: Function;
    /**
     * @input {function} Same as `ngForTrackBy` which can be used on `ngFor`.
     */
    virtualTrackBy: TrackByFunction<any>;
    constructor(_iterableDiffers: IterableDiffers, _elementRef: ElementRef, _renderer: Renderer, _zone: NgZone, _cd: ChangeDetectorRef, _content: Content, _plt: Platform, _ctrl: ViewController, _config: Config, _dom: DomController);
    /**
     * @hidden
     */
    firstRecord(): number;
    /**
     * @hidden
     */
    lastRecord(): number;
    /**
    * @hidden
    */
    ngOnChanges(changes: SimpleChanges): void;
    /**
     * @hidden
     */
    ngDoCheck(): void;
    /**
     * @hidden
     */
    readUpdate(needClean: boolean): void;
    /**
     * @hidden
     */
    writeUpdate(needClean: boolean): void;
    /**
     * @hidden
     */
    private calcDimensions();
    /**
     * @hidden
     * DOM WRITE
     */
    renderVirtual(needClean: boolean): void;
    /**
     * @hidden
     */
    resize(): void;
    /**
     * @hidden
     */
    private _stepDOMWrite();
    /**
     * @hidden
     */
    private _stepChangeDetection();
    /**
     * @hidden
     */
    private _stepNoChanges();
    /**
     * @hidden
     */
    scrollUpdate(ev: ScrollEvent): void;
    /**
     * @hidden
     * DOM WRITE
     */
    scrollEnd(): void;
    /**
     * @hidden
     * NO DOM
     */
    private _listeners();
    /**
     * @hidden
     * DOM WRITE
     */
    private _setHeight(newVirtualHeight);
    /**
     * @hidden
     */
    ngAfterContentInit(): void;
    /**
     * @hidden
     */
    setElementClass(className: string, add: boolean): void;
    /**
     * @hidden
     */
    ngOnDestroy(): void;
    static Éµfac: Éµngcc0.ÉµÉµFactoryDef<VirtualScroll, never>;
    static Éµdir: Éµngcc0.ÉµÉµDirectiveDefWithMeta<VirtualScroll, "[virtualScroll]", never, { "bufferRatio": "bufferRatio"; "approxItemWidth": "approxItemWidth"; "approxHeaderWidth": "approxHeaderWidth"; "approxHeaderHeight": "approxHeaderHeight"; "approxFooterWidth": "approxFooterWidth"; "approxFooterHeight": "approxFooterHeight"; "virtualScroll": "virtualScroll"; "headerFn": "headerFn"; "footerFn": "footerFn"; "approxItemHeight": "approxItemHeight"; "virtualTrackBy": "virtualTrackBy"; }, {}, ["_itmTmp", "_hdrTmp", "_ftrTmp"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmlydHVhbC1zY3JvbGwuZC50cyIsInNvdXJjZXMiOlsidmlydHVhbC1zY3JvbGwuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBZnRlckNvbnRlbnRJbml0LCBDaGFuZ2VEZXRlY3RvclJlZiwgRG9DaGVjaywgRWxlbWVudFJlZiwgSXRlcmFibGVEaWZmZXIsIEl0ZXJhYmxlRGlmZmVycywgTmdab25lLCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgUmVuZGVyZXIsIFNpbXBsZUNoYW5nZXMsIFRyYWNrQnlGdW5jdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29uZmlnIH0gZnJvbSAnLi4vLi4vY29uZmlnL2NvbmZpZyc7XG5pbXBvcnQgeyBDb250ZW50LCBTY3JvbGxFdmVudCB9IGZyb20gJy4uL2NvbnRlbnQvY29udGVudCc7XG5pbXBvcnQgeyBEb21Db250cm9sbGVyIH0gZnJvbSAnLi4vLi4vcGxhdGZvcm0vZG9tLWNvbnRyb2xsZXInO1xuaW1wb3J0IHsgUGxhdGZvcm0gfSBmcm9tICcuLi8uLi9wbGF0Zm9ybS9wbGF0Zm9ybSc7XG5pbXBvcnQgeyBWaWV3Q29udHJvbGxlciB9IGZyb20gJy4uLy4uL25hdmlnYXRpb24vdmlldy1jb250cm9sbGVyJztcbmltcG9ydCB7IFZpcnR1YWxDZWxsLCBWaXJ0dWFsRGF0YSwgVmlydHVhbE5vZGUgfSBmcm9tICcuL3ZpcnR1YWwtdXRpbCc7XG5pbXBvcnQgeyBWaXJ0dWFsSXRlbSB9IGZyb20gJy4vdmlydHVhbC1pdGVtJztcbmltcG9ydCB7IFZpcnR1YWxGb290ZXIgfSBmcm9tICcuL3ZpcnR1YWwtZm9vdGVyJztcbmltcG9ydCB7IFZpcnR1YWxIZWFkZXIgfSBmcm9tICcuL3ZpcnR1YWwtaGVhZGVyJztcbi8qKlxuICogQG5hbWUgVmlydHVhbFNjcm9sbFxuICogQGRlc2NyaXB0aW9uXG4gKiBWaXJ0dWFsIFNjcm9sbCBkaXNwbGF5cyBhIHZpcnR1YWwsIFwiaW5maW5pdGVcIiBsaXN0LiBBbiBhcnJheSBvZiByZWNvcmRzXG4gKiBpcyBwYXNzZWQgdG8gdGhlIHZpcnR1YWwgc2Nyb2xsIGNvbnRhaW5pbmcgdGhlIGRhdGEgdG8gY3JlYXRlIHRlbXBsYXRlc1xuICogZm9yLiBUaGUgdGVtcGxhdGUgY3JlYXRlZCBmb3IgZWFjaCByZWNvcmQsIHJlZmVycmVkIHRvIGFzIGEgY2VsbCwgY2FuXG4gKiBjb25zaXN0IG9mIGl0ZW1zLCBoZWFkZXJzLCBhbmQgZm9vdGVycy5cbiAqXG4gKiBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgbm90IGV2ZXJ5IHJlY29yZCBpbiB0aGUgbGlzdCBpcyByZW5kZXJlZCBhdCBvbmNlO1xuICogaW5zdGVhZCBhIHNtYWxsIHN1YnNldCBvZiByZWNvcmRzIChlbm91Z2ggdG8gZmlsbCB0aGUgdmlld3BvcnQpIGFyZSByZW5kZXJlZFxuICogYW5kIHJldXNlZCBhcyB0aGUgdXNlciBzY3JvbGxzLlxuICpcbiAqICMjIyBUaGUgQmFzaWNzXG4gKlxuICogVGhlIGFycmF5IG9mIHJlY29yZHMgc2hvdWxkIGJlIHBhc3NlZCB0byB0aGUgYHZpcnR1YWxTY3JvbGxgIHByb3BlcnR5LlxuICogVGhlIGRhdGEgZ2l2ZW4gdG8gdGhlIGB2aXJ0dWFsU2Nyb2xsYCBwcm9wZXJ0eSBtdXN0IGJlIGFuIGFycmF5LiBBbiBpdGVtXG4gKiB0ZW1wbGF0ZSB3aXRoIHRoZSBgKnZpcnR1YWxJdGVtYCBwcm9wZXJ0eSBpcyByZXF1aXJlZCBpbiB0aGUgYHZpcnR1YWxTY3JvbGxgLlxuICogVGhlIGB2aXJ0dWFsU2Nyb2xsYCBhbmQgYCp2aXJ0dWFsSXRlbWAgcHJvcGVydGllcyBjYW4gYmUgYWRkZWQgdG8gYW55IGVsZW1lbnQuXG4gKlxuICogYGBgaHRtbFxuICogPGlvbi1saXN0IFt2aXJ0dWFsU2Nyb2xsXT1cIml0ZW1zXCI+XG4gKlxuICogICA8aW9uLWl0ZW0gKnZpcnR1YWxJdGVtPVwibGV0IGl0ZW1cIj5cbiAqICAgICB7JSByYXcgJX17eyBpdGVtIH19eyUgZW5kcmF3ICV9XG4gKiAgIDwvaW9uLWl0ZW0+XG4gKlxuICogPC9pb24tbGlzdD5cbiAqIGBgYFxuICpcbiAqXG4gKiAjIyMgU2VjdGlvbiBIZWFkZXJzIGFuZCBGb290ZXJzXG4gKlxuICogU2VjdGlvbiBoZWFkZXJzIGFuZCBmb290ZXJzIGFyZSBvcHRpb25hbC4gVGhleSBjYW4gYmUgZHluYW1pY2FsbHkgY3JlYXRlZFxuICogZnJvbSBkZXZlbG9wZXItZGVmaW5lZCBmdW5jdGlvbnMuIEZvciBleGFtcGxlLCBhIGxhcmdlIGxpc3Qgb2YgY29udGFjdHNcbiAqIHVzdWFsbHkgaGFzIGEgZGl2aWRlciBmb3IgZWFjaCBsZXR0ZXIgaW4gdGhlIGFscGhhYmV0LiBEZXZlbG9wZXJzIHByb3ZpZGVcbiAqIHRoZWlyIG93biBjdXN0b20gZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGVhY2ggcmVjb3JkLiBUaGUgbG9naWMgaW4gdGhlXG4gKiBjdXN0b20gZnVuY3Rpb24gc2hvdWxkIGRldGVybWluZSB3aGV0aGVyIHRvIGNyZWF0ZSB0aGUgc2VjdGlvbiB0ZW1wbGF0ZVxuICogYW5kIHdoYXQgZGF0YSB0byBwcm92aWRlIHRvIHRoZSB0ZW1wbGF0ZS4gVGhlIGN1c3RvbSBmdW5jdGlvbiBzaG91bGRcbiAqIHJldHVybiBgbnVsbGAgaWYgYSB0ZW1wbGF0ZSBzaG91bGRuJ3QgYmUgY3JlYXRlZC5cbiAqXG4gKiBgYGBodG1sXG4gKiA8aW9uLWxpc3QgW3ZpcnR1YWxTY3JvbGxdPVwiaXRlbXNcIiBbaGVhZGVyRm5dPVwibXlIZWFkZXJGblwiPlxuICpcbiAqICAgPGlvbi1pdGVtLWRpdmlkZXIgKnZpcnR1YWxIZWFkZXI9XCJsZXQgaGVhZGVyXCI+XG4gKiAgICAgSGVhZGVyOiB7JSByYXcgJX17eyBoZWFkZXIgfX17JSBlbmRyYXcgJX1cbiAqICAgPC9pb24taXRlbS1kaXZpZGVyPlxuICpcbiAqICAgPGlvbi1pdGVtICp2aXJ0dWFsSXRlbT1cImxldCBpdGVtXCI+XG4gKiAgICAgSXRlbTogeyUgcmF3ICV9e3sgaXRlbSB9fXslIGVuZHJhdyAlfVxuICogICA8L2lvbi1pdGVtPlxuICpcbiAqIDwvaW9uLWxpc3Q+XG4gKiBgYGBcbiAqXG4gKiBCZWxvdyBpcyBhbiBleGFtcGxlIG9mIGEgY3VzdG9tIGZ1bmN0aW9uIGNhbGxlZCBvbiBldmVyeSByZWNvcmQuIEl0XG4gKiBnZXRzIHBhc3NlZCB0aGUgaW5kaXZpZHVhbCByZWNvcmQsIHRoZSByZWNvcmQncyBpbmRleCBudW1iZXIsXG4gKiBhbmQgdGhlIGVudGlyZSBhcnJheSBvZiByZWNvcmRzLiBJbiB0aGlzIGV4YW1wbGUsIGFmdGVyIGV2ZXJ5IDIwXG4gKiByZWNvcmRzIGEgaGVhZGVyIHdpbGwgYmUgaW5zZXJ0ZWQuIFNvIGJldHdlZW4gdGhlIDE5dGggYW5kIDIwdGggcmVjb3JkcyxcbiAqIGJldHdlZW4gdGhlIDM5dGggYW5kIDQwdGgsIGFuZCBzbyBvbiwgYSBgPGlvbi1pdGVtLWRpdmlkZXI+YCB3aWxsXG4gKiBiZSBjcmVhdGVkIGFuZCB0aGUgdGVtcGxhdGUncyBkYXRhIHdpbGwgY29tZSBmcm9tIHRoZSBmdW5jdGlvbidzXG4gKiByZXR1cm5lZCBkYXRhLlxuICpcbiAqIGBgYHRzXG4gKiBteUhlYWRlckZuKHJlY29yZCwgcmVjb3JkSW5kZXgsIHJlY29yZHMpIHtcbiAqICAgaWYgKHJlY29yZEluZGV4ICUgMjAgPT09IDApIHtcbiAqICAgICByZXR1cm4gJ0hlYWRlciAnICsgcmVjb3JkSW5kZXg7XG4gKiAgIH1cbiAqICAgcmV0dXJuIG51bGw7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKlxuICogIyMjIEFwcHJveGltYXRlIFdpZHRocyBhbmQgSGVpZ2h0c1xuICpcbiAqIElmIHRoZSBoZWlnaHQgb2YgaXRlbXMgaW4gdGhlIHZpcnR1YWwgc2Nyb2xsIGFyZSBub3QgY2xvc2UgdG8gdGhlXG4gKiBkZWZhdWx0IHNpemUgb2YgNDBweCwgaXQgaXMgZXh0cmVtZWx5IGltcG9ydGFudCB0byBwcm92aWRlIGEgdmFsdWUgZm9yXG4gKiBhcHByb3hJdGVtSGVpZ2h0IGhlaWdodC4gQW4gZXhhY3QgcGl4ZWwtcGVyZmVjdCBzaXplIGlzIG5vdCBuZWNlc3NhcnksXG4gKiBidXQgd2l0aG91dCBhbiBlc3RpbWF0ZSB0aGUgdmlydHVhbCBzY3JvbGwgd2lsbCBub3QgcmVuZGVyIGNvcnJlY3RseS5cbiAqXG4gKiBUaGUgYXBwcm94aW1hdGUgd2lkdGggYW5kIGhlaWdodCBvZiBlYWNoIHRlbXBsYXRlIGlzIHVzZWQgdG8gaGVscFxuICogZGV0ZXJtaW5lIGhvdyBtYW55IGNlbGxzIHNob3VsZCBiZSBjcmVhdGVkLCBhbmQgdG8gaGVscCBjYWxjdWxhdGVcbiAqIHRoZSBoZWlnaHQgb2YgdGhlIHNjcm9sbGFibGUgYXJlYS4gTm90ZSB0aGF0IHRoZSBhY3R1YWwgcmVuZGVyZWQgc2l6ZVxuICogb2YgZWFjaCBjZWxsIGNvbWVzIGZyb20gdGhlIGFwcCdzIENTUywgd2hlcmVhcyB0aGlzIGFwcHJveGltYXRpb25cbiAqIGlzIG9ubHkgdXNlZCB0byBoZWxwIGNhbGN1bGF0ZSBpbml0aWFsIGRpbWVuc2lvbnMuXG4gKlxuICogSXQncyBhbHNvIGltcG9ydGFudCB0byBrbm93IHRoYXQgSW9uaWMncyBkZWZhdWx0IGl0ZW0gc2l6ZXMgaGF2ZVxuICogc2xpZ2h0bHkgZGlmZmVyZW50IGhlaWdodHMgYmV0d2VlbiBwbGF0Zm9ybXMsIHdoaWNoIGlzIHBlcmZlY3RseSBmaW5lLlxuICpcbiAqXG4gKiAjIyMgSW1hZ2VzIFdpdGhpbiBWaXJ0dWFsIFNjcm9sbFxuICpcbiAqIEhUVFAgcmVxdWVzdHMsIGltYWdlIGRlY29kaW5nLCBhbmQgaW1hZ2UgcmVuZGVyaW5nIGNhbiBjYXVzZSBqYW5rIHdoaWxlXG4gKiBzY3JvbGxpbmcuIEluIG9yZGVyIHRvIGJldHRlciBjb250cm9sIGltYWdlcywgSW9uaWMgcHJvdmlkZXMgYDxpb24taW1nPmBcbiAqIHRvIG1hbmFnZSBIVFRQIHJlcXVlc3RzIGFuZCBpbWFnZSByZW5kZXJpbmcuIFdoaWxlIHNjcm9sbGluZyB0aHJvdWdoIGl0ZW1zXG4gKiBxdWlja2x5LCBgPGlvbi1pbWc+YCBrbm93cyB3aGVuIGFuZCB3aGVuIG5vdCB0byBtYWtlIHJlcXVlc3RzLCB3aGVuIGFuZFxuICogd2hlbiBub3QgdG8gcmVuZGVyIGltYWdlcywgYW5kIG9ubHkgbG9hZHMgdGhlIGltYWdlcyB0aGF0IGFyZSB2aWV3YWJsZVxuICogYWZ0ZXIgc2Nyb2xsaW5nLiBbUmVhZCBtb3JlIGFib3V0IGBpb24taW1nYC5dKC4uLy4uL2ltZy9JbWcvKVxuICpcbiAqIEl0J3MgYWxzbyBpbXBvcnRhbnQgZm9yIGFwcCBkZXZlbG9wZXJzIHRvIGVuc3VyZSBpbWFnZSBzaXplcyBhcmUgbG9ja2VkIGluLFxuICogYW5kIGFmdGVyIGltYWdlcyBoYXZlIGZ1bGx5IGxvYWRlZCB0aGV5IGRvIG5vdCBjaGFuZ2Ugc2l6ZSBhbmQgYWZmZWN0IGFueVxuICogb3RoZXIgZWxlbWVudCBzaXplcy4gU2ltcGx5IHB1dCwgdG8gZW5zdXJlIHJlbmRlcmluZyBidWdzIGFyZSBub3QgaW50cm9kdWNlZCxcbiAqIGl0J3Mgdml0YWwgdGhhdCBlbGVtZW50cyB3aXRoaW4gYSB2aXJ0dWFsIGl0ZW0gZG9lcyBub3QgZHluYW1pY2FsbHkgY2hhbmdlLlxuICpcbiAqIEZvciB2aXJ0dWFsIHNjcm9sbGluZywgdGhlIG5hdHVyYWwgZWZmZWN0cyBvZiB0aGUgYDxpbWc+YCBhcmUgbm90IGRlc2lyYWJsZVxuICogZmVhdHVyZXMuIFdlIHJlY29tbWVuZCB1c2luZyB0aGUgYDxpb24taW1nPmAgY29tcG9uZW50IG92ZXIgdGhlIG5hdGl2ZVxuICogYDxpbWc+YCBlbGVtZW50IGJlY2F1c2Ugd2hlbiBhbiBgPGltZz5gIGVsZW1lbnQgaXMgYWRkZWQgdG8gdGhlIERPTSwgaXRcbiAqIGltbWVkaWF0ZWx5IG1ha2VzIGEgSFRUUCByZXF1ZXN0IGZvciB0aGUgaW1hZ2UgZmlsZS4gQWRkaXRpb25hbGx5LCBgPGltZz5gXG4gKiByZW5kZXJzIHdoZW5ldmVyIGl0IHdhbnRzIHdoaWNoIGNvdWxkIGJlIHdoaWxlIHRoZSB1c2VyIGlzIHNjcm9sbGluZy4gSG93ZXZlcixcbiAqIGA8aW9uLWltZz5gIGlzIGdvdmVybmVkIGJ5IHRoZSBjb250YWluaW5nIGBpb24tY29udGVudGAgYW5kIGRvZXMgbm90IHJlbmRlclxuICogaW1hZ2VzIHdoaWxlIHNjcm9sbGluZyBxdWlja2x5LlxuICpcbiAqIGBgYGh0bWxcbiAqIDxpb24tbGlzdCBbdmlydHVhbFNjcm9sbF09XCJpdGVtc1wiPlxuICpcbiAqICAgPGlvbi1pdGVtICp2aXJ0dWFsSXRlbT1cImxldCBpdGVtXCI+XG4gKiAgICAgPGlvbi1hdmF0YXIgaXRlbS1zdGFydD5cbiAqICAgICAgIDxpb24taW1nIFtzcmNdPVwiaXRlbS5hdmF0YXJVcmxcIj48L2lvbi1pbWc+XG4gKiAgICAgPC9pb24tYXZhdGFyPlxuICogICAgeyUgcmF3ICV9IHt7IGl0ZW0uZmlyc3ROYW1lIH19IHt7IGl0ZW0ubGFzdE5hbWUgfX17JSBlbmRyYXcgJX1cbiAqICAgPC9pb24taXRlbT5cbiAqXG4gKiA8L2lvbi1saXN0PlxuICogYGBgXG4gKlxuICpcbiAqICMjIyBDdXN0b20gQ29tcG9uZW50c1xuICpcbiAqIElmIGEgY3VzdG9tIGNvbXBvbmVudCBpcyBnb2luZyB0byBiZSB1c2VkIHdpdGhpbiBWaXJ0dWFsIFNjcm9sbCwgaXQncyBiZXN0XG4gKiB0byB3cmFwIGl0IHdpdGggYSBnb29kIG9sZCBgPGRpdj5gIHRvIGVuc3VyZSB0aGUgY29tcG9uZW50IGlzIHJlbmRlcmVkXG4gKiBjb3JyZWN0bHkuIFNpbmNlIGVhY2ggY3VzdG9tIGNvbXBvbmVudCdzIGltcGxlbWVudGF0aW9uIGFuZCBpbnRlcm5hbHMgY2FuIGJlXG4gKiBxdWl0ZSBkaWZmZXJlbnQsIHdyYXBwaW5nIHdpdGhpbiBhIGA8ZGl2PmAgaXMgYSBzYWZlIHdheSB0byBtYWtlIHN1cmVcbiAqIGRpbWVuc2lvbnMgYXJlIG1lYXN1cmVkIGNvcnJlY3RseS5cbiAqXG4gKiBgYGBodG1sXG4gKiA8aW9uLWxpc3QgW3ZpcnR1YWxTY3JvbGxdPVwiaXRlbXNcIj5cbiAqXG4gKiAgIDxkaXYgKnZpcnR1YWxJdGVtPVwibGV0IGl0ZW1cIj5cbiAqICAgICA8bXktY3VzdG9tLWl0ZW0gW2l0ZW1dPVwiaXRlbVwiPlxuICogICAgICAgeyUgcmF3ICV9IHt7IGl0ZW0gfX17JSBlbmRyYXcgJX1cbiAqICAgICA8L215LWN1c3RvbS1pdGVtPlxuICogICA8L2Rpdj5cbiAqXG4gKiA8L2lvbi1saXN0PlxuICogYGBgXG4gKlxuICpcbiAqICMjIFZpcnR1YWwgU2Nyb2xsIFBlcmZvcm1hbmNlIFRpcHNcbiAqXG4gKiAjIyMjIGlPUyBDb3Jkb3ZhIFdLV2ViVmlld1xuICpcbiAqIFdoZW4gZGVwbG95aW5nIHRvIGlPUyB3aXRoIENvcmRvdmEsIGl0J3MgaGlnaGx5IHJlY29tbWVuZGVkIHRvIHVzZSB0aGVcbiAqIFtXS1dlYlZpZXcgcGx1Z2luXShodHRwOi8vYmxvZy5pb25pYy5pby9jb3Jkb3ZhLWlvcy1wZXJmb3JtYW5jZS1pbXByb3ZlbWVudHMtZHJvcC1pbi1zcGVlZC13aXRoLXdrd2Vidmlldy8pXG4gKiBpbiBvcmRlciB0byB0YWtlIGFkdmFudGFnZSBvZiBpT1MncyBoaWdoZXIgcGVyZm9ybWltZyB3ZWJ2aWV3LiBBZGRpdGlvbmFsbHksXG4gKiBXS1dlYlZpZXcgaXMgc3VwZXJpb3IgYXQgc2Nyb2xsaW5nIGVmZmljaWVudGx5IGluIGNvbXBhcmlzaW9uIHRvIHRoZSBvbGRlclxuICogVUlXZWJWaWV3LlxuICpcbiAqICMjIyMgTG9jayBpbiBlbGVtZW50IGRpbWVuc2lvbnMgYW5kIGxvY2F0aW9uc1xuICpcbiAqIEluIG9yZGVyIGZvciB2aXJ0dWFsIHNjcm9sbCB0byBlZmZpY2llbnRseSBzaXplIGFuZCBsb2NhdGUgZXZlcnkgaXRlbSwgaXQnc1xuICogdmVyeSBpbXBvcnRhbnQgZXZlcnkgZWxlbWVudCB3aXRoaW4gZWFjaCB2aXJ0dWFsIGl0ZW0gZG9lcyBub3QgZHluYW1pY2FsbHlcbiAqIGNoYW5nZSBpdHMgZGltZW5zaW9ucyBvciBsb2NhdGlvbi4gVGhlIGJlc3Qgd2F5IHRvIGVuc3VyZSBzaXplIGFuZCBsb2NhdGlvblxuICogZG9lcyBub3QgY2hhbmdlLCBpdCdzIHJlY29tbWVuZGVkIGVhY2ggdmlydHVhbCBpdGVtIGhhcyBsb2NrZWQgaW4gaXRzIHNpemVcbiAqIHZpYSBDU1MuXG4gKlxuICogIyMjIyBVc2UgYGlvbi1pbWdgIGZvciBpbWFnZXNcbiAqXG4gKiBXaGVuIGluY2x1ZGluZyBpbWFnZXMgd2l0aGluIFZpcnR1YWwgU2Nyb2xsLCBiZSBzdXJlIHRvIHVzZVxuICogW2Bpb24taW1nYF0oLi4vaW1nL0ltZy8pIHJhdGhlciB0aGFuIHRoZSBzdGFuZGFyZCBgPGltZz5gIEhUTUwgZWxlbWVudC5cbiAqIFdpdGggYGlvbi1pbWdgLCBpbWFnZXMgYXJlIGxhenkgbG9hZGVkIHNvIG9ubHkgdGhlIHZpZXdhYmxlIG9uZXMgYXJlXG4gKiByZW5kZXJlZCwgYW5kIEhUVFAgcmVxdWVzdHMgYXJlIGVmZmljaWVudGx5IGNvbnRyb2xsZWQgd2hpbGUgc2Nyb2xsaW5nLlxuICpcbiAqICMjIyMgU2V0IEFwcHJveGltYXRlIFdpZHRocyBhbmQgSGVpZ2h0c1xuICpcbiAqIEFzIG1lbnRpb25lZCBhYm92ZSwgYWxsIGVsZW1lbnRzIHNob3VsZCBsb2NrIGluIHRoZWlyIGRpbWVuc2lvbnMuIEhvd2V2ZXIsXG4gKiB2aXJ0dWFsIHNjcm9sbCBpc24ndCBhd2FyZSBvZiB0aGUgZGltZW5zaW9ucyB1bnRpbCBhZnRlciB0aGV5IGhhdmUgYmVlblxuICogcmVuZGVyZWQuIEZvciB0aGUgaW5pdGlhbCByZW5kZXIsIHZpcnR1YWwgc2Nyb2xsIHN0aWxsIG5lZWRzIHRvIHNldFxuICogaG93IG1hbnkgaXRlbXMgc2hvdWxkIGJlIGJ1aWx0LiBXaXRoIFwiYXBwcm94XCIgcHJvcGVydHkgaW5wdXRzLCBzdWNoIGFzXG4gKiBgYXBwcm94SXRlbUhlaWdodGAsIHdlJ3JlIGFibGUgdG8gZ2l2ZSB2aXJ0dWFsIHNjcm9sbCBhbiBhcHByb3hpbWF0ZSBzaXplLFxuICogdGhlcmVmb3JlIGFsbG93aW5nIHZpcnR1YWwgc2Nyb2xsIHRvIGRlY2lkZSBob3cgbWFueSBpdGVtcyBzaG91bGQgYmVcbiAqIGNyZWF0ZWQuXG4gKlxuICogIyMjIyBDaGFuZ2luZyBkYXRhc2V0IHNob3VsZCB1c2UgYHZpcnR1YWxUcmFja0J5YFxuICpcbiAqIEl0IGlzIHBvc3NpYmxlIGZvciB0aGUgaWRlbnRpdGllcyBvZiBlbGVtZW50cyBpbiB0aGUgaXRlcmF0b3IgdG8gY2hhbmdlXG4gKiB3aGlsZSB0aGUgZGF0YSBkb2VzIG5vdC4gVGhpcyBjYW4gaGFwcGVuLCBmb3IgZXhhbXBsZSwgaWYgdGhlIGl0ZXJhdG9yXG4gKiBwcm9kdWNlZCBmcm9tIGFuIFJQQyB0byB0aGUgc2VydmVyLCBhbmQgdGhhdCBSUEMgaXMgcmUtcnVuLiBFdmVuIGlmIHRoZVxuICogXCJkYXRhXCIgaGFzbid0IGNoYW5nZWQsIHRoZSBzZWNvbmQgcmVzcG9uc2Ugd2lsbCBwcm9kdWNlIG9iamVjdHMgd2l0aFxuICogZGlmZmVyZW50IGlkZW50aXRpZXMsIGFuZCBJb25pYyB3aWxsIHRlYXIgZG93biB0aGUgZW50aXJlIERPTSBhbmQgcmVidWlsZFxuICogaXQuIFRoaXMgaXMgYW4gZXhwZW5zaXZlIG9wZXJhdGlvbiBhbmQgc2hvdWxkIGJlIGF2b2lkZWQgaWYgcG9zc2libGUuXG4gKlxuICogIyMjIyBFZmZpY2llbnQgaGVhZGVycyBhbmQgZm9vdGVyIGZ1bmN0aW9uc1xuICpcbiAqIEVhY2ggdmlydHVhbCBpdGVtIG11c3Qgc3RheSBleHRyZW1lbHkgZWZmaWNpZW50LCBidXQgb25lIHdheSB0byByZWFsbHlcbiAqIGtpbGwgaXRzIHBlcmZvcm1hbmNlIGlzIHRvIHBlcmZvcm0gYW55IERPTSBvcGVyYXRpb25zIHdpdGhpbiBzZWN0aW9uIGhlYWRlclxuICogYW5kIGZvb3RlciBmdW5jdGlvbnMuIFRoZXNlIGZ1bmN0aW9ucyBhcmUgY2FsbGVkIGZvciBldmVyeSByZWNvcmQgaW4gdGhlXG4gKiBkYXRhc2V0LCBzbyBwbGVhc2UgbWFrZSBzdXJlIHRoZXkncmUgcGVyZm9ybWFudC5cbiAqXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIFZpcnR1YWxTY3JvbGwgaW1wbGVtZW50cyBEb0NoZWNrLCBPbkNoYW5nZXMsIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG4gICAgcHJpdmF0ZSBfaXRlcmFibGVEaWZmZXJzO1xuICAgIHByaXZhdGUgX2VsZW1lbnRSZWY7XG4gICAgcHJpdmF0ZSBfcmVuZGVyZXI7XG4gICAgcHJpdmF0ZSBfem9uZTtcbiAgICBwcml2YXRlIF9jZDtcbiAgICBwcml2YXRlIF9jb250ZW50O1xuICAgIHByaXZhdGUgX3BsdDtcbiAgICBwcml2YXRlIF9jdHJsO1xuICAgIHByaXZhdGUgX2NvbmZpZztcbiAgICBwcml2YXRlIF9kb207XG4gICAgX2RpZmZlcjogSXRlcmFibGVEaWZmZXI8YW55PjtcbiAgICBfc2Nyb2xsU3ViOiBhbnk7XG4gICAgX3Njcm9sbEVuZFN1YjogYW55O1xuICAgIF9yZXNpemVTdWI6IGFueTtcbiAgICBfaW5pdDogYm9vbGVhbjtcbiAgICBfbGFzdEVsZTogYm9vbGVhbjtcbiAgICBfaGRyRm46IEZ1bmN0aW9uO1xuICAgIF9mdHJGbjogRnVuY3Rpb247XG4gICAgX3JlY29yZHM6IGFueVtdO1xuICAgIF9jZWxsczogVmlydHVhbENlbGxbXTtcbiAgICBfbm9kZXM6IFZpcnR1YWxOb2RlW107XG4gICAgX3ZIZWlnaHQ6IG51bWJlcjtcbiAgICBfbGFzdENoZWNrOiBudW1iZXI7XG4gICAgX3JlY29yZFNpemU6IG51bWJlcjtcbiAgICBfZGF0YTogVmlydHVhbERhdGE7XG4gICAgX3F1ZXVlOiBudW1iZXI7XG4gICAgX2l0bVRtcDogVmlydHVhbEl0ZW07XG4gICAgX2hkclRtcDogVmlydHVhbEhlYWRlcjtcbiAgICBfZnRyVG1wOiBWaXJ0dWFsRm9vdGVyO1xuICAgIC8qKlxuICAgICAqIEBpbnB1dCB7YXJyYXl9IFRoZSBkYXRhIHRoYXQgYnVpbGRzIHRoZSB0ZW1wbGF0ZXMgd2l0aGluIHRoZSB2aXJ0dWFsIHNjcm9sbC5cbiAgICAgKiBUaGlzIGlzIHRoZSBzYW1lIGRhdGEgdGhhdCB5b3UnZCBwYXNzIHRvIGAqbmdGb3JgLiBJdCdzIGltcG9ydGFudCB0byBub3RlXG4gICAgICogdGhhdCB3aGVuIHRoaXMgZGF0YSBoYXMgY2hhbmdlZCwgdGhlbiB0aGUgZW50aXJlIHZpcnR1YWwgc2Nyb2xsIGlzIHJlc2V0LFxuICAgICAqIHdoaWNoIGlzIGFuIGV4cGVuc2l2ZSBvcGVyYXRpb24gYW5kIHNob3VsZCBiZSBhdm9pZGVkIGlmIHBvc3NpYmxlLlxuICAgICAqL1xuICAgIHZpcnR1YWxTY3JvbGw6IGFueTtcbiAgICAvKipcbiAgICAgKiBAaW5wdXQge251bWJlcn0gVGhlIGJ1ZmZlciByYXRpbyBpcyB1c2VkIHRvIGRlY2lkZSBob3cgbWFueSBjZWxsc1xuICAgICAqIHNob3VsZCBnZXQgY3JlYXRlZCB3aGVuIGluaXRpYWxseSByZW5kZXJlZC4gVGhlIG51bWJlciBpcyBhXG4gICAgICogbXVsdGlwbGllciBhZ2FpbnN0IHRoZSB2aWV3YWJsZSBhcmVhJ3MgaGVpZ2h0LiBGb3IgZXhhbXBsZSwgaWYgaXRcbiAgICAgKiB0YWtlcyBgMjBgIGNlbGxzIHRvIGZpbGwgdXAgdGhlIGhlaWdodCBvZiB0aGUgdmlld2FibGUgYXJlYSwgdGhlblxuICAgICAqIHdpdGggYSBidWZmZXIgcmF0aW8gb2YgYDNgIGl0IHdpbGwgY3JlYXRlIGA2MGAgY2VsbHMgdGhhdCBhcmVcbiAgICAgKiBhdmFpbGFibGUgZm9yIHJldXNlIHdoaWxlIHNjcm9sbGluZy4gRm9yIGJldHRlciBwZXJmb3JtYW5jZSwgaXQnc1xuICAgICAqIGJldHRlciB0byBoYXZlIG1vcmUgY2VsbHMgdGhhbiB3aGF0IGFyZSByZXF1aXJlZCB0byBmaWxsIHRoZVxuICAgICAqIHZpZXdhYmxlIGFyZWEuIERlZmF1bHQgaXMgYDNgLlxuICAgICAqIEluIGNhc2UgbW9yZSB0aGFuIG9uZSBpdGVtcyBhcmUgcmVuZGVyZWQgcGVyIHJvdywgYnVmZmVyUmF0aW9cbiAgICAgKiBoYXMgdG8gYWNjb3VudCBmb3IgdGhhdCBhbmQgYSBtdWx0aXBsZSBudW1iZXIgc2hvdWxkIGJlIHVzZWQuXG4gICAgICogRm9yIGV4YW1wbGUgaWYgYSBzaW5nbGUgaXRlbSBwZXIgcm93IGxpc3QgdXNlZCAzIGFzIGJ1ZmZlclJhdGlvXG4gICAgICogYSA0IGl0ZW0gcGVyIHJvdyBsaXN0IHNob3VsZCB1c2UgMyAqIDQgPSAxMiBhcyBidWZmZXIgcmF0aW8uXG4gICAgICovXG4gICAgYnVmZmVyUmF0aW86IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBAaW5wdXQge3N0cmluZ30gVGhlIGFwcHJveGltYXRlIHdpZHRoIG9mIGVhY2ggaXRlbSB0ZW1wbGF0ZSdzIGNlbGwuXG4gICAgICogVGhpcyBkaW1lbnNpb24gaXMgdXNlZCB0byBoZWxwIGRldGVybWluZSBob3cgbWFueSBjZWxscyBzaG91bGRcbiAgICAgKiBiZSBjcmVhdGVkIHdoZW4gaW5pdGlhbGl6ZWQsIGFuZCB0byBoZWxwIGNhbGN1bGF0ZSB0aGUgaGVpZ2h0IG9mXG4gICAgICogdGhlIHNjcm9sbGFibGUgYXJlYS4gVGhpcyB2YWx1ZSBjYW4gdXNlIGVpdGhlciBgcHhgIG9yIGAlYCB1bml0cy5cbiAgICAgKiBOb3RlIHRoYXQgdGhlIGFjdHVhbCByZW5kZXJlZCBzaXplIG9mIGVhY2ggY2VsbCBjb21lcyBmcm9tIHRoZVxuICAgICAqIGFwcCdzIENTUywgd2hlcmVhcyB0aGlzIGFwcHJveGltYXRpb24gaXMgdXNlZCB0byBoZWxwIGNhbGN1bGF0ZVxuICAgICAqIGluaXRpYWwgZGltZW5zaW9ucyBiZWZvcmUgdGhlIGl0ZW0gaGFzIGJlZW4gcmVuZGVyZWQuIERlZmF1bHQgaXNcbiAgICAgKiBgMTAwJWAuXG4gICAgICovXG4gICAgYXBwcm94SXRlbVdpZHRoOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQGlucHV0IHtzdHJpbmd9IEl0IGlzIGltcG9ydGFudCB0byBwcm92aWRlIHRoaXNcbiAgICAgKiBpZiB2aXJ0dWFsIGl0ZW0gaGVpZ2h0IHdpbGwgYmUgc2lnbmlmaWNhbnRseSBsYXJnZXIgdGhhbiB0aGUgZGVmYXVsdFxuICAgICAqIFRoZSBhcHByb3hpbWF0ZSBoZWlnaHQgb2YgZWFjaCB2aXJ0dWFsIGl0ZW0gdGVtcGxhdGUncyBjZWxsLlxuICAgICAqIFRoaXMgZGltZW5zaW9uIGlzIHVzZWQgdG8gaGVscCBkZXRlcm1pbmUgaG93IG1hbnkgY2VsbHMgc2hvdWxkXG4gICAgICogYmUgY3JlYXRlZCB3aGVuIGluaXRpYWxpemVkLCBhbmQgdG8gaGVscCBjYWxjdWxhdGUgdGhlIGhlaWdodCBvZlxuICAgICAqIHRoZSBzY3JvbGxhYmxlIGFyZWEuIFRoaXMgaGVpZ2h0IHZhbHVlIGNhbiBvbmx5IHVzZSBgcHhgIHVuaXRzLlxuICAgICAqIE5vdGUgdGhhdCB0aGUgYWN0dWFsIHJlbmRlcmVkIHNpemUgb2YgZWFjaCBjZWxsIGNvbWVzIGZyb20gdGhlXG4gICAgICogYXBwJ3MgQ1NTLCB3aGVyZWFzIHRoaXMgYXBwcm94aW1hdGlvbiBpcyB1c2VkIHRvIGhlbHAgY2FsY3VsYXRlXG4gICAgICogaW5pdGlhbCBkaW1lbnNpb25zIGJlZm9yZSB0aGUgaXRlbSBoYXMgYmVlbiByZW5kZXJlZC4gRGVmYXVsdCBpc1xuICAgICAqIGA0MHB4YC5cbiAgICAgKi9cbiAgICBhcHByb3hJdGVtSGVpZ2h0OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQGlucHV0IHtzdHJpbmd9IFRoZSBhcHByb3hpbWF0ZSB3aWR0aCBvZiBlYWNoIGhlYWRlciB0ZW1wbGF0ZSdzIGNlbGwuXG4gICAgICogVGhpcyBkaW1lbnNpb24gaXMgdXNlZCB0byBoZWxwIGRldGVybWluZSBob3cgbWFueSBjZWxscyBzaG91bGRcbiAgICAgKiBiZSBjcmVhdGVkIHdoZW4gaW5pdGlhbGl6ZWQsIGFuZCB0byBoZWxwIGNhbGN1bGF0ZSB0aGUgaGVpZ2h0IG9mXG4gICAgICogdGhlIHNjcm9sbGFibGUgYXJlYS4gVGhpcyB2YWx1ZSBjYW4gdXNlIGVpdGhlciBgcHhgIG9yIGAlYCB1bml0cy5cbiAgICAgKiBOb3RlIHRoYXQgdGhlIGFjdHVhbCByZW5kZXJlZCBzaXplIG9mIGVhY2ggY2VsbCBjb21lcyBmcm9tIHRoZVxuICAgICAqIGFwcCdzIENTUywgd2hlcmVhcyB0aGlzIGFwcHJveGltYXRpb24gaXMgdXNlZCB0byBoZWxwIGNhbGN1bGF0ZVxuICAgICAqIGluaXRpYWwgZGltZW5zaW9ucy4gRGVmYXVsdCBpcyBgMTAwJWAuXG4gICAgICovXG4gICAgYXBwcm94SGVhZGVyV2lkdGg6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBAaW5wdXQge3N0cmluZ30gVGhlIGFwcHJveGltYXRlIGhlaWdodCBvZiBlYWNoIGhlYWRlciB0ZW1wbGF0ZSdzIGNlbGwuXG4gICAgICogVGhpcyBkaW1lbnNpb24gaXMgdXNlZCB0byBoZWxwIGRldGVybWluZSBob3cgbWFueSBjZWxscyBzaG91bGRcbiAgICAgKiBiZSBjcmVhdGVkIHdoZW4gaW5pdGlhbGl6ZWQsIGFuZCB0byBoZWxwIGNhbGN1bGF0ZSB0aGUgaGVpZ2h0IG9mXG4gICAgICogdGhlIHNjcm9sbGFibGUgYXJlYS4gVGhpcyBoZWlnaHQgdmFsdWUgY2FuIG9ubHkgdXNlIGBweGAgdW5pdHMuXG4gICAgICogTm90ZSB0aGF0IHRoZSBhY3R1YWwgcmVuZGVyZWQgc2l6ZSBvZiBlYWNoIGNlbGwgY29tZXMgZnJvbSB0aGVcbiAgICAgKiBhcHAncyBDU1MsIHdoZXJlYXMgdGhpcyBhcHByb3hpbWF0aW9uIGlzIHVzZWQgdG8gaGVscCBjYWxjdWxhdGVcbiAgICAgKiBpbml0aWFsIGRpbWVuc2lvbnMgYmVmb3JlIHRoZSBpdGVtIGhhcyBiZWVuIHJlbmRlcmVkLiBEZWZhdWx0IGlzIGA0MHB4YC5cbiAgICAgKi9cbiAgICBhcHByb3hIZWFkZXJIZWlnaHQ6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBAaW5wdXQge3N0cmluZ30gVGhlIGFwcHJveGltYXRlIHdpZHRoIG9mIGVhY2ggZm9vdGVyIHRlbXBsYXRlJ3MgY2VsbC5cbiAgICAgKiBUaGlzIGRpbWVuc2lvbiBpcyB1c2VkIHRvIGhlbHAgZGV0ZXJtaW5lIGhvdyBtYW55IGNlbGxzIHNob3VsZFxuICAgICAqIGJlIGNyZWF0ZWQgd2hlbiBpbml0aWFsaXplZCwgYW5kIHRvIGhlbHAgY2FsY3VsYXRlIHRoZSBoZWlnaHQgb2ZcbiAgICAgKiB0aGUgc2Nyb2xsYWJsZSBhcmVhLiBUaGlzIHZhbHVlIGNhbiB1c2UgZWl0aGVyIGBweGAgb3IgYCVgIHVuaXRzLlxuICAgICAqIE5vdGUgdGhhdCB0aGUgYWN0dWFsIHJlbmRlcmVkIHNpemUgb2YgZWFjaCBjZWxsIGNvbWVzIGZyb20gdGhlXG4gICAgICogYXBwJ3MgQ1NTLCB3aGVyZWFzIHRoaXMgYXBwcm94aW1hdGlvbiBpcyB1c2VkIHRvIGhlbHAgY2FsY3VsYXRlXG4gICAgICogaW5pdGlhbCBkaW1lbnNpb25zIGJlZm9yZSB0aGUgaXRlbSBoYXMgYmVlbiByZW5kZXJlZC4gRGVmYXVsdCBpcyBgMTAwJWAuXG4gICAgICovXG4gICAgYXBwcm94Rm9vdGVyV2lkdGg6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBAaW5wdXQge3N0cmluZ30gVGhlIGFwcHJveGltYXRlIGhlaWdodCBvZiBlYWNoIGZvb3RlciB0ZW1wbGF0ZSdzIGNlbGwuXG4gICAgICogVGhpcyBkaW1lbnNpb24gaXMgdXNlZCB0byBoZWxwIGRldGVybWluZSBob3cgbWFueSBjZWxscyBzaG91bGRcbiAgICAgKiBiZSBjcmVhdGVkIHdoZW4gaW5pdGlhbGl6ZWQsIGFuZCB0byBoZWxwIGNhbGN1bGF0ZSB0aGUgaGVpZ2h0IG9mXG4gICAgICogdGhlIHNjcm9sbGFibGUgYXJlYS4gVGhpcyBoZWlnaHQgdmFsdWUgY2FuIG9ubHkgdXNlIGBweGAgdW5pdHMuXG4gICAgICogTm90ZSB0aGF0IHRoZSBhY3R1YWwgcmVuZGVyZWQgc2l6ZSBvZiBlYWNoIGNlbGwgY29tZXMgZnJvbSB0aGVcbiAgICAgKiBhcHAncyBDU1MsIHdoZXJlYXMgdGhpcyBhcHByb3hpbWF0aW9uIGlzIHVzZWQgdG8gaGVscCBjYWxjdWxhdGVcbiAgICAgKiBpbml0aWFsIGRpbWVuc2lvbnMgYmVmb3JlIHRoZSBpdGVtIGhhcyBiZWVuIHJlbmRlcmVkLiBEZWZhdWx0IGlzIGA0MHB4YC5cbiAgICAgKi9cbiAgICBhcHByb3hGb290ZXJIZWlnaHQ6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBAaW5wdXQge2Z1bmN0aW9ufSBTZWN0aW9uIGhlYWRlcnMgYW5kIHRoZSBkYXRhIHVzZWQgd2l0aGluIGl0cyBnaXZlblxuICAgICAqIHRlbXBsYXRlIGNhbiBiZSBkeW5hbWljYWxseSBjcmVhdGVkIGJ5IHBhc3NpbmcgYSBmdW5jdGlvbiB0byBgaGVhZGVyRm5gLlxuICAgICAqIEZvciBleGFtcGxlLCBhIGxhcmdlIGxpc3Qgb2YgY29udGFjdHMgdXN1YWxseSBoYXMgZGl2aWRlcnMgYmV0d2VlbiBlYWNoXG4gICAgICogbGV0dGVyIGluIHRoZSBhbHBoYWJldC4gQXBwJ3MgY2FuIHByb3ZpZGUgdGhlaXIgb3duIGN1c3RvbSBgaGVhZGVyRm5gXG4gICAgICogd2hpY2ggaXMgY2FsbGVkIHdpdGggZWFjaCByZWNvcmQgd2l0aGluIHRoZSBkYXRhc2V0LiBUaGUgbG9naWMgd2l0aGluXG4gICAgICogdGhlIGhlYWRlciBmdW5jdGlvbiBjYW4gZGVjaWRlIGlmIHRoZSBoZWFkZXIgdGVtcGxhdGUgc2hvdWxkIGJlIHVzZWQsXG4gICAgICogYW5kIHdoYXQgZGF0YSB0byBnaXZlIHRvIHRoZSBoZWFkZXIgdGVtcGxhdGUuIFRoZSBmdW5jdGlvbiBtdXN0IHJldHVyblxuICAgICAqIGBudWxsYCBpZiBhIGhlYWRlciBjZWxsIHNob3VsZG4ndCBiZSBjcmVhdGVkLlxuICAgICAqL1xuICAgIGhlYWRlckZuOiBGdW5jdGlvbjtcbiAgICAvKipcbiAgICAgKiBAaW5wdXQge2Z1bmN0aW9ufSBTZWN0aW9uIGZvb3RlcnMgYW5kIHRoZSBkYXRhIHVzZWQgd2l0aGluIGl0cyBnaXZlblxuICAgICAqIHRlbXBsYXRlIGNhbiBiZSBkeW5hbWljYWxseSBjcmVhdGVkIGJ5IHBhc3NpbmcgYSBmdW5jdGlvbiB0byBgZm9vdGVyRm5gLlxuICAgICAqIFRoZSBsb2dpYyB3aXRoaW4gdGhlIGZvb3RlciBmdW5jdGlvbiBjYW4gZGVjaWRlIGlmIHRoZSBmb290ZXIgdGVtcGxhdGVcbiAgICAgKiBzaG91bGQgYmUgdXNlZCwgYW5kIHdoYXQgZGF0YSB0byBnaXZlIHRvIHRoZSBmb290ZXIgdGVtcGxhdGUuIFRoZSBmdW5jdGlvblxuICAgICAqIG11c3QgcmV0dXJuIGBudWxsYCBpZiBhIGZvb3RlciBjZWxsIHNob3VsZG4ndCBiZSBjcmVhdGVkLlxuICAgICAqL1xuICAgIGZvb3RlckZuOiBGdW5jdGlvbjtcbiAgICAvKipcbiAgICAgKiBAaW5wdXQge2Z1bmN0aW9ufSBTYW1lIGFzIGBuZ0ZvclRyYWNrQnlgIHdoaWNoIGNhbiBiZSB1c2VkIG9uIGBuZ0ZvcmAuXG4gICAgICovXG4gICAgdmlydHVhbFRyYWNrQnk6IFRyYWNrQnlGdW5jdGlvbjxhbnk+O1xuICAgIGNvbnN0cnVjdG9yKF9pdGVyYWJsZURpZmZlcnM6IEl0ZXJhYmxlRGlmZmVycywgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIF9yZW5kZXJlcjogUmVuZGVyZXIsIF96b25lOiBOZ1pvbmUsIF9jZDogQ2hhbmdlRGV0ZWN0b3JSZWYsIF9jb250ZW50OiBDb250ZW50LCBfcGx0OiBQbGF0Zm9ybSwgX2N0cmw6IFZpZXdDb250cm9sbGVyLCBfY29uZmlnOiBDb25maWcsIF9kb206IERvbUNvbnRyb2xsZXIpO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBmaXJzdFJlY29yZCgpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGxhc3RSZWNvcmQoKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICovXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nRG9DaGVjaygpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWFkVXBkYXRlKG5lZWRDbGVhbjogYm9vbGVhbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHdyaXRlVXBkYXRlKG5lZWRDbGVhbjogYm9vbGVhbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByaXZhdGUgY2FsY0RpbWVuc2lvbnMoKTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogRE9NIFdSSVRFXG4gICAgICovXG4gICAgcmVuZGVyVmlydHVhbChuZWVkQ2xlYW46IGJvb2xlYW4pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZXNpemUoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJpdmF0ZSBfc3RlcERPTVdyaXRlKCk7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByaXZhdGUgX3N0ZXBDaGFuZ2VEZXRlY3Rpb24oKTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJpdmF0ZSBfc3RlcE5vQ2hhbmdlcygpO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzY3JvbGxVcGRhdGUoZXY6IFNjcm9sbEV2ZW50KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogRE9NIFdSSVRFXG4gICAgICovXG4gICAgc2Nyb2xsRW5kKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIE5PIERPTVxuICAgICAqL1xuICAgIHByaXZhdGUgX2xpc3RlbmVycygpO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBET00gV1JJVEVcbiAgICAgKi9cbiAgICBwcml2YXRlIF9zZXRIZWlnaHQobmV3VmlydHVhbEhlaWdodCk7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXRFbGVtZW50Q2xhc3MoY2xhc3NOYW1lOiBzdHJpbmcsIGFkZDogYm9vbGVhbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG59XG4iXX0=