import { ElementRef, EventEmitter, NgZone, QueryList, Renderer } from '@angular/core';
import { Item } from './item';
import { List } from '../list/list';
import { Platform } from '../../platform/platform';
import { ItemOptions } from './item-options';
/**
 * @name ItemSliding
 * @description
 * A sliding item is a list item that can be swiped to reveal buttons. It requires
 * an [Item](../Item) component as a child and a [List](../../list/List) component as
 * a parent. All buttons to reveal can be placed in the `<ion-item-options>` element.
 *
 * @usage
 * ```html
 * <ion-list>
 *   <ion-item-sliding #item>
 *     <ion-item>
 *       Item
 *     </ion-item>
 *     <ion-item-options side="left">
 *       <button ion-button (click)="favorite(item)">Favorite</button>
 *       <button ion-button color="danger" (click)="share(item)">Share</button>
 *     </ion-item-options>
 *
 *     <ion-item-options side="right">
 *       <button ion-button (click)="unread(item)">Unread</button>
 *     </ion-item-options>
 *   </ion-item-sliding>
 * </ion-list>
 * ```
 *
 * ### Swipe Direction
 * By default, the buttons are revealed when the sliding item is swiped from right to left,
 * so the buttons are placed in the right side. But it's also possible to reveal them
 * in the right side (sliding from left to right) by setting the `side` attribute
 * on the `ion-item-options` element. Up to 2 `ion-item-options` can used at the same time
 * in order to reveal two different sets of buttons depending the swipping direction.
 *
 * ```html
 * <ion-item-options side="right">
 *   <button ion-button (click)="archive(item)">
 *     <ion-icon name="archive"></ion-icon>
 *     Archive
 *   </button>
 * </ion-item-options>
 *
 * <ion-item-options side="left">
 *   <button ion-button (click)="archive(item)">
 *     <ion-icon name="archive"></ion-icon>
 *     Archive
 *   </button>
 * </ion-item-options>
 * ```
 *
 * ### Listening for events (ionDrag) and (ionSwipe)
 * It's possible to know the current relative position of the sliding item by subscribing
 * to the (ionDrag)` event.
 *
 * ```html
 * <ion-item-sliding (ionDrag)="logDrag($event)">
 *   <ion-item>Item</ion-item>
 *   <ion-item-options>
 *     <button ion-button>Favorite</button>
 *   </ion-item-options>
 * </ion-item-sliding>
 * ```
 *
 * ### Button Layout
 * If an icon is placed with text in the option button, by default it will
 * display the icon on top of the text. This can be changed to display the icon
 * to the left of the text by setting `icon-start` as an attribute on the
 * `<ion-item-options>` element.
 *
 * ```html
 * <ion-item-options icon-start>
 *    <button ion-button (click)="archive(item)">
 *      <ion-icon name="archive"></ion-icon>
 *      Archive
 *    </button>
 *  </ion-item-options>
 *
 * ```
 *
 * ### Expandable Options
 *
 * Options can be expanded to take up the full width of the item if you swipe past
 * a certain point. This can be combined with the `ionSwipe` event to call methods
 * on the class.
 *
 * ```html
 *
 * <ion-item-sliding>
 *   <ion-item>Item</ion-item>
 *   <ion-item-options (ionSwipe)="delete(item)">
 *     <button ion-button expandable (click)="delete(item)">Delete</button>
 *   </ion-item-options>
 * </ion-item-sliding>
 * ```
 *
 * We can call `delete` by either clicking the button, or by doing a full swipe on the item.
 *
 * @demo /docs/demos/src/item-sliding/
 * @see {@link /docs/components#lists List Component Docs}
 * @see {@link ../Item Item API Docs}
 * @see {@link ../../list/List List API Docs}
 */
import * as ɵngcc0 from '@angular/core';
export declare class ItemSliding {
    private _plt;
    private _renderer;
    private _elementRef;
    private _zone;
    private _openAmount;
    private _startX;
    private _optsWidthRightSide;
    private _optsWidthLeftSide;
    private _sides;
    private _tmr;
    private _leftOptions;
    private _rightOptions;
    private _optsDirty;
    private _state;
    /**
     * @hidden
     */
    item: Item;
    /**
     * @output {event} Emitted when the sliding position changes.
     * It reports the relative position.
     *
     * ```ts
     * ondrag(item) {
     *   let percent = item.getSlidingPercent();
     *   if (percent > 0) {
     *     // positive
     *     console.log('right side');
     *   } else {
     *     // negative
     *     console.log('left side');
     *   }
     *   if (Math.abs(percent) > 1) {
     *     console.log('overscroll');
     *   }
     * }
     * ```
     *
     */
    ionDrag: EventEmitter<ItemSliding>;
    constructor(list: List, _plt: Platform, _renderer: Renderer, _elementRef: ElementRef, _zone: NgZone);
    _itemOptions: QueryList<ItemOptions>;
    /**
     * @hidden
     */
    getOpenAmount(): number;
    /**
     * @hidden
     */
    getSlidingPercent(): number;
    /**
     * @hidden
     */
    startSliding(startX: number): void;
    /**
     * @hidden
     */
    moveSliding(x: number): number;
    /**
     * @hidden
     */
    endSliding(velocity: number): number;
    /**
     * @hidden
     */
    private fireSwipeEvent();
    /**
     * @hidden
     */
    private calculateOptsWidth();
    private _setOpenAmount(openAmount, isFinal);
    private _setState(state);
    /**
     * Close the sliding item. Items can also be closed from the [List](../../list/List).
     *
     * The sliding item can be closed by grabbing a reference to `ItemSliding`. In the
     * below example, the template reference variable `slidingItem` is placed on the element
     * and passed to the `share` method.
     *
     * ```html
     * <ion-list>
     *   <ion-item-sliding #slidingItem>
     *     <ion-item>
     *       Item
     *     </ion-item>
     *     <ion-item-options>
     *       <button ion-button (click)="share(slidingItem)">Share</button>
     *     </ion-item-options>
     *   </ion-item-sliding>
     * </ion-list>
     * ```
     *
     * ```ts
     * import { Component } from '@angular/core';
     * import { ItemSliding } from 'ionic-angular';
     *
     * @Component({...})
     * export class MyClass {
     *   constructor() { }
     *
     *   share(slidingItem: ItemSliding) {
     *     slidingItem.close();
     *   }
     * }
     * ```
     */
    close(): void;
    /**
     * @hidden
     */
    setElementClass(cssClass: string, shouldAdd: boolean): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<ItemSliding, [{ optional: true; }, null, null, null, null]>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<ItemSliding, "ion-item-sliding", never, {}, { "ionDrag": "ionDrag"; }, ["item", "_itemOptions"], ["ion-item,[ion-item]", "ion-item-options"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaXRlbS1zbGlkaW5nLmQudHMiLCJzb3VyY2VzIjpbIml0ZW0tc2xpZGluZy5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgTmdab25lLCBRdWVyeUxpc3QsIFJlbmRlcmVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJdGVtIH0gZnJvbSAnLi9pdGVtJztcbmltcG9ydCB7IExpc3QgfSBmcm9tICcuLi9saXN0L2xpc3QnO1xuaW1wb3J0IHsgUGxhdGZvcm0gfSBmcm9tICcuLi8uLi9wbGF0Zm9ybS9wbGF0Zm9ybSc7XG5pbXBvcnQgeyBJdGVtT3B0aW9ucyB9IGZyb20gJy4vaXRlbS1vcHRpb25zJztcbi8qKlxuICogQG5hbWUgSXRlbVNsaWRpbmdcbiAqIEBkZXNjcmlwdGlvblxuICogQSBzbGlkaW5nIGl0ZW0gaXMgYSBsaXN0IGl0ZW0gdGhhdCBjYW4gYmUgc3dpcGVkIHRvIHJldmVhbCBidXR0b25zLiBJdCByZXF1aXJlc1xuICogYW4gW0l0ZW1dKC4uL0l0ZW0pIGNvbXBvbmVudCBhcyBhIGNoaWxkIGFuZCBhIFtMaXN0XSguLi8uLi9saXN0L0xpc3QpIGNvbXBvbmVudCBhc1xuICogYSBwYXJlbnQuIEFsbCBidXR0b25zIHRvIHJldmVhbCBjYW4gYmUgcGxhY2VkIGluIHRoZSBgPGlvbi1pdGVtLW9wdGlvbnM+YCBlbGVtZW50LlxuICpcbiAqIEB1c2FnZVxuICogYGBgaHRtbFxuICogPGlvbi1saXN0PlxuICogICA8aW9uLWl0ZW0tc2xpZGluZyAjaXRlbT5cbiAqICAgICA8aW9uLWl0ZW0+XG4gKiAgICAgICBJdGVtXG4gKiAgICAgPC9pb24taXRlbT5cbiAqICAgICA8aW9uLWl0ZW0tb3B0aW9ucyBzaWRlPVwibGVmdFwiPlxuICogICAgICAgPGJ1dHRvbiBpb24tYnV0dG9uIChjbGljayk9XCJmYXZvcml0ZShpdGVtKVwiPkZhdm9yaXRlPC9idXR0b24+XG4gKiAgICAgICA8YnV0dG9uIGlvbi1idXR0b24gY29sb3I9XCJkYW5nZXJcIiAoY2xpY2spPVwic2hhcmUoaXRlbSlcIj5TaGFyZTwvYnV0dG9uPlxuICogICAgIDwvaW9uLWl0ZW0tb3B0aW9ucz5cbiAqXG4gKiAgICAgPGlvbi1pdGVtLW9wdGlvbnMgc2lkZT1cInJpZ2h0XCI+XG4gKiAgICAgICA8YnV0dG9uIGlvbi1idXR0b24gKGNsaWNrKT1cInVucmVhZChpdGVtKVwiPlVucmVhZDwvYnV0dG9uPlxuICogICAgIDwvaW9uLWl0ZW0tb3B0aW9ucz5cbiAqICAgPC9pb24taXRlbS1zbGlkaW5nPlxuICogPC9pb24tbGlzdD5cbiAqIGBgYFxuICpcbiAqICMjIyBTd2lwZSBEaXJlY3Rpb25cbiAqIEJ5IGRlZmF1bHQsIHRoZSBidXR0b25zIGFyZSByZXZlYWxlZCB3aGVuIHRoZSBzbGlkaW5nIGl0ZW0gaXMgc3dpcGVkIGZyb20gcmlnaHQgdG8gbGVmdCxcbiAqIHNvIHRoZSBidXR0b25zIGFyZSBwbGFjZWQgaW4gdGhlIHJpZ2h0IHNpZGUuIEJ1dCBpdCdzIGFsc28gcG9zc2libGUgdG8gcmV2ZWFsIHRoZW1cbiAqIGluIHRoZSByaWdodCBzaWRlIChzbGlkaW5nIGZyb20gbGVmdCB0byByaWdodCkgYnkgc2V0dGluZyB0aGUgYHNpZGVgIGF0dHJpYnV0ZVxuICogb24gdGhlIGBpb24taXRlbS1vcHRpb25zYCBlbGVtZW50LiBVcCB0byAyIGBpb24taXRlbS1vcHRpb25zYCBjYW4gdXNlZCBhdCB0aGUgc2FtZSB0aW1lXG4gKiBpbiBvcmRlciB0byByZXZlYWwgdHdvIGRpZmZlcmVudCBzZXRzIG9mIGJ1dHRvbnMgZGVwZW5kaW5nIHRoZSBzd2lwcGluZyBkaXJlY3Rpb24uXG4gKlxuICogYGBgaHRtbFxuICogPGlvbi1pdGVtLW9wdGlvbnMgc2lkZT1cInJpZ2h0XCI+XG4gKiAgIDxidXR0b24gaW9uLWJ1dHRvbiAoY2xpY2spPVwiYXJjaGl2ZShpdGVtKVwiPlxuICogICAgIDxpb24taWNvbiBuYW1lPVwiYXJjaGl2ZVwiPjwvaW9uLWljb24+XG4gKiAgICAgQXJjaGl2ZVxuICogICA8L2J1dHRvbj5cbiAqIDwvaW9uLWl0ZW0tb3B0aW9ucz5cbiAqXG4gKiA8aW9uLWl0ZW0tb3B0aW9ucyBzaWRlPVwibGVmdFwiPlxuICogICA8YnV0dG9uIGlvbi1idXR0b24gKGNsaWNrKT1cImFyY2hpdmUoaXRlbSlcIj5cbiAqICAgICA8aW9uLWljb24gbmFtZT1cImFyY2hpdmVcIj48L2lvbi1pY29uPlxuICogICAgIEFyY2hpdmVcbiAqICAgPC9idXR0b24+XG4gKiA8L2lvbi1pdGVtLW9wdGlvbnM+XG4gKiBgYGBcbiAqXG4gKiAjIyMgTGlzdGVuaW5nIGZvciBldmVudHMgKGlvbkRyYWcpIGFuZCAoaW9uU3dpcGUpXG4gKiBJdCdzIHBvc3NpYmxlIHRvIGtub3cgdGhlIGN1cnJlbnQgcmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIHNsaWRpbmcgaXRlbSBieSBzdWJzY3JpYmluZ1xuICogdG8gdGhlIChpb25EcmFnKWAgZXZlbnQuXG4gKlxuICogYGBgaHRtbFxuICogPGlvbi1pdGVtLXNsaWRpbmcgKGlvbkRyYWcpPVwibG9nRHJhZygkZXZlbnQpXCI+XG4gKiAgIDxpb24taXRlbT5JdGVtPC9pb24taXRlbT5cbiAqICAgPGlvbi1pdGVtLW9wdGlvbnM+XG4gKiAgICAgPGJ1dHRvbiBpb24tYnV0dG9uPkZhdm9yaXRlPC9idXR0b24+XG4gKiAgIDwvaW9uLWl0ZW0tb3B0aW9ucz5cbiAqIDwvaW9uLWl0ZW0tc2xpZGluZz5cbiAqIGBgYFxuICpcbiAqICMjIyBCdXR0b24gTGF5b3V0XG4gKiBJZiBhbiBpY29uIGlzIHBsYWNlZCB3aXRoIHRleHQgaW4gdGhlIG9wdGlvbiBidXR0b24sIGJ5IGRlZmF1bHQgaXQgd2lsbFxuICogZGlzcGxheSB0aGUgaWNvbiBvbiB0b3Agb2YgdGhlIHRleHQuIFRoaXMgY2FuIGJlIGNoYW5nZWQgdG8gZGlzcGxheSB0aGUgaWNvblxuICogdG8gdGhlIGxlZnQgb2YgdGhlIHRleHQgYnkgc2V0dGluZyBgaWNvbi1zdGFydGAgYXMgYW4gYXR0cmlidXRlIG9uIHRoZVxuICogYDxpb24taXRlbS1vcHRpb25zPmAgZWxlbWVudC5cbiAqXG4gKiBgYGBodG1sXG4gKiA8aW9uLWl0ZW0tb3B0aW9ucyBpY29uLXN0YXJ0PlxuICogICAgPGJ1dHRvbiBpb24tYnV0dG9uIChjbGljayk9XCJhcmNoaXZlKGl0ZW0pXCI+XG4gKiAgICAgIDxpb24taWNvbiBuYW1lPVwiYXJjaGl2ZVwiPjwvaW9uLWljb24+XG4gKiAgICAgIEFyY2hpdmVcbiAqICAgIDwvYnV0dG9uPlxuICogIDwvaW9uLWl0ZW0tb3B0aW9ucz5cbiAqXG4gKiBgYGBcbiAqXG4gKiAjIyMgRXhwYW5kYWJsZSBPcHRpb25zXG4gKlxuICogT3B0aW9ucyBjYW4gYmUgZXhwYW5kZWQgdG8gdGFrZSB1cCB0aGUgZnVsbCB3aWR0aCBvZiB0aGUgaXRlbSBpZiB5b3Ugc3dpcGUgcGFzdFxuICogYSBjZXJ0YWluIHBvaW50LiBUaGlzIGNhbiBiZSBjb21iaW5lZCB3aXRoIHRoZSBgaW9uU3dpcGVgIGV2ZW50IHRvIGNhbGwgbWV0aG9kc1xuICogb24gdGhlIGNsYXNzLlxuICpcbiAqIGBgYGh0bWxcbiAqXG4gKiA8aW9uLWl0ZW0tc2xpZGluZz5cbiAqICAgPGlvbi1pdGVtPkl0ZW08L2lvbi1pdGVtPlxuICogICA8aW9uLWl0ZW0tb3B0aW9ucyAoaW9uU3dpcGUpPVwiZGVsZXRlKGl0ZW0pXCI+XG4gKiAgICAgPGJ1dHRvbiBpb24tYnV0dG9uIGV4cGFuZGFibGUgKGNsaWNrKT1cImRlbGV0ZShpdGVtKVwiPkRlbGV0ZTwvYnV0dG9uPlxuICogICA8L2lvbi1pdGVtLW9wdGlvbnM+XG4gKiA8L2lvbi1pdGVtLXNsaWRpbmc+XG4gKiBgYGBcbiAqXG4gKiBXZSBjYW4gY2FsbCBgZGVsZXRlYCBieSBlaXRoZXIgY2xpY2tpbmcgdGhlIGJ1dHRvbiwgb3IgYnkgZG9pbmcgYSBmdWxsIHN3aXBlIG9uIHRoZSBpdGVtLlxuICpcbiAqIEBkZW1vIC9kb2NzL2RlbW9zL3NyYy9pdGVtLXNsaWRpbmcvXG4gKiBAc2VlIHtAbGluayAvZG9jcy9jb21wb25lbnRzI2xpc3RzIExpc3QgQ29tcG9uZW50IERvY3N9XG4gKiBAc2VlIHtAbGluayAuLi9JdGVtIEl0ZW0gQVBJIERvY3N9XG4gKiBAc2VlIHtAbGluayAuLi8uLi9saXN0L0xpc3QgTGlzdCBBUEkgRG9jc31cbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgSXRlbVNsaWRpbmcge1xuICAgIHByaXZhdGUgX3BsdDtcbiAgICBwcml2YXRlIF9yZW5kZXJlcjtcbiAgICBwcml2YXRlIF9lbGVtZW50UmVmO1xuICAgIHByaXZhdGUgX3pvbmU7XG4gICAgcHJpdmF0ZSBfb3BlbkFtb3VudDtcbiAgICBwcml2YXRlIF9zdGFydFg7XG4gICAgcHJpdmF0ZSBfb3B0c1dpZHRoUmlnaHRTaWRlO1xuICAgIHByaXZhdGUgX29wdHNXaWR0aExlZnRTaWRlO1xuICAgIHByaXZhdGUgX3NpZGVzO1xuICAgIHByaXZhdGUgX3RtcjtcbiAgICBwcml2YXRlIF9sZWZ0T3B0aW9ucztcbiAgICBwcml2YXRlIF9yaWdodE9wdGlvbnM7XG4gICAgcHJpdmF0ZSBfb3B0c0RpcnR5O1xuICAgIHByaXZhdGUgX3N0YXRlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBpdGVtOiBJdGVtO1xuICAgIC8qKlxuICAgICAqIEBvdXRwdXQge2V2ZW50fSBFbWl0dGVkIHdoZW4gdGhlIHNsaWRpbmcgcG9zaXRpb24gY2hhbmdlcy5cbiAgICAgKiBJdCByZXBvcnRzIHRoZSByZWxhdGl2ZSBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogb25kcmFnKGl0ZW0pIHtcbiAgICAgKiAgIGxldCBwZXJjZW50ID0gaXRlbS5nZXRTbGlkaW5nUGVyY2VudCgpO1xuICAgICAqICAgaWYgKHBlcmNlbnQgPiAwKSB7XG4gICAgICogICAgIC8vIHBvc2l0aXZlXG4gICAgICogICAgIGNvbnNvbGUubG9nKCdyaWdodCBzaWRlJyk7XG4gICAgICogICB9IGVsc2Uge1xuICAgICAqICAgICAvLyBuZWdhdGl2ZVxuICAgICAqICAgICBjb25zb2xlLmxvZygnbGVmdCBzaWRlJyk7XG4gICAgICogICB9XG4gICAgICogICBpZiAoTWF0aC5hYnMocGVyY2VudCkgPiAxKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdvdmVyc2Nyb2xsJyk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICovXG4gICAgaW9uRHJhZzogRXZlbnRFbWl0dGVyPEl0ZW1TbGlkaW5nPjtcbiAgICBjb25zdHJ1Y3RvcihsaXN0OiBMaXN0LCBfcGx0OiBQbGF0Zm9ybSwgX3JlbmRlcmVyOiBSZW5kZXJlciwgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIF96b25lOiBOZ1pvbmUpO1xuICAgIF9pdGVtT3B0aW9uczogUXVlcnlMaXN0PEl0ZW1PcHRpb25zPjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0T3BlbkFtb3VudCgpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldFNsaWRpbmdQZXJjZW50KCk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc3RhcnRTbGlkaW5nKHN0YXJ0WDogbnVtYmVyKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbW92ZVNsaWRpbmcoeDogbnVtYmVyKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBlbmRTbGlkaW5nKHZlbG9jaXR5OiBudW1iZXIpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByaXZhdGUgZmlyZVN3aXBlRXZlbnQoKTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJpdmF0ZSBjYWxjdWxhdGVPcHRzV2lkdGgoKTtcbiAgICBwcml2YXRlIF9zZXRPcGVuQW1vdW50KG9wZW5BbW91bnQsIGlzRmluYWwpO1xuICAgIHByaXZhdGUgX3NldFN0YXRlKHN0YXRlKTtcbiAgICAvKipcbiAgICAgKiBDbG9zZSB0aGUgc2xpZGluZyBpdGVtLiBJdGVtcyBjYW4gYWxzbyBiZSBjbG9zZWQgZnJvbSB0aGUgW0xpc3RdKC4uLy4uL2xpc3QvTGlzdCkuXG4gICAgICpcbiAgICAgKiBUaGUgc2xpZGluZyBpdGVtIGNhbiBiZSBjbG9zZWQgYnkgZ3JhYmJpbmcgYSByZWZlcmVuY2UgdG8gYEl0ZW1TbGlkaW5nYC4gSW4gdGhlXG4gICAgICogYmVsb3cgZXhhbXBsZSwgdGhlIHRlbXBsYXRlIHJlZmVyZW5jZSB2YXJpYWJsZSBgc2xpZGluZ0l0ZW1gIGlzIHBsYWNlZCBvbiB0aGUgZWxlbWVudFxuICAgICAqIGFuZCBwYXNzZWQgdG8gdGhlIGBzaGFyZWAgbWV0aG9kLlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpb24tbGlzdD5cbiAgICAgKiAgIDxpb24taXRlbS1zbGlkaW5nICNzbGlkaW5nSXRlbT5cbiAgICAgKiAgICAgPGlvbi1pdGVtPlxuICAgICAqICAgICAgIEl0ZW1cbiAgICAgKiAgICAgPC9pb24taXRlbT5cbiAgICAgKiAgICAgPGlvbi1pdGVtLW9wdGlvbnM+XG4gICAgICogICAgICAgPGJ1dHRvbiBpb24tYnV0dG9uIChjbGljayk9XCJzaGFyZShzbGlkaW5nSXRlbSlcIj5TaGFyZTwvYnV0dG9uPlxuICAgICAqICAgICA8L2lvbi1pdGVtLW9wdGlvbnM+XG4gICAgICogICA8L2lvbi1pdGVtLXNsaWRpbmc+XG4gICAgICogPC9pb24tbGlzdD5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gICAgICogaW1wb3J0IHsgSXRlbVNsaWRpbmcgfSBmcm9tICdpb25pYy1hbmd1bGFyJztcbiAgICAgKlxuICAgICAqIEBDb21wb25lbnQoey4uLn0pXG4gICAgICogZXhwb3J0IGNsYXNzIE15Q2xhc3Mge1xuICAgICAqICAgY29uc3RydWN0b3IoKSB7IH1cbiAgICAgKlxuICAgICAqICAgc2hhcmUoc2xpZGluZ0l0ZW06IEl0ZW1TbGlkaW5nKSB7XG4gICAgICogICAgIHNsaWRpbmdJdGVtLmNsb3NlKCk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGNsb3NlKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNldEVsZW1lbnRDbGFzcyhjc3NDbGFzczogc3RyaW5nLCBzaG91bGRBZGQ6IGJvb2xlYW4pOiB2b2lkO1xufVxuIl19