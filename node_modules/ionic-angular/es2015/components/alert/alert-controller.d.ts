import { Alert } from './alert';
import { App } from '../app/app';
import { AlertOptions } from './alert-options';
import { Config } from '../../config/config';
/**
 * @name AlertController
 * @description
 * An Alert is a dialog that presents users with information or collects
 * information from the user using inputs. An alert appears on top
 * of the app's content, and must be manually dismissed by the user before
 * they can resume interaction with the app. It can also optionally have a
 * `title`, `subTitle` and `message`.
 *
 * You can pass all of the alert's options in the first argument of
 * the create method: `create(opts)`. Otherwise the alert's instance
 * has methods to add options, such as `setTitle()` or `addButton()`.
 *
 *
 * ### Alert Buttons
 *
 * In the array of `buttons`, each button includes properties for its `text`,
 * and optionally a `handler`. If a handler returns `false` then the alert
 * will not automatically be dismissed when the button is clicked. All
 * buttons will show up in the order they have been added to the `buttons`
 * array, from left to right. Note: The right most button (the last one in
 * the array) is the main button.
 *
 * Optionally, a `role` property can be added to a button, such as `cancel`.
 * If a `cancel` role is on one of the buttons, then if the alert is
 * dismissed by tapping the backdrop, then it will fire the handler from
 * the button with a cancel role.
 *
 *
 * ### Alert Inputs
 *
 * Alerts can also include several different inputs whose data can be passed
 * back to the app. Inputs can be used as a simple way to prompt users for
 * information. Radios, checkboxes and text inputs are all accepted, but they
 * cannot be mixed. For example, an alert could have all radio button inputs,
 * or all checkbox inputs, but the same alert cannot mix radio and checkbox
 * inputs. Do note however, different types of "text"" inputs can be mixed,
 * such as `url`, `email`, `text`, etc. If you require a complex form UI
 * which doesn't fit within the guidelines of an alert then we recommend
 * building the form within a modal instead.
 *
 *
 * @usage
 * ```ts
 * import { AlertController } from 'ionic-angular';
 *
 * constructor(public alertCtrl: AlertController) { }
 *
 * presentAlert() {
 *   const alert = this.alertCtrl.create({
 *     title: 'Low battery',
 *     subTitle: '10% of battery remaining',
 *     buttons: ['Dismiss']
 *   });
 *   alert.onDidDismiss(() => console.log('Alert was dismissed by the user'));
 *   alert.present();
 * }
 *
 * presentConfirm() {
 *   const alert = this.alertCtrl.create({
 *     title: 'Confirm purchase',
 *     message: 'Do you want to buy this book?',
 *     buttons: [
 *       {
 *         text: 'Cancel',
 *         role: 'cancel',
 *         handler: () => {
 *           console.log('Cancel clicked');
 *         }
 *       },
 *       {
 *         text: 'Buy',
 *         handler: () => {
 *           console.log('Buy clicked');
 *         }
 *       }
 *     ]
 *   });
 *   alert.onDidDismiss(() => console.log('Alert was dismissed by the user'));
 *   alert.present();
 * }
 *
 * presentPrompt() {
 *   const alert = this.alertCtrl.create({
 *     title: 'Login',
 *     inputs: [
 *       {
 *         name: 'username',
 *         placeholder: 'Username'
 *       },
 *       {
 *         name: 'password',
 *         placeholder: 'Password',
 *         type: 'password'
 *       }
 *     ],
 *     buttons: [
 *       {
 *         text: 'Cancel',
 *         role: 'cancel',
 *         handler: data => {
 *           console.log('Cancel clicked');
 *         }
 *       },
 *       {
 *         text: 'Login',
 *         handler: data => {
 *           if (User.isValid(data.username, data.password)) {
 *             // logged in!
 *           } else {
 *             // invalid login
 *             return false;
 *           }
 *         }
 *       }
 *     ]
 *   });
 *   alert.present();
 * }
 * ```
 * @advanced
 *
 *
 *  Alert options
 *
 *  | Property              | Type      | Description                                                                  |
 *  |-----------------------|-----------|------------------------------------------------------------------------------|
 *  | title                 | `string`  | The title for the alert.                                                     |
 *  | subTitle              | `string`  | The subtitle for the alert.                                                  |
 *  | message               | `string`  | The message for the alert.                                                   |
 *  | cssClass              | `string`  | Additional classes for custom styles, separated by spaces.                   |
 *  | inputs                | `array`   | An array of inputs for the alert. See input options.                         |
 *  | buttons               | `array`   | An array of buttons for the alert. See buttons options.                      |
 *  | enableBackdropDismiss | `boolean` | Whether the alert should be dismissed by tapping the backdrop. Default true. |
 *
 *
 *  Input options
 *
 *  | Property    | Type      | Description                                                     |
 *  |-------------|-----------|-----------------------------------------------------------------|
 *  | type        | `string`  | The type the input should be: text, tel, number, etc.           |
 *  | name        | `string`  | The name for the input.                                         |
 *  | placeholder | `string`  | The input's placeholder (for textual/numeric inputs)            |
 *  | value       | `string`  | The input's value.                                              |
 *  | label       | `string`  | The input's label (only for radio/checkbox inputs)              |
 *  | checked     | `boolean` | Whether or not the input is checked.                            |
 *  | disabled    | `boolean` | Whether or not the input is disabled.                           |
 *  | id          | `string`  | The input's id.                                                 |
 *
 *  Button options
 *
 *  | Property | Type     | Description                                                     |
 *  |----------|----------|-----------------------------------------------------------------|
 *  | text     | `string` | The buttons displayed text.                                     |
 *  | handler  | `any`    | Emitted when the button is pressed.                             |
 *  | cssClass | `string` | An additional CSS class for the button.                         |
 *  | role     | `string` | The buttons role, null or `cancel`.                             |
 *
 * ### Detecting dismissal
 *
 * Any dismissal of the alert (including backdrop) can be detected
 * using the method `onDidDismiss(() => {})`.
 *
 * ### Dismissing And Async Navigation
 *
 * After an alert has been dismissed, the app may need to also transition
 * to another page depending on the handler's logic. However, because multiple
 * transitions were fired at roughly the same time, it's difficult for the
 * nav controller to cleanly animate multiple transitions that may
 * have been kicked off asynchronously. This is further described in the
 * [`Nav Transition Promises`](../../nav/NavController) section. For alerts,
 * this means it's best to wait for the alert to finish its transition
 * out before starting a new transition on the same nav controller.
 *
 * In the example below, after the alert button has been clicked, its handler
 * waits on async operation to complete, *then* it uses `pop` to navigate
 * back a page in the same stack. The potential problem is that the async operation
 * may have been completed before the alert has even finished its transition
 * out. In this case, it's best to ensure the alert has finished its transition
 * out first, *then* start the next transition.
 *
 * ```ts
 * const alert = this.alertCtrl.create({
 *   title: 'Hello',
 *   buttons: [{
 *     text: 'Ok',
 *     handler: () => {
 *       // user has clicked the alert button
 *       // begin the alert's dismiss transition
 *       const navTransition = alert.dismiss();
 *
 *       // start some async method
 *       someAsyncOperation().then(() => {
 *         // once the async operation has completed
 *         // then run the next nav transition after the
 *         // first transition has finished animating out
 *
 *         navTransition.then(() => {
 *           this.nav.pop();
 *         });
 *       });
 *       return false;
 *     }
 *   }]
 * });
 *
 * alert.present();
 * ```
 *
 * It's important to note that the handler returns `false`. A feature of
 * button handlers is that they automatically dismiss the alert when their button
 * was clicked, however, we'll need more control regarding the transition. Because
 * the handler returns `false`, then the alert does not automatically dismiss
 * itself. Instead, you now have complete control of when the alert has finished
 * transitioning, and the ability to wait for the alert to finish transitioning
 * out before starting a new transition.
 *
 *
 * @demo /docs/demos/src/alert/
 */
import * as ɵngcc0 from '@angular/core';
export declare class AlertController {
    private _app;
    config: Config;
    constructor(_app: App, config: Config);
    /**
     * Display an alert with a title, inputs, and buttons
     * @param {AlertOptions} opts Alert. See the table below
     */
    create(opts?: AlertOptions): Alert;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<AlertController, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<AlertController>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWxlcnQtY29udHJvbGxlci5kLnRzIiwic291cmNlcyI6WyJhbGVydC1jb250cm9sbGVyLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWxlcnQgfSBmcm9tICcuL2FsZXJ0JztcbmltcG9ydCB7IEFwcCB9IGZyb20gJy4uL2FwcC9hcHAnO1xuaW1wb3J0IHsgQWxlcnRPcHRpb25zIH0gZnJvbSAnLi9hbGVydC1vcHRpb25zJztcbmltcG9ydCB7IENvbmZpZyB9IGZyb20gJy4uLy4uL2NvbmZpZy9jb25maWcnO1xuLyoqXG4gKiBAbmFtZSBBbGVydENvbnRyb2xsZXJcbiAqIEBkZXNjcmlwdGlvblxuICogQW4gQWxlcnQgaXMgYSBkaWFsb2cgdGhhdCBwcmVzZW50cyB1c2VycyB3aXRoIGluZm9ybWF0aW9uIG9yIGNvbGxlY3RzXG4gKiBpbmZvcm1hdGlvbiBmcm9tIHRoZSB1c2VyIHVzaW5nIGlucHV0cy4gQW4gYWxlcnQgYXBwZWFycyBvbiB0b3BcbiAqIG9mIHRoZSBhcHAncyBjb250ZW50LCBhbmQgbXVzdCBiZSBtYW51YWxseSBkaXNtaXNzZWQgYnkgdGhlIHVzZXIgYmVmb3JlXG4gKiB0aGV5IGNhbiByZXN1bWUgaW50ZXJhY3Rpb24gd2l0aCB0aGUgYXBwLiBJdCBjYW4gYWxzbyBvcHRpb25hbGx5IGhhdmUgYVxuICogYHRpdGxlYCwgYHN1YlRpdGxlYCBhbmQgYG1lc3NhZ2VgLlxuICpcbiAqIFlvdSBjYW4gcGFzcyBhbGwgb2YgdGhlIGFsZXJ0J3Mgb3B0aW9ucyBpbiB0aGUgZmlyc3QgYXJndW1lbnQgb2ZcbiAqIHRoZSBjcmVhdGUgbWV0aG9kOiBgY3JlYXRlKG9wdHMpYC4gT3RoZXJ3aXNlIHRoZSBhbGVydCdzIGluc3RhbmNlXG4gKiBoYXMgbWV0aG9kcyB0byBhZGQgb3B0aW9ucywgc3VjaCBhcyBgc2V0VGl0bGUoKWAgb3IgYGFkZEJ1dHRvbigpYC5cbiAqXG4gKlxuICogIyMjIEFsZXJ0IEJ1dHRvbnNcbiAqXG4gKiBJbiB0aGUgYXJyYXkgb2YgYGJ1dHRvbnNgLCBlYWNoIGJ1dHRvbiBpbmNsdWRlcyBwcm9wZXJ0aWVzIGZvciBpdHMgYHRleHRgLFxuICogYW5kIG9wdGlvbmFsbHkgYSBgaGFuZGxlcmAuIElmIGEgaGFuZGxlciByZXR1cm5zIGBmYWxzZWAgdGhlbiB0aGUgYWxlcnRcbiAqIHdpbGwgbm90IGF1dG9tYXRpY2FsbHkgYmUgZGlzbWlzc2VkIHdoZW4gdGhlIGJ1dHRvbiBpcyBjbGlja2VkLiBBbGxcbiAqIGJ1dHRvbnMgd2lsbCBzaG93IHVwIGluIHRoZSBvcmRlciB0aGV5IGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgYGJ1dHRvbnNgXG4gKiBhcnJheSwgZnJvbSBsZWZ0IHRvIHJpZ2h0LiBOb3RlOiBUaGUgcmlnaHQgbW9zdCBidXR0b24gKHRoZSBsYXN0IG9uZSBpblxuICogdGhlIGFycmF5KSBpcyB0aGUgbWFpbiBidXR0b24uXG4gKlxuICogT3B0aW9uYWxseSwgYSBgcm9sZWAgcHJvcGVydHkgY2FuIGJlIGFkZGVkIHRvIGEgYnV0dG9uLCBzdWNoIGFzIGBjYW5jZWxgLlxuICogSWYgYSBgY2FuY2VsYCByb2xlIGlzIG9uIG9uZSBvZiB0aGUgYnV0dG9ucywgdGhlbiBpZiB0aGUgYWxlcnQgaXNcbiAqIGRpc21pc3NlZCBieSB0YXBwaW5nIHRoZSBiYWNrZHJvcCwgdGhlbiBpdCB3aWxsIGZpcmUgdGhlIGhhbmRsZXIgZnJvbVxuICogdGhlIGJ1dHRvbiB3aXRoIGEgY2FuY2VsIHJvbGUuXG4gKlxuICpcbiAqICMjIyBBbGVydCBJbnB1dHNcbiAqXG4gKiBBbGVydHMgY2FuIGFsc28gaW5jbHVkZSBzZXZlcmFsIGRpZmZlcmVudCBpbnB1dHMgd2hvc2UgZGF0YSBjYW4gYmUgcGFzc2VkXG4gKiBiYWNrIHRvIHRoZSBhcHAuIElucHV0cyBjYW4gYmUgdXNlZCBhcyBhIHNpbXBsZSB3YXkgdG8gcHJvbXB0IHVzZXJzIGZvclxuICogaW5mb3JtYXRpb24uIFJhZGlvcywgY2hlY2tib3hlcyBhbmQgdGV4dCBpbnB1dHMgYXJlIGFsbCBhY2NlcHRlZCwgYnV0IHRoZXlcbiAqIGNhbm5vdCBiZSBtaXhlZC4gRm9yIGV4YW1wbGUsIGFuIGFsZXJ0IGNvdWxkIGhhdmUgYWxsIHJhZGlvIGJ1dHRvbiBpbnB1dHMsXG4gKiBvciBhbGwgY2hlY2tib3ggaW5wdXRzLCBidXQgdGhlIHNhbWUgYWxlcnQgY2Fubm90IG1peCByYWRpbyBhbmQgY2hlY2tib3hcbiAqIGlucHV0cy4gRG8gbm90ZSBob3dldmVyLCBkaWZmZXJlbnQgdHlwZXMgb2YgXCJ0ZXh0XCJcIiBpbnB1dHMgY2FuIGJlIG1peGVkLFxuICogc3VjaCBhcyBgdXJsYCwgYGVtYWlsYCwgYHRleHRgLCBldGMuIElmIHlvdSByZXF1aXJlIGEgY29tcGxleCBmb3JtIFVJXG4gKiB3aGljaCBkb2Vzbid0IGZpdCB3aXRoaW4gdGhlIGd1aWRlbGluZXMgb2YgYW4gYWxlcnQgdGhlbiB3ZSByZWNvbW1lbmRcbiAqIGJ1aWxkaW5nIHRoZSBmb3JtIHdpdGhpbiBhIG1vZGFsIGluc3RlYWQuXG4gKlxuICpcbiAqIEB1c2FnZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEFsZXJ0Q29udHJvbGxlciB9IGZyb20gJ2lvbmljLWFuZ3VsYXInO1xuICpcbiAqIGNvbnN0cnVjdG9yKHB1YmxpYyBhbGVydEN0cmw6IEFsZXJ0Q29udHJvbGxlcikgeyB9XG4gKlxuICogcHJlc2VudEFsZXJ0KCkge1xuICogICBjb25zdCBhbGVydCA9IHRoaXMuYWxlcnRDdHJsLmNyZWF0ZSh7XG4gKiAgICAgdGl0bGU6ICdMb3cgYmF0dGVyeScsXG4gKiAgICAgc3ViVGl0bGU6ICcxMCUgb2YgYmF0dGVyeSByZW1haW5pbmcnLFxuICogICAgIGJ1dHRvbnM6IFsnRGlzbWlzcyddXG4gKiAgIH0pO1xuICogICBhbGVydC5vbkRpZERpc21pc3MoKCkgPT4gY29uc29sZS5sb2coJ0FsZXJ0IHdhcyBkaXNtaXNzZWQgYnkgdGhlIHVzZXInKSk7XG4gKiAgIGFsZXJ0LnByZXNlbnQoKTtcbiAqIH1cbiAqXG4gKiBwcmVzZW50Q29uZmlybSgpIHtcbiAqICAgY29uc3QgYWxlcnQgPSB0aGlzLmFsZXJ0Q3RybC5jcmVhdGUoe1xuICogICAgIHRpdGxlOiAnQ29uZmlybSBwdXJjaGFzZScsXG4gKiAgICAgbWVzc2FnZTogJ0RvIHlvdSB3YW50IHRvIGJ1eSB0aGlzIGJvb2s/JyxcbiAqICAgICBidXR0b25zOiBbXG4gKiAgICAgICB7XG4gKiAgICAgICAgIHRleHQ6ICdDYW5jZWwnLFxuICogICAgICAgICByb2xlOiAnY2FuY2VsJyxcbiAqICAgICAgICAgaGFuZGxlcjogKCkgPT4ge1xuICogICAgICAgICAgIGNvbnNvbGUubG9nKCdDYW5jZWwgY2xpY2tlZCcpO1xuICogICAgICAgICB9XG4gKiAgICAgICB9LFxuICogICAgICAge1xuICogICAgICAgICB0ZXh0OiAnQnV5JyxcbiAqICAgICAgICAgaGFuZGxlcjogKCkgPT4ge1xuICogICAgICAgICAgIGNvbnNvbGUubG9nKCdCdXkgY2xpY2tlZCcpO1xuICogICAgICAgICB9XG4gKiAgICAgICB9XG4gKiAgICAgXVxuICogICB9KTtcbiAqICAgYWxlcnQub25EaWREaXNtaXNzKCgpID0+IGNvbnNvbGUubG9nKCdBbGVydCB3YXMgZGlzbWlzc2VkIGJ5IHRoZSB1c2VyJykpO1xuICogICBhbGVydC5wcmVzZW50KCk7XG4gKiB9XG4gKlxuICogcHJlc2VudFByb21wdCgpIHtcbiAqICAgY29uc3QgYWxlcnQgPSB0aGlzLmFsZXJ0Q3RybC5jcmVhdGUoe1xuICogICAgIHRpdGxlOiAnTG9naW4nLFxuICogICAgIGlucHV0czogW1xuICogICAgICAge1xuICogICAgICAgICBuYW1lOiAndXNlcm5hbWUnLFxuICogICAgICAgICBwbGFjZWhvbGRlcjogJ1VzZXJuYW1lJ1xuICogICAgICAgfSxcbiAqICAgICAgIHtcbiAqICAgICAgICAgbmFtZTogJ3Bhc3N3b3JkJyxcbiAqICAgICAgICAgcGxhY2Vob2xkZXI6ICdQYXNzd29yZCcsXG4gKiAgICAgICAgIHR5cGU6ICdwYXNzd29yZCdcbiAqICAgICAgIH1cbiAqICAgICBdLFxuICogICAgIGJ1dHRvbnM6IFtcbiAqICAgICAgIHtcbiAqICAgICAgICAgdGV4dDogJ0NhbmNlbCcsXG4gKiAgICAgICAgIHJvbGU6ICdjYW5jZWwnLFxuICogICAgICAgICBoYW5kbGVyOiBkYXRhID0+IHtcbiAqICAgICAgICAgICBjb25zb2xlLmxvZygnQ2FuY2VsIGNsaWNrZWQnKTtcbiAqICAgICAgICAgfVxuICogICAgICAgfSxcbiAqICAgICAgIHtcbiAqICAgICAgICAgdGV4dDogJ0xvZ2luJyxcbiAqICAgICAgICAgaGFuZGxlcjogZGF0YSA9PiB7XG4gKiAgICAgICAgICAgaWYgKFVzZXIuaXNWYWxpZChkYXRhLnVzZXJuYW1lLCBkYXRhLnBhc3N3b3JkKSkge1xuICogICAgICAgICAgICAgLy8gbG9nZ2VkIGluIVxuICogICAgICAgICAgIH0gZWxzZSB7XG4gKiAgICAgICAgICAgICAvLyBpbnZhbGlkIGxvZ2luXG4gKiAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gKiAgICAgICAgICAgfVxuICogICAgICAgICB9XG4gKiAgICAgICB9XG4gKiAgICAgXVxuICogICB9KTtcbiAqICAgYWxlcnQucHJlc2VudCgpO1xuICogfVxuICogYGBgXG4gKiBAYWR2YW5jZWRcbiAqXG4gKlxuICogIEFsZXJ0IG9wdGlvbnNcbiAqXG4gKiAgfCBQcm9wZXJ0eSAgICAgICAgICAgICAgfCBUeXBlICAgICAgfCBEZXNjcmlwdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogIHwgdGl0bGUgICAgICAgICAgICAgICAgIHwgYHN0cmluZ2AgIHwgVGhlIHRpdGxlIGZvciB0aGUgYWxlcnQuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgfCBzdWJUaXRsZSAgICAgICAgICAgICAgfCBgc3RyaW5nYCAgfCBUaGUgc3VidGl0bGUgZm9yIHRoZSBhbGVydC4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8IG1lc3NhZ2UgICAgICAgICAgICAgICB8IGBzdHJpbmdgICB8IFRoZSBtZXNzYWdlIGZvciB0aGUgYWxlcnQuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgY3NzQ2xhc3MgICAgICAgICAgICAgIHwgYHN0cmluZ2AgIHwgQWRkaXRpb25hbCBjbGFzc2VzIGZvciBjdXN0b20gc3R5bGVzLCBzZXBhcmF0ZWQgYnkgc3BhY2VzLiAgICAgICAgICAgICAgICAgICB8XG4gKiAgfCBpbnB1dHMgICAgICAgICAgICAgICAgfCBgYXJyYXlgICAgfCBBbiBhcnJheSBvZiBpbnB1dHMgZm9yIHRoZSBhbGVydC4gU2VlIGlucHV0IG9wdGlvbnMuICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8IGJ1dHRvbnMgICAgICAgICAgICAgICB8IGBhcnJheWAgICB8IEFuIGFycmF5IG9mIGJ1dHRvbnMgZm9yIHRoZSBhbGVydC4gU2VlIGJ1dHRvbnMgb3B0aW9ucy4gICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgZW5hYmxlQmFja2Ryb3BEaXNtaXNzIHwgYGJvb2xlYW5gIHwgV2hldGhlciB0aGUgYWxlcnQgc2hvdWxkIGJlIGRpc21pc3NlZCBieSB0YXBwaW5nIHRoZSBiYWNrZHJvcC4gRGVmYXVsdCB0cnVlLiB8XG4gKlxuICpcbiAqICBJbnB1dCBvcHRpb25zXG4gKlxuICogIHwgUHJvcGVydHkgICAgfCBUeXBlICAgICAgfCBEZXNjcmlwdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwtLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogIHwgdHlwZSAgICAgICAgfCBgc3RyaW5nYCAgfCBUaGUgdHlwZSB0aGUgaW5wdXQgc2hvdWxkIGJlOiB0ZXh0LCB0ZWwsIG51bWJlciwgZXRjLiAgICAgICAgICAgfFxuICogIHwgbmFtZSAgICAgICAgfCBgc3RyaW5nYCAgfCBUaGUgbmFtZSBmb3IgdGhlIGlucHV0LiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgcGxhY2Vob2xkZXIgfCBgc3RyaW5nYCAgfCBUaGUgaW5wdXQncyBwbGFjZWhvbGRlciAoZm9yIHRleHR1YWwvbnVtZXJpYyBpbnB1dHMpICAgICAgICAgICAgfFxuICogIHwgdmFsdWUgICAgICAgfCBgc3RyaW5nYCAgfCBUaGUgaW5wdXQncyB2YWx1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgbGFiZWwgICAgICAgfCBgc3RyaW5nYCAgfCBUaGUgaW5wdXQncyBsYWJlbCAob25seSBmb3IgcmFkaW8vY2hlY2tib3ggaW5wdXRzKSAgICAgICAgICAgICAgfFxuICogIHwgY2hlY2tlZCAgICAgfCBgYm9vbGVhbmAgfCBXaGV0aGVyIG9yIG5vdCB0aGUgaW5wdXQgaXMgY2hlY2tlZC4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgZGlzYWJsZWQgICAgfCBgYm9vbGVhbmAgfCBXaGV0aGVyIG9yIG5vdCB0aGUgaW5wdXQgaXMgZGlzYWJsZWQuICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgaWQgICAgICAgICAgfCBgc3RyaW5nYCAgfCBUaGUgaW5wdXQncyBpZC4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICpcbiAqICBCdXR0b24gb3B0aW9uc1xuICpcbiAqICB8IFByb3BlcnR5IHwgVHlwZSAgICAgfCBEZXNjcmlwdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwtLS0tLS0tLS0tfC0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gKiAgfCB0ZXh0ICAgICB8IGBzdHJpbmdgIHwgVGhlIGJ1dHRvbnMgZGlzcGxheWVkIHRleHQuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8IGhhbmRsZXIgIHwgYGFueWAgICAgfCBFbWl0dGVkIHdoZW4gdGhlIGJ1dHRvbiBpcyBwcmVzc2VkLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgY3NzQ2xhc3MgfCBgc3RyaW5nYCB8IEFuIGFkZGl0aW9uYWwgQ1NTIGNsYXNzIGZvciB0aGUgYnV0dG9uLiAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgfCByb2xlICAgICB8IGBzdHJpbmdgIHwgVGhlIGJ1dHRvbnMgcm9sZSwgbnVsbCBvciBgY2FuY2VsYC4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqXG4gKiAjIyMgRGV0ZWN0aW5nIGRpc21pc3NhbFxuICpcbiAqIEFueSBkaXNtaXNzYWwgb2YgdGhlIGFsZXJ0IChpbmNsdWRpbmcgYmFja2Ryb3ApIGNhbiBiZSBkZXRlY3RlZFxuICogdXNpbmcgdGhlIG1ldGhvZCBgb25EaWREaXNtaXNzKCgpID0+IHt9KWAuXG4gKlxuICogIyMjIERpc21pc3NpbmcgQW5kIEFzeW5jIE5hdmlnYXRpb25cbiAqXG4gKiBBZnRlciBhbiBhbGVydCBoYXMgYmVlbiBkaXNtaXNzZWQsIHRoZSBhcHAgbWF5IG5lZWQgdG8gYWxzbyB0cmFuc2l0aW9uXG4gKiB0byBhbm90aGVyIHBhZ2UgZGVwZW5kaW5nIG9uIHRoZSBoYW5kbGVyJ3MgbG9naWMuIEhvd2V2ZXIsIGJlY2F1c2UgbXVsdGlwbGVcbiAqIHRyYW5zaXRpb25zIHdlcmUgZmlyZWQgYXQgcm91Z2hseSB0aGUgc2FtZSB0aW1lLCBpdCdzIGRpZmZpY3VsdCBmb3IgdGhlXG4gKiBuYXYgY29udHJvbGxlciB0byBjbGVhbmx5IGFuaW1hdGUgbXVsdGlwbGUgdHJhbnNpdGlvbnMgdGhhdCBtYXlcbiAqIGhhdmUgYmVlbiBraWNrZWQgb2ZmIGFzeW5jaHJvbm91c2x5LiBUaGlzIGlzIGZ1cnRoZXIgZGVzY3JpYmVkIGluIHRoZVxuICogW2BOYXYgVHJhbnNpdGlvbiBQcm9taXNlc2BdKC4uLy4uL25hdi9OYXZDb250cm9sbGVyKSBzZWN0aW9uLiBGb3IgYWxlcnRzLFxuICogdGhpcyBtZWFucyBpdCdzIGJlc3QgdG8gd2FpdCBmb3IgdGhlIGFsZXJ0IHRvIGZpbmlzaCBpdHMgdHJhbnNpdGlvblxuICogb3V0IGJlZm9yZSBzdGFydGluZyBhIG5ldyB0cmFuc2l0aW9uIG9uIHRoZSBzYW1lIG5hdiBjb250cm9sbGVyLlxuICpcbiAqIEluIHRoZSBleGFtcGxlIGJlbG93LCBhZnRlciB0aGUgYWxlcnQgYnV0dG9uIGhhcyBiZWVuIGNsaWNrZWQsIGl0cyBoYW5kbGVyXG4gKiB3YWl0cyBvbiBhc3luYyBvcGVyYXRpb24gdG8gY29tcGxldGUsICp0aGVuKiBpdCB1c2VzIGBwb3BgIHRvIG5hdmlnYXRlXG4gKiBiYWNrIGEgcGFnZSBpbiB0aGUgc2FtZSBzdGFjay4gVGhlIHBvdGVudGlhbCBwcm9ibGVtIGlzIHRoYXQgdGhlIGFzeW5jIG9wZXJhdGlvblxuICogbWF5IGhhdmUgYmVlbiBjb21wbGV0ZWQgYmVmb3JlIHRoZSBhbGVydCBoYXMgZXZlbiBmaW5pc2hlZCBpdHMgdHJhbnNpdGlvblxuICogb3V0LiBJbiB0aGlzIGNhc2UsIGl0J3MgYmVzdCB0byBlbnN1cmUgdGhlIGFsZXJ0IGhhcyBmaW5pc2hlZCBpdHMgdHJhbnNpdGlvblxuICogb3V0IGZpcnN0LCAqdGhlbiogc3RhcnQgdGhlIG5leHQgdHJhbnNpdGlvbi5cbiAqXG4gKiBgYGB0c1xuICogY29uc3QgYWxlcnQgPSB0aGlzLmFsZXJ0Q3RybC5jcmVhdGUoe1xuICogICB0aXRsZTogJ0hlbGxvJyxcbiAqICAgYnV0dG9uczogW3tcbiAqICAgICB0ZXh0OiAnT2snLFxuICogICAgIGhhbmRsZXI6ICgpID0+IHtcbiAqICAgICAgIC8vIHVzZXIgaGFzIGNsaWNrZWQgdGhlIGFsZXJ0IGJ1dHRvblxuICogICAgICAgLy8gYmVnaW4gdGhlIGFsZXJ0J3MgZGlzbWlzcyB0cmFuc2l0aW9uXG4gKiAgICAgICBjb25zdCBuYXZUcmFuc2l0aW9uID0gYWxlcnQuZGlzbWlzcygpO1xuICpcbiAqICAgICAgIC8vIHN0YXJ0IHNvbWUgYXN5bmMgbWV0aG9kXG4gKiAgICAgICBzb21lQXN5bmNPcGVyYXRpb24oKS50aGVuKCgpID0+IHtcbiAqICAgICAgICAgLy8gb25jZSB0aGUgYXN5bmMgb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWRcbiAqICAgICAgICAgLy8gdGhlbiBydW4gdGhlIG5leHQgbmF2IHRyYW5zaXRpb24gYWZ0ZXIgdGhlXG4gKiAgICAgICAgIC8vIGZpcnN0IHRyYW5zaXRpb24gaGFzIGZpbmlzaGVkIGFuaW1hdGluZyBvdXRcbiAqXG4gKiAgICAgICAgIG5hdlRyYW5zaXRpb24udGhlbigoKSA9PiB7XG4gKiAgICAgICAgICAgdGhpcy5uYXYucG9wKCk7XG4gKiAgICAgICAgIH0pO1xuICogICAgICAgfSk7XG4gKiAgICAgICByZXR1cm4gZmFsc2U7XG4gKiAgICAgfVxuICogICB9XVxuICogfSk7XG4gKlxuICogYWxlcnQucHJlc2VudCgpO1xuICogYGBgXG4gKlxuICogSXQncyBpbXBvcnRhbnQgdG8gbm90ZSB0aGF0IHRoZSBoYW5kbGVyIHJldHVybnMgYGZhbHNlYC4gQSBmZWF0dXJlIG9mXG4gKiBidXR0b24gaGFuZGxlcnMgaXMgdGhhdCB0aGV5IGF1dG9tYXRpY2FsbHkgZGlzbWlzcyB0aGUgYWxlcnQgd2hlbiB0aGVpciBidXR0b25cbiAqIHdhcyBjbGlja2VkLCBob3dldmVyLCB3ZSdsbCBuZWVkIG1vcmUgY29udHJvbCByZWdhcmRpbmcgdGhlIHRyYW5zaXRpb24uIEJlY2F1c2VcbiAqIHRoZSBoYW5kbGVyIHJldHVybnMgYGZhbHNlYCwgdGhlbiB0aGUgYWxlcnQgZG9lcyBub3QgYXV0b21hdGljYWxseSBkaXNtaXNzXG4gKiBpdHNlbGYuIEluc3RlYWQsIHlvdSBub3cgaGF2ZSBjb21wbGV0ZSBjb250cm9sIG9mIHdoZW4gdGhlIGFsZXJ0IGhhcyBmaW5pc2hlZFxuICogdHJhbnNpdGlvbmluZywgYW5kIHRoZSBhYmlsaXR5IHRvIHdhaXQgZm9yIHRoZSBhbGVydCB0byBmaW5pc2ggdHJhbnNpdGlvbmluZ1xuICogb3V0IGJlZm9yZSBzdGFydGluZyBhIG5ldyB0cmFuc2l0aW9uLlxuICpcbiAqXG4gKiBAZGVtbyAvZG9jcy9kZW1vcy9zcmMvYWxlcnQvXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIEFsZXJ0Q29udHJvbGxlciB7XG4gICAgcHJpdmF0ZSBfYXBwO1xuICAgIGNvbmZpZzogQ29uZmlnO1xuICAgIGNvbnN0cnVjdG9yKF9hcHA6IEFwcCwgY29uZmlnOiBDb25maWcpO1xuICAgIC8qKlxuICAgICAqIERpc3BsYXkgYW4gYWxlcnQgd2l0aCBhIHRpdGxlLCBpbnB1dHMsIGFuZCBidXR0b25zXG4gICAgICogQHBhcmFtIHtBbGVydE9wdGlvbnN9IG9wdHMgQWxlcnQuIFNlZSB0aGUgdGFibGUgYmVsb3dcbiAgICAgKi9cbiAgICBjcmVhdGUob3B0cz86IEFsZXJ0T3B0aW9ucyk6IEFsZXJ0O1xufVxuIl19