import { EventEmitter, NgZone } from '@angular/core';
import { Content } from '../content/content';
import { GestureController, GestureDelegate } from '../../gestures/gesture-controller';
import { Platform } from '../../platform/platform';
import { PointerEvents } from '../../gestures/pointer-events';
import { UIEventManager } from '../../gestures/ui-event-manager';
/**
 * @name Refresher
 * @description
 * The Refresher provides pull-to-refresh functionality on a content component.
 * Place the `ion-refresher` as the first child of your `ion-content` element.
 *
 * Pages can then listen to the refresher's various output events. The
 * `refresh` output event is fired when the user has pulled down far
 * enough to kick off the refreshing process. Once the async operation
 * has completed and the refreshing should end, call `complete()`.
 *
 * Note: Do not wrap the `ion-refresher` in a `*ngIf`. It will not render
 * properly this way. Please use the `enabled` property instead to
 * display or hide the refresher.
 *
 * @usage
 * ```html
 * <ion-content>
 *
 *   <ion-refresher (ionRefresh)="doRefresh($event)">
 *     <ion-refresher-content></ion-refresher-content>
 *   </ion-refresher>
 *
 * </ion-content>
 * ```
 *
 * ```ts
 * @Component({...})
 * export class NewsFeedPage {
 *
 *   doRefresh(refresher) {
 *     console.log('Begin async operation', refresher);
 *
 *     setTimeout(() => {
 *       console.log('Async operation has ended');
 *       refresher.complete();
 *     }, 2000);
 *   }
 *
 * }
 * ```
 *
 *
 * ## Refresher Content
 *
 * By default, Ionic provides the pulling icon and refreshing spinner that
 * looks best for the platform the user is on. However, you can change the
 * default icon and spinner, along with adding text for each state by
 * adding properties to the child `ion-refresher-content` component.
 *
 *  ```html
 *  <ion-content>
 *
 *    <ion-refresher (ionRefresh)="doRefresh($event)">
 *      <ion-refresher-content
 *        pullingIcon="arrow-dropdown"
 *        pullingText="Pull to refresh"
 *        refreshingSpinner="circles"
 *        refreshingText="Refreshing...">
 *      </ion-refresher-content>
 *    </ion-refresher>
 *
 *  </ion-content>
 *  ```
 *
 *
 * ## Further Customizing Refresher Content
 *
 * The `ion-refresher` component holds the refresh logic.
 * It requires a child component in order to display the content.
 * Ionic uses `ion-refresher-content` by default. This component
 * displays the refresher and changes the look depending
 * on the refresher's state. Separating these components
 * allows developers to create their own refresher content
 * components. You could replace our default content with
 * custom SVG or CSS animations.
 *
 * @demo /docs/demos/src/refresher/
 *
 */
import * as ɵngcc0 from '@angular/core';
export declare class Refresher {
    private _plt;
    private _content;
    private _zone;
    _appliedStyles: boolean;
    _didStart: boolean;
    _lastCheck: number;
    _isEnabled: boolean;
    _gesture: GestureDelegate;
    _events: UIEventManager;
    _pointerEvents: PointerEvents;
    _top: string;
    /**
     * The current state which the refresher is in. The refresher's states include:
     *
     * - `inactive` - The refresher is not being pulled down or refreshing and is currently hidden.
     * - `pulling` - The user is actively pulling down the refresher, but has not reached the point yet that if the user lets go, it'll refresh.
     * - `cancelling` - The user pulled down the refresher and let go, but did not pull down far enough to kick off the `refreshing` state. After letting go, the refresher is in the `cancelling` state while it is closing, and will go back to the `inactive` state once closed.
     * - `ready` - The user has pulled down the refresher far enough that if they let go, it'll begin the `refreshing` state.
     * - `refreshing` - The refresher is actively waiting on the async operation to end. Once the refresh handler calls `complete()` it will begin the `completing` state.
     * - `completing` - The `refreshing` state has finished and the refresher is in the process of closing itself. Once closed, the refresher will go back to the `inactive` state.
     */
    state: string;
    /**
     * The Y coordinate of where the user started to the pull down the content.
     */
    startY: number;
    /**
     * The current touch or mouse event's Y coordinate.
     */
    currentY: number;
    /**
     * The distance between the start of the pull and the current touch or
     * mouse event's Y coordinate.
     */
    deltaY: number;
    /**
     * A number representing how far down the user has pulled.
     * The number `0` represents the user hasn't pulled down at all. The
     * number `1`, and anything greater than `1`, represents that the user
     * has pulled far enough down that when they let go then the refresh will
     * happen. If they let go and the number is less than `1`, then the
     * refresh will not happen, and the content will return to it's original
     * position.
     */
    progress: number;
    /**
     * @input {number} The min distance the user must pull down until the
     * refresher can go into the `refreshing` state. Default is `60`.
     */
    pullMin: number;
    /**
     * @input {number} The maximum distance of the pull until the refresher
     * will automatically go into the `refreshing` state. By default, the pull
     * maximum will be the result of `pullMin + 60`.
     */
    pullMax: number;
    /**
     * @input {number} How many milliseconds it takes to close the refresher. Default is `280`.
     */
    closeDuration: number;
    /**
     * @input {number} How many milliseconds it takes the refresher to to snap back to the `refreshing` state. Default is `280`.
     */
    snapbackDuration: number;
    /**
     * @input {boolean} If the refresher is enabled or not. This should be used in place of an `ngIf`. Default is `true`.
     */
    enabled: boolean;
    /**
     * @output {event} Emitted when the user lets go and has pulled down
     * far enough, which would be farther than the `pullMin`, then your refresh hander if
     * fired and the state is updated to `refreshing`. From within your refresh handler,
     * you must call the `complete()` method when your async operation has completed.
     */
    ionRefresh: EventEmitter<Refresher>;
    /**
     * @output {event} Emitted while the user is pulling down the content and exposing the refresher.
     */
    ionPull: EventEmitter<Refresher>;
    /**
     * @output {event} Emitted when the user begins to start pulling down.
     */
    ionStart: EventEmitter<Refresher>;
    constructor(_plt: Platform, _content: Content, _zone: NgZone, gestureCtrl: GestureController);
    _onStart(ev: TouchEvent): any;
    _onMove(ev: TouchEvent): 1 | 2 | 3 | 0 | 5 | 6 | 8 | 7;
    _onMoveInZone(): 2 | 3 | 4;
    _onEnd(): void;
    _beginRefresh(): void;
    /**
     * Call `complete()` when your async operation has completed.
     * For example, the `refreshing` state is while the app is performing
     * an asynchronous operation, such as receiving more data from an
     * AJAX request. Once the data has been received, you then call this
     * method to signify that the refreshing has completed and to close
     * the refresher. This method also changes the refresher's state from
     * `refreshing` to `completing`.
     */
    complete(): void;
    /**
     * Changes the refresher's state from `refreshing` to `cancelling`.
     */
    cancel(): void;
    _close(state: string, delay: string): void;
    _setCss(y: number, duration: string, overflowVisible: boolean, delay: string): void;
    _setListeners(shouldListen: boolean): void;
    /**
     * @hidden
     */
    ngOnInit(): void;
    /**
     * @hidden
     */
    ngOnDestroy(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<Refresher, [null, { host: true; }, null, null]>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<Refresher, "ion-refresher", never, { "pullMin": "pullMin"; "pullMax": "pullMax"; "closeDuration": "closeDuration"; "snapbackDuration": "snapbackDuration"; "enabled": "enabled"; }, { "ionRefresh": "ionRefresh"; "ionPull": "ionPull"; "ionStart": "ionStart"; }, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVmcmVzaGVyLmQudHMiLCJzb3VyY2VzIjpbInJlZnJlc2hlci5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnRFbWl0dGVyLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRlbnQgfSBmcm9tICcuLi9jb250ZW50L2NvbnRlbnQnO1xuaW1wb3J0IHsgR2VzdHVyZUNvbnRyb2xsZXIsIEdlc3R1cmVEZWxlZ2F0ZSB9IGZyb20gJy4uLy4uL2dlc3R1cmVzL2dlc3R1cmUtY29udHJvbGxlcic7XG5pbXBvcnQgeyBQbGF0Zm9ybSB9IGZyb20gJy4uLy4uL3BsYXRmb3JtL3BsYXRmb3JtJztcbmltcG9ydCB7IFBvaW50ZXJFdmVudHMgfSBmcm9tICcuLi8uLi9nZXN0dXJlcy9wb2ludGVyLWV2ZW50cyc7XG5pbXBvcnQgeyBVSUV2ZW50TWFuYWdlciB9IGZyb20gJy4uLy4uL2dlc3R1cmVzL3VpLWV2ZW50LW1hbmFnZXInO1xuLyoqXG4gKiBAbmFtZSBSZWZyZXNoZXJcbiAqIEBkZXNjcmlwdGlvblxuICogVGhlIFJlZnJlc2hlciBwcm92aWRlcyBwdWxsLXRvLXJlZnJlc2ggZnVuY3Rpb25hbGl0eSBvbiBhIGNvbnRlbnQgY29tcG9uZW50LlxuICogUGxhY2UgdGhlIGBpb24tcmVmcmVzaGVyYCBhcyB0aGUgZmlyc3QgY2hpbGQgb2YgeW91ciBgaW9uLWNvbnRlbnRgIGVsZW1lbnQuXG4gKlxuICogUGFnZXMgY2FuIHRoZW4gbGlzdGVuIHRvIHRoZSByZWZyZXNoZXIncyB2YXJpb3VzIG91dHB1dCBldmVudHMuIFRoZVxuICogYHJlZnJlc2hgIG91dHB1dCBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSB1c2VyIGhhcyBwdWxsZWQgZG93biBmYXJcbiAqIGVub3VnaCB0byBraWNrIG9mZiB0aGUgcmVmcmVzaGluZyBwcm9jZXNzLiBPbmNlIHRoZSBhc3luYyBvcGVyYXRpb25cbiAqIGhhcyBjb21wbGV0ZWQgYW5kIHRoZSByZWZyZXNoaW5nIHNob3VsZCBlbmQsIGNhbGwgYGNvbXBsZXRlKClgLlxuICpcbiAqIE5vdGU6IERvIG5vdCB3cmFwIHRoZSBgaW9uLXJlZnJlc2hlcmAgaW4gYSBgKm5nSWZgLiBJdCB3aWxsIG5vdCByZW5kZXJcbiAqIHByb3Blcmx5IHRoaXMgd2F5LiBQbGVhc2UgdXNlIHRoZSBgZW5hYmxlZGAgcHJvcGVydHkgaW5zdGVhZCB0b1xuICogZGlzcGxheSBvciBoaWRlIHRoZSByZWZyZXNoZXIuXG4gKlxuICogQHVzYWdlXG4gKiBgYGBodG1sXG4gKiA8aW9uLWNvbnRlbnQ+XG4gKlxuICogICA8aW9uLXJlZnJlc2hlciAoaW9uUmVmcmVzaCk9XCJkb1JlZnJlc2goJGV2ZW50KVwiPlxuICogICAgIDxpb24tcmVmcmVzaGVyLWNvbnRlbnQ+PC9pb24tcmVmcmVzaGVyLWNvbnRlbnQ+XG4gKiAgIDwvaW9uLXJlZnJlc2hlcj5cbiAqXG4gKiA8L2lvbi1jb250ZW50PlxuICogYGBgXG4gKlxuICogYGBgdHNcbiAqIEBDb21wb25lbnQoey4uLn0pXG4gKiBleHBvcnQgY2xhc3MgTmV3c0ZlZWRQYWdlIHtcbiAqXG4gKiAgIGRvUmVmcmVzaChyZWZyZXNoZXIpIHtcbiAqICAgICBjb25zb2xlLmxvZygnQmVnaW4gYXN5bmMgb3BlcmF0aW9uJywgcmVmcmVzaGVyKTtcbiAqXG4gKiAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gKiAgICAgICBjb25zb2xlLmxvZygnQXN5bmMgb3BlcmF0aW9uIGhhcyBlbmRlZCcpO1xuICogICAgICAgcmVmcmVzaGVyLmNvbXBsZXRlKCk7XG4gKiAgICAgfSwgMjAwMCk7XG4gKiAgIH1cbiAqXG4gKiB9XG4gKiBgYGBcbiAqXG4gKlxuICogIyMgUmVmcmVzaGVyIENvbnRlbnRcbiAqXG4gKiBCeSBkZWZhdWx0LCBJb25pYyBwcm92aWRlcyB0aGUgcHVsbGluZyBpY29uIGFuZCByZWZyZXNoaW5nIHNwaW5uZXIgdGhhdFxuICogbG9va3MgYmVzdCBmb3IgdGhlIHBsYXRmb3JtIHRoZSB1c2VyIGlzIG9uLiBIb3dldmVyLCB5b3UgY2FuIGNoYW5nZSB0aGVcbiAqIGRlZmF1bHQgaWNvbiBhbmQgc3Bpbm5lciwgYWxvbmcgd2l0aCBhZGRpbmcgdGV4dCBmb3IgZWFjaCBzdGF0ZSBieVxuICogYWRkaW5nIHByb3BlcnRpZXMgdG8gdGhlIGNoaWxkIGBpb24tcmVmcmVzaGVyLWNvbnRlbnRgIGNvbXBvbmVudC5cbiAqXG4gKiAgYGBgaHRtbFxuICogIDxpb24tY29udGVudD5cbiAqXG4gKiAgICA8aW9uLXJlZnJlc2hlciAoaW9uUmVmcmVzaCk9XCJkb1JlZnJlc2goJGV2ZW50KVwiPlxuICogICAgICA8aW9uLXJlZnJlc2hlci1jb250ZW50XG4gKiAgICAgICAgcHVsbGluZ0ljb249XCJhcnJvdy1kcm9wZG93blwiXG4gKiAgICAgICAgcHVsbGluZ1RleHQ9XCJQdWxsIHRvIHJlZnJlc2hcIlxuICogICAgICAgIHJlZnJlc2hpbmdTcGlubmVyPVwiY2lyY2xlc1wiXG4gKiAgICAgICAgcmVmcmVzaGluZ1RleHQ9XCJSZWZyZXNoaW5nLi4uXCI+XG4gKiAgICAgIDwvaW9uLXJlZnJlc2hlci1jb250ZW50PlxuICogICAgPC9pb24tcmVmcmVzaGVyPlxuICpcbiAqICA8L2lvbi1jb250ZW50PlxuICogIGBgYFxuICpcbiAqXG4gKiAjIyBGdXJ0aGVyIEN1c3RvbWl6aW5nIFJlZnJlc2hlciBDb250ZW50XG4gKlxuICogVGhlIGBpb24tcmVmcmVzaGVyYCBjb21wb25lbnQgaG9sZHMgdGhlIHJlZnJlc2ggbG9naWMuXG4gKiBJdCByZXF1aXJlcyBhIGNoaWxkIGNvbXBvbmVudCBpbiBvcmRlciB0byBkaXNwbGF5IHRoZSBjb250ZW50LlxuICogSW9uaWMgdXNlcyBgaW9uLXJlZnJlc2hlci1jb250ZW50YCBieSBkZWZhdWx0LiBUaGlzIGNvbXBvbmVudFxuICogZGlzcGxheXMgdGhlIHJlZnJlc2hlciBhbmQgY2hhbmdlcyB0aGUgbG9vayBkZXBlbmRpbmdcbiAqIG9uIHRoZSByZWZyZXNoZXIncyBzdGF0ZS4gU2VwYXJhdGluZyB0aGVzZSBjb21wb25lbnRzXG4gKiBhbGxvd3MgZGV2ZWxvcGVycyB0byBjcmVhdGUgdGhlaXIgb3duIHJlZnJlc2hlciBjb250ZW50XG4gKiBjb21wb25lbnRzLiBZb3UgY291bGQgcmVwbGFjZSBvdXIgZGVmYXVsdCBjb250ZW50IHdpdGhcbiAqIGN1c3RvbSBTVkcgb3IgQ1NTIGFuaW1hdGlvbnMuXG4gKlxuICogQGRlbW8gL2RvY3MvZGVtb3Mvc3JjL3JlZnJlc2hlci9cbiAqXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIFJlZnJlc2hlciB7XG4gICAgcHJpdmF0ZSBfcGx0O1xuICAgIHByaXZhdGUgX2NvbnRlbnQ7XG4gICAgcHJpdmF0ZSBfem9uZTtcbiAgICBfYXBwbGllZFN0eWxlczogYm9vbGVhbjtcbiAgICBfZGlkU3RhcnQ6IGJvb2xlYW47XG4gICAgX2xhc3RDaGVjazogbnVtYmVyO1xuICAgIF9pc0VuYWJsZWQ6IGJvb2xlYW47XG4gICAgX2dlc3R1cmU6IEdlc3R1cmVEZWxlZ2F0ZTtcbiAgICBfZXZlbnRzOiBVSUV2ZW50TWFuYWdlcjtcbiAgICBfcG9pbnRlckV2ZW50czogUG9pbnRlckV2ZW50cztcbiAgICBfdG9wOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgc3RhdGUgd2hpY2ggdGhlIHJlZnJlc2hlciBpcyBpbi4gVGhlIHJlZnJlc2hlcidzIHN0YXRlcyBpbmNsdWRlOlxuICAgICAqXG4gICAgICogLSBgaW5hY3RpdmVgIC0gVGhlIHJlZnJlc2hlciBpcyBub3QgYmVpbmcgcHVsbGVkIGRvd24gb3IgcmVmcmVzaGluZyBhbmQgaXMgY3VycmVudGx5IGhpZGRlbi5cbiAgICAgKiAtIGBwdWxsaW5nYCAtIFRoZSB1c2VyIGlzIGFjdGl2ZWx5IHB1bGxpbmcgZG93biB0aGUgcmVmcmVzaGVyLCBidXQgaGFzIG5vdCByZWFjaGVkIHRoZSBwb2ludCB5ZXQgdGhhdCBpZiB0aGUgdXNlciBsZXRzIGdvLCBpdCdsbCByZWZyZXNoLlxuICAgICAqIC0gYGNhbmNlbGxpbmdgIC0gVGhlIHVzZXIgcHVsbGVkIGRvd24gdGhlIHJlZnJlc2hlciBhbmQgbGV0IGdvLCBidXQgZGlkIG5vdCBwdWxsIGRvd24gZmFyIGVub3VnaCB0byBraWNrIG9mZiB0aGUgYHJlZnJlc2hpbmdgIHN0YXRlLiBBZnRlciBsZXR0aW5nIGdvLCB0aGUgcmVmcmVzaGVyIGlzIGluIHRoZSBgY2FuY2VsbGluZ2Agc3RhdGUgd2hpbGUgaXQgaXMgY2xvc2luZywgYW5kIHdpbGwgZ28gYmFjayB0byB0aGUgYGluYWN0aXZlYCBzdGF0ZSBvbmNlIGNsb3NlZC5cbiAgICAgKiAtIGByZWFkeWAgLSBUaGUgdXNlciBoYXMgcHVsbGVkIGRvd24gdGhlIHJlZnJlc2hlciBmYXIgZW5vdWdoIHRoYXQgaWYgdGhleSBsZXQgZ28sIGl0J2xsIGJlZ2luIHRoZSBgcmVmcmVzaGluZ2Agc3RhdGUuXG4gICAgICogLSBgcmVmcmVzaGluZ2AgLSBUaGUgcmVmcmVzaGVyIGlzIGFjdGl2ZWx5IHdhaXRpbmcgb24gdGhlIGFzeW5jIG9wZXJhdGlvbiB0byBlbmQuIE9uY2UgdGhlIHJlZnJlc2ggaGFuZGxlciBjYWxscyBgY29tcGxldGUoKWAgaXQgd2lsbCBiZWdpbiB0aGUgYGNvbXBsZXRpbmdgIHN0YXRlLlxuICAgICAqIC0gYGNvbXBsZXRpbmdgIC0gVGhlIGByZWZyZXNoaW5nYCBzdGF0ZSBoYXMgZmluaXNoZWQgYW5kIHRoZSByZWZyZXNoZXIgaXMgaW4gdGhlIHByb2Nlc3Mgb2YgY2xvc2luZyBpdHNlbGYuIE9uY2UgY2xvc2VkLCB0aGUgcmVmcmVzaGVyIHdpbGwgZ28gYmFjayB0byB0aGUgYGluYWN0aXZlYCBzdGF0ZS5cbiAgICAgKi9cbiAgICBzdGF0ZTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBZIGNvb3JkaW5hdGUgb2Ygd2hlcmUgdGhlIHVzZXIgc3RhcnRlZCB0byB0aGUgcHVsbCBkb3duIHRoZSBjb250ZW50LlxuICAgICAqL1xuICAgIHN0YXJ0WTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHRvdWNoIG9yIG1vdXNlIGV2ZW50J3MgWSBjb29yZGluYXRlLlxuICAgICAqL1xuICAgIGN1cnJlbnRZOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogVGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIHN0YXJ0IG9mIHRoZSBwdWxsIGFuZCB0aGUgY3VycmVudCB0b3VjaCBvclxuICAgICAqIG1vdXNlIGV2ZW50J3MgWSBjb29yZGluYXRlLlxuICAgICAqL1xuICAgIGRlbHRhWTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEEgbnVtYmVyIHJlcHJlc2VudGluZyBob3cgZmFyIGRvd24gdGhlIHVzZXIgaGFzIHB1bGxlZC5cbiAgICAgKiBUaGUgbnVtYmVyIGAwYCByZXByZXNlbnRzIHRoZSB1c2VyIGhhc24ndCBwdWxsZWQgZG93biBhdCBhbGwuIFRoZVxuICAgICAqIG51bWJlciBgMWAsIGFuZCBhbnl0aGluZyBncmVhdGVyIHRoYW4gYDFgLCByZXByZXNlbnRzIHRoYXQgdGhlIHVzZXJcbiAgICAgKiBoYXMgcHVsbGVkIGZhciBlbm91Z2ggZG93biB0aGF0IHdoZW4gdGhleSBsZXQgZ28gdGhlbiB0aGUgcmVmcmVzaCB3aWxsXG4gICAgICogaGFwcGVuLiBJZiB0aGV5IGxldCBnbyBhbmQgdGhlIG51bWJlciBpcyBsZXNzIHRoYW4gYDFgLCB0aGVuIHRoZVxuICAgICAqIHJlZnJlc2ggd2lsbCBub3QgaGFwcGVuLCBhbmQgdGhlIGNvbnRlbnQgd2lsbCByZXR1cm4gdG8gaXQncyBvcmlnaW5hbFxuICAgICAqIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIHByb2dyZXNzOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQGlucHV0IHtudW1iZXJ9IFRoZSBtaW4gZGlzdGFuY2UgdGhlIHVzZXIgbXVzdCBwdWxsIGRvd24gdW50aWwgdGhlXG4gICAgICogcmVmcmVzaGVyIGNhbiBnbyBpbnRvIHRoZSBgcmVmcmVzaGluZ2Agc3RhdGUuIERlZmF1bHQgaXMgYDYwYC5cbiAgICAgKi9cbiAgICBwdWxsTWluOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQGlucHV0IHtudW1iZXJ9IFRoZSBtYXhpbXVtIGRpc3RhbmNlIG9mIHRoZSBwdWxsIHVudGlsIHRoZSByZWZyZXNoZXJcbiAgICAgKiB3aWxsIGF1dG9tYXRpY2FsbHkgZ28gaW50byB0aGUgYHJlZnJlc2hpbmdgIHN0YXRlLiBCeSBkZWZhdWx0LCB0aGUgcHVsbFxuICAgICAqIG1heGltdW0gd2lsbCBiZSB0aGUgcmVzdWx0IG9mIGBwdWxsTWluICsgNjBgLlxuICAgICAqL1xuICAgIHB1bGxNYXg6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBAaW5wdXQge251bWJlcn0gSG93IG1hbnkgbWlsbGlzZWNvbmRzIGl0IHRha2VzIHRvIGNsb3NlIHRoZSByZWZyZXNoZXIuIERlZmF1bHQgaXMgYDI4MGAuXG4gICAgICovXG4gICAgY2xvc2VEdXJhdGlvbjogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEBpbnB1dCB7bnVtYmVyfSBIb3cgbWFueSBtaWxsaXNlY29uZHMgaXQgdGFrZXMgdGhlIHJlZnJlc2hlciB0byB0byBzbmFwIGJhY2sgdG8gdGhlIGByZWZyZXNoaW5nYCBzdGF0ZS4gRGVmYXVsdCBpcyBgMjgwYC5cbiAgICAgKi9cbiAgICBzbmFwYmFja0R1cmF0aW9uOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQGlucHV0IHtib29sZWFufSBJZiB0aGUgcmVmcmVzaGVyIGlzIGVuYWJsZWQgb3Igbm90LiBUaGlzIHNob3VsZCBiZSB1c2VkIGluIHBsYWNlIG9mIGFuIGBuZ0lmYC4gRGVmYXVsdCBpcyBgdHJ1ZWAuXG4gICAgICovXG4gICAgZW5hYmxlZDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAb3V0cHV0IHtldmVudH0gRW1pdHRlZCB3aGVuIHRoZSB1c2VyIGxldHMgZ28gYW5kIGhhcyBwdWxsZWQgZG93blxuICAgICAqIGZhciBlbm91Z2gsIHdoaWNoIHdvdWxkIGJlIGZhcnRoZXIgdGhhbiB0aGUgYHB1bGxNaW5gLCB0aGVuIHlvdXIgcmVmcmVzaCBoYW5kZXIgaWZcbiAgICAgKiBmaXJlZCBhbmQgdGhlIHN0YXRlIGlzIHVwZGF0ZWQgdG8gYHJlZnJlc2hpbmdgLiBGcm9tIHdpdGhpbiB5b3VyIHJlZnJlc2ggaGFuZGxlcixcbiAgICAgKiB5b3UgbXVzdCBjYWxsIHRoZSBgY29tcGxldGUoKWAgbWV0aG9kIHdoZW4geW91ciBhc3luYyBvcGVyYXRpb24gaGFzIGNvbXBsZXRlZC5cbiAgICAgKi9cbiAgICBpb25SZWZyZXNoOiBFdmVudEVtaXR0ZXI8UmVmcmVzaGVyPjtcbiAgICAvKipcbiAgICAgKiBAb3V0cHV0IHtldmVudH0gRW1pdHRlZCB3aGlsZSB0aGUgdXNlciBpcyBwdWxsaW5nIGRvd24gdGhlIGNvbnRlbnQgYW5kIGV4cG9zaW5nIHRoZSByZWZyZXNoZXIuXG4gICAgICovXG4gICAgaW9uUHVsbDogRXZlbnRFbWl0dGVyPFJlZnJlc2hlcj47XG4gICAgLyoqXG4gICAgICogQG91dHB1dCB7ZXZlbnR9IEVtaXR0ZWQgd2hlbiB0aGUgdXNlciBiZWdpbnMgdG8gc3RhcnQgcHVsbGluZyBkb3duLlxuICAgICAqL1xuICAgIGlvblN0YXJ0OiBFdmVudEVtaXR0ZXI8UmVmcmVzaGVyPjtcbiAgICBjb25zdHJ1Y3RvcihfcGx0OiBQbGF0Zm9ybSwgX2NvbnRlbnQ6IENvbnRlbnQsIF96b25lOiBOZ1pvbmUsIGdlc3R1cmVDdHJsOiBHZXN0dXJlQ29udHJvbGxlcik7XG4gICAgX29uU3RhcnQoZXY6IFRvdWNoRXZlbnQpOiBhbnk7XG4gICAgX29uTW92ZShldjogVG91Y2hFdmVudCk6IDEgfCAyIHwgMyB8IDAgfCA1IHwgNiB8IDggfCA3O1xuICAgIF9vbk1vdmVJblpvbmUoKTogMiB8IDMgfCA0O1xuICAgIF9vbkVuZCgpOiB2b2lkO1xuICAgIF9iZWdpblJlZnJlc2goKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBDYWxsIGBjb21wbGV0ZSgpYCB3aGVuIHlvdXIgYXN5bmMgb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWQuXG4gICAgICogRm9yIGV4YW1wbGUsIHRoZSBgcmVmcmVzaGluZ2Agc3RhdGUgaXMgd2hpbGUgdGhlIGFwcCBpcyBwZXJmb3JtaW5nXG4gICAgICogYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbiwgc3VjaCBhcyByZWNlaXZpbmcgbW9yZSBkYXRhIGZyb20gYW5cbiAgICAgKiBBSkFYIHJlcXVlc3QuIE9uY2UgdGhlIGRhdGEgaGFzIGJlZW4gcmVjZWl2ZWQsIHlvdSB0aGVuIGNhbGwgdGhpc1xuICAgICAqIG1ldGhvZCB0byBzaWduaWZ5IHRoYXQgdGhlIHJlZnJlc2hpbmcgaGFzIGNvbXBsZXRlZCBhbmQgdG8gY2xvc2VcbiAgICAgKiB0aGUgcmVmcmVzaGVyLiBUaGlzIG1ldGhvZCBhbHNvIGNoYW5nZXMgdGhlIHJlZnJlc2hlcidzIHN0YXRlIGZyb21cbiAgICAgKiBgcmVmcmVzaGluZ2AgdG8gYGNvbXBsZXRpbmdgLlxuICAgICAqL1xuICAgIGNvbXBsZXRlKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgcmVmcmVzaGVyJ3Mgc3RhdGUgZnJvbSBgcmVmcmVzaGluZ2AgdG8gYGNhbmNlbGxpbmdgLlxuICAgICAqL1xuICAgIGNhbmNlbCgpOiB2b2lkO1xuICAgIF9jbG9zZShzdGF0ZTogc3RyaW5nLCBkZWxheTogc3RyaW5nKTogdm9pZDtcbiAgICBfc2V0Q3NzKHk6IG51bWJlciwgZHVyYXRpb246IHN0cmluZywgb3ZlcmZsb3dWaXNpYmxlOiBib29sZWFuLCBkZWxheTogc3RyaW5nKTogdm9pZDtcbiAgICBfc2V0TGlzdGVuZXJzKHNob3VsZExpc3RlbjogYm9vbGVhbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25Jbml0KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG59XG4iXX0=